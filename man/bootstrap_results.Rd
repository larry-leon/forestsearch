% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrap_dofuture.R, R/bootstrap_results.R
\name{bootstrap_results}
\alias{bootstrap_results}
\title{Bootstrap Results for ForestSearch with Bias Correction}
\usage{
bootstrap_results(
  fs.est,
  df_boot_analysis,
  cox.formula.boot,
  nb_boots,
  show_three,
  H_obs,
  Hc_obs
)

bootstrap_results(
  fs.est,
  df_boot_analysis,
  cox.formula.boot,
  nb_boots,
  show_three,
  H_obs,
  Hc_obs
)
}
\arguments{
\item{fs.est}{List. ForestSearch results object from \code{\link{forestsearch}}.
Must contain:
\itemize{
\item \code{df.est}: Data frame with analysis data including \code{treat.recommend}
\item \code{confounders.candidate}: Character vector of confounder names
\item \code{args_call_all}: List of original forestsearch call arguments
}}

\item{df_boot_analysis}{Data frame. Bootstrap analysis data with same structure
as \code{fs.est$df.est}. Must contain columns for outcome, event, treatment,
and the \code{treat.recommend} flag.}

\item{cox.formula.boot}{Formula. Cox model formula for bootstrap, typically
created by \code{\link{build_cox_formula}}. Should be of form
\code{Surv(outcome, event) ~ treatment}.}

\item{nb_boots}{Integer. Number of bootstrap samples to generate (e.g., 500-1000).
More iterations provide better bias correction but increase computation time.}

\item{show_three}{Logical. If \code{TRUE}, prints detailed progress for the
first three bootstrap iterations for debugging purposes. Default: \code{FALSE}.}

\item{H_obs}{Numeric. Observed log hazard ratio for subgroup H (harm/questionable group,
\code{treat.recommend == 0}) from original sample. Used as reference for
bias correction.}

\item{Hc_obs}{Numeric. Observed log hazard ratio for subgroup H^c (complement/recommend,
\code{treat.recommend == 1}) from original sample. Used as reference for
bias correction.}
}
\value{
Data.table with one row per bootstrap iteration and columns:
\describe{
\item{H_biasadj_1}{Bias-corrected estimate for H using method 1:
\code{H_obs - (Hstar_star - Hstar_obs)}}
\item{H_biasadj_2}{Bias-corrected estimate for H using method 2:
\code{2*H_obs - (H_star + Hstar_star - Hstar_obs)}}
\item{Hc_biasadj_1}{Bias-corrected estimate for H^c using method 1}
\item{Hc_biasadj_2}{Bias-corrected estimate for H^c using method 2}
\item{tmins_search}{Numeric. Minutes spent on subgroup search in this iteration}
\item{max_sg_est}{Numeric. Maximum subgroup hazard ratio found}
\item{prop_maxk}{Numeric. Proportion of maximum K factors used}
\item{L}{Integer. Number of candidate factors evaluated}
\item{max_count}{Integer. Maximum number of factor combinations}
}
Rows where no valid subgroup was found will have \code{NA} for bias corrections.

Data.table with one row per bootstrap iteration and columns:
\describe{
\item{H_biasadj_1}{Bias-corrected estimate for H using method 1:
\code{H_obs - (Hstar_star - Hstar_obs)}}
\item{H_biasadj_2}{Bias-corrected estimate for H using method 2:
\code{2*H_obs - (H_star + Hstar_star - Hstar_obs)}}
\item{Hc_biasadj_1}{Bias-corrected estimate for H^c using method 1}
\item{Hc_biasadj_2}{Bias-corrected estimate for H^c using method 2}
\item{tmins_search}{Numeric. Minutes spent on subgroup search in this iteration}
\item{max_sg_est}{Numeric. Maximum subgroup hazard ratio found}
\item{prop_maxk}{Numeric. Proportion of maximum K factors used}
\item{L}{Integer. Number of candidate factors evaluated}
\item{max_count}{Integer. Maximum number of factor combinations}
}
Rows where no valid subgroup was found will have \code{NA} for bias corrections.
}
\description{
Runs bootstrap analysis for ForestSearch, fitting Cox models and computing
bias-corrected estimates and valid CIs (see vignette for references)

Runs bootstrap analysis for ForestSearch, fitting Cox models and computing
bias-corrected estimates and valid CIs (see vignette for references)
}
\note{
This function is designed to be called within a \code{foreach} loop
with \code{\%dofuture\%} operator. It requires:
\itemize{
\item All functions in \code{\link{get_bootstrap_exports}} to be available
in the parallel workers
\item Packages listed in \code{BOOTSTRAP_REQUIRED_PACKAGES} to be installed
\item Proper parallel backend setup via \code{\link{setup_parallel_SGcons}}
}

This function is designed to be called within a \code{foreach} loop
with \code{\%dofuture\%} operator. It requires:
\itemize{
\item All functions in \code{\link{get_bootstrap_exports}} to be available
in the parallel workers
\item Packages listed in \code{BOOTSTRAP_REQUIRED_PACKAGES} to be installed
\item Proper parallel backend setup via \code{\link{setup_parallel_SGcons}}
}
}
\section{Bias Correction Methods}{

The function implements two bias correction approaches:
\enumerate{
\item \strong{Method 1 (Simple Optimism)}: Corrects for optimism using the difference
between bootstrap internal validation (\code{Hstar_star}) and
bootstrap-on-original (\code{Hstar_obs}):
\deqn{H_{adj1} = H_{obs} - (H*_{star} - H*_{obs})}
\item \strong{Method 2 (Double Bootstrap)}: Uses both the bootstrap estimate and the
optimism correction for a more conservative adjustment:
\deqn{H_{adj2} = 2 \times H_{obs} - (H_{star} + H*_{star} - H*_{obs})}
}
where:
\itemize{
\item \code{H_obs}: Original subgroup HR on original data
\item \code{H_star}: Original subgroup HR on bootstrap data
\item \code{Hstar_obs}: New subgroup (found in bootstrap) HR on original data
\item \code{Hstar_star}: New subgroup (found in bootstrap) HR on bootstrap data
}


The function implements two bias correction approaches:
\enumerate{
\item \strong{Method 1 (Simple Optimism)}: Corrects for optimism using the difference
between bootstrap internal validation (\code{Hstar_star}) and
bootstrap-on-original (\code{Hstar_obs}):
\deqn{H_{adj1} = H_{obs} - (H*_{star} - H*_{obs})}
\item \strong{Method 2 (Double Bootstrap)}: Uses both the bootstrap estimate and the
optimism correction for a more conservative adjustment:
\deqn{H_{adj2} = 2 \times H_{obs} - (H_{star} + H*_{star} - H*_{obs})}
}
where:
\itemize{
\item \code{H_obs}: Original subgroup HR on original data
\item \code{H_star}: Original subgroup HR on bootstrap data
\item \code{Hstar_obs}: New subgroup (found in bootstrap) HR on original data
\item \code{Hstar_star}: New subgroup (found in bootstrap) HR on bootstrap data
}
}

\section{Computational Details}{

\itemize{
\item Uses \code{doFuture} backend for parallel execution (configured externally)
\item Sets reproducible seeds: \code{8316951 + boot * 100} for each iteration
\item Each bootstrap iteration runs full ForestSearch pipeline including
variable selection, subgroup search, and consistency evaluation
\item Sequential execution within each bootstrap prevents nested parallelization
\item Failed bootstrap iterations generate warnings but don't stop execution
\item Confounders are removed from bootstrap data to force fresh variable selection
}


\itemize{
\item Uses \code{doFuture} backend for parallel execution (configured externally)
\item Sets reproducible seeds: \code{8316951 + boot * 100} for each iteration
\item Each bootstrap iteration runs full ForestSearch pipeline including
variable selection, subgroup search, and consistency evaluation
\item Sequential execution within each bootstrap prevents nested parallelization
\item Failed bootstrap iterations generate warnings but don't stop execution
\item Confounders are removed from bootstrap data to force fresh variable selection
}
}

\section{Bootstrap Configuration}{

Each bootstrap iteration modifies ForestSearch arguments to:
\itemize{
\item \strong{Suppress output}: \code{details}, \code{showten_subgroups},
\code{plot.sg}, \code{plot.grf} all set to \code{FALSE}
\item \strong{Force re-selection}: \code{grf_res} and \code{grf_cuts} set to \code{NULL}
\item \strong{Prevent nested parallel}: \code{parallel_args$plan = "sequential"},
\code{workers = 1}
}


Each bootstrap iteration modifies ForestSearch arguments to:
\itemize{
\item \strong{Suppress output}: \code{details}, \code{showten_subgroups},
\code{plot.sg}, \code{plot.grf} all set to \code{FALSE}
\item \strong{Force re-selection}: \code{grf_res} and \code{grf_cuts} set to \code{NULL}
\item \strong{Prevent nested parallel}: \code{parallel_args$plan = "sequential"},
\code{workers = 1}
}
}

\section{Performance Considerations}{

\itemize{
\item Typical runtime: 1-5 seconds per bootstrap iteration
\item For 1000 bootstraps with 6 workers: ~3-10 minutes total
\item Memory usage scales with dataset size and number of workers
\item Consider reducing \code{nb_boots} for initial testing (e.g., 100)
}


\itemize{
\item Typical runtime: 1-5 seconds per bootstrap iteration
\item For 1000 bootstraps with 6 workers: ~3-10 minutes total
\item Memory usage scales with dataset size and number of workers
\item Consider reducing \code{nb_boots} for initial testing (e.g., 100)
}
}

\section{Error Handling}{

The function gracefully handles three failure modes:
\enumerate{
\item Bootstrap sample creation fails: Returns row with all \code{NA}
\item ForestSearch fails to run: Warns and returns row with all \code{NA}
\item ForestSearch runs but finds no subgroup: Returns row with all \code{NA}
}
All three cases ensure the foreach loop can still combine results via \code{rbind}.


The function gracefully handles three failure modes:
\enumerate{
\item Bootstrap sample creation fails: Returns row with all \code{NA}
\item ForestSearch fails to run: Warns and returns row with all \code{NA}
\item ForestSearch runs but finds no subgroup: Returns row with all \code{NA}
}
All three cases ensure the foreach loop can still combine results via \code{rbind}.
}

\examples{
\dontrun{
# Typically called via forestsearch_bootstrap_dofuture()
# Manual usage for debugging:

# 1. Fit initial ForestSearch model
fs_result <- forestsearch(
  df.analysis = mydata,
  outcome.name = "time",
  event.name = "status",
  treat.name = "treatment",
  confounders.name = c("age", "sex", "stage")
)

# 2. Build Cox formula
cox_formula <- build_cox_formula("time", "status", "treatment")

# 3. Get observed estimates
cox_fits <- fit_cox_models(fs_result$df.est, cox_formula)

# 4. Set up parallel backend
library(doFuture)
registerDoFuture()
plan(multisession, workers = 6)

# 5. Run bootstrap (note: this is already parallelized internally)
boot_results <- bootstrap_results(
  fs.est = fs_result,
  df_boot_analysis = fs_result$df.est,
  cox.formula.boot = cox_formula,
  nb_boots = 100,
  show_three = TRUE,
  H_obs = cox_fits$H_obs,
  Hc_obs = cox_fits$Hc_obs
)

# 6. Check results
summary(boot_results)

# Proportion of bootstraps that found a subgroup
mean(!is.na(boot_results$H_biasadj_2))
}

\dontrun{
# Typically called via forestsearch_bootstrap_dofuture()
# Manual usage for debugging:

# 1. Fit initial ForestSearch model
fs_result <- forestsearch(
  df.analysis = mydata,
  outcome.name = "time",
  event.name = "status",
  treat.name = "treatment",
  confounders.name = c("age", "sex", "stage")
)

# 2. Build Cox formula
cox_formula <- build_cox_formula("time", "status", "treatment")

# 3. Get observed estimates
cox_fits <- fit_cox_models(fs_result$df.est, cox_formula)

# 4. Set up parallel backend
library(doFuture)
registerDoFuture()
plan(multisession, workers = 6)

# 5. Run bootstrap (note: this is already parallelized internally)
boot_results <- bootstrap_results(
  fs.est = fs_result,
  df_boot_analysis = fs_result$df.est,
  cox.formula.boot = cox_formula,
  nb_boots = 100,
  show_three = TRUE,
  H_obs = cox_fits$H_obs,
  Hc_obs = cox_fits$Hc_obs
)

# 6. Check results
summary(boot_results)

# Proportion of bootstraps that found a subgroup
mean(!is.na(boot_results$H_biasadj_2))
}

}
\seealso{
\code{\link{forestsearch_bootstrap_dofuture}} for the wrapper function that
sets up parallelization and calls this function
\code{\link{build_cox_formula}} for creating the Cox formula
\code{\link{fit_cox_models}} for initial Cox model fitting
\code{\link{get_Cox_sg}} for Cox model fitting on subgroups
\code{\link{get_dfRes}} for processing bootstrap results into confidence intervals
\code{\link{bootstrap_ystar}} for generating the Ystar matrix

\code{\link{forestsearch_bootstrap_dofuture}} for the wrapper function that
sets up parallelization and calls this function
\code{\link{build_cox_formula}} for creating the Cox formula
\code{\link{fit_cox_models}} for initial Cox model fitting
\code{\link{get_Cox_sg}} for Cox model fitting on subgroups
\code{\link{get_dfRes}} for processing bootstrap results into confidence intervals
\code{\link{bootstrap_ystar}} for generating the Ystar matrix
}
\concept{bootstrap functions}
