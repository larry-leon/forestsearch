<html><head><style>body { font-family: Arial, sans-serif; background-color: #f7f7f7; }.user-msg { background-color: #ffd8b1; color: black; padding: 10px; margin: 10px 0; border-radius: 10px; }.bot-msg { background-color: #e1f5fe; color: black; padding: 10px; margin: 10px 0; border-radius: 10px; }pre { background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; padding: 10px; white-space: pre-wrap; word-wrap: break-word; }img { max-width: 100%; height: auto; }</style></head><body><div class="user-msg"><strong>User:</strong> üìÅ[get_FSdata_helpers.R]</div><div class="user-msg"><strong>User:</strong> üìÅ[get_FSdata.R]</div><div class="user-msg"><strong>User:</strong> üìÅ[subgroup_search.R]</div><div class="user-msg"><strong>User:</strong> please inspect these files</div><div class="bot-msg"><strong>ADW:</strong> <p>I will inspect the contents of the uploaded R files: <code>get_FSdata_helpers.R</code>, <code>get_FSdata.R</code>, and <code>subgroup_search.R</code>. This will involve reading and summarizing their contents to provide an overview of their functions and structure.</p>
<p>Let's start by displaying the contents of each file.
üü¢Working:</p>
<pre><code class="language-R"># Read and display the contents of the uploaded R files
helpers_content &lt;- readLines('get_FSdata_helpers.R')
fsdata_content &lt;- readLines('get_FSdata.R')
subgroup_content &lt;- readLines('subgroup_search.R')

list(
  get_FSdata_helpers = helpers_content[1:20], # Show first 20 lines for preview
  get_FSdata = fsdata_content[1:20],
  subgroup_search = subgroup_content[1:20]
)
</code></pre></div><div class="bot-msg"><strong>ADW:</strong> <p>‚úîÔ∏èTerminal output:</p>
<pre><code class="language-shell">$get_FSdata_helpers
 [1] &quot;&quot;                                                                                      
 [2] &quot;#' Check if a variable is continuous&quot;                                                  
 [3] &quot;#'&quot;                                                                                    
 [4] &quot;#' Determines if a variable is continuous based on the number of unique values.&quot;       
 [5] &quot;#'&quot;                                                                                    
 [6] &quot;#' @param x A vector.&quot;                                                                 
 [7] &quot;#' @param cutoff Integer. Minimum number of unique values to be considered continuous.&quot;
 [8] &quot;#' @return 1 if continuous, 2 if not.&quot;                                                 
 [9] &quot;#' @export&quot;                                                                            
[10] &quot;&quot;                                                                                      
[11] &quot;is.continuous &lt;- function(x,cutoff = 4){ifelse(length(unique(x))&gt;=cutoff,1,2)}&quot;        
[12] &quot;&quot;                                                                                      
[13] &quot;#' 25th Percentile (Quantile Low)&quot;                                                     
[14] &quot;#'&quot;                                                                                    
[15] &quot;#' Returns the 25th percentile of a numeric vector.&quot;                                   
[16] &quot;#'&quot;                                                                                    
[17] &quot;#' @param x A numeric vector.&quot;                                                         
[18] &quot;#' @return Numeric value of the 25th percentile.&quot;                                      
[19] &quot;#' @importFrom stats quantile&quot;                                                         
[20] &quot;#' @export&quot;                                                                            

$get_FSdata
 [1] &quot;&quot;                                                                                                            
 [2] &quot;#' ForestSearch Data Preparation and Feature Selection&quot;                                                      
 [3] &quot;#'&quot;                                                                                                          
 [4] &quot;#' Prepares a dataset for ForestSearch, including options for LASSO-based dimension reduction,&quot;              
 [5] &quot;#' GRF cuts, forced cuts, and flexible cut strategies. Returns a list with the processed data,&quot;              
 [6] &quot;#' subgroup factor names, cut expressions, and LASSO selection results.&quot;                                     
 [7] &quot;#'&quot;                                                                                                          
 [8] &quot;#' @param df Data frame containing the data.&quot;                                                                
 [9] &quot;#' @param use_lasso Logical. Whether to use LASSO for dimension reduction.&quot;                                  
[10] &quot;#' @param use_grf Logical. Whether to use GRF cuts.&quot;                                                         
[11] &quot;#' @param grf_cuts Character vector of GRF cut expressions.&quot;                                                 
[12] &quot;#' @param confounders.name Character vector of confounder variable names.&quot;                                   
[13] &quot;#' @param cont.cutoff Integer. Cutoff for continuous variable determination.&quot;                                
[14] &quot;#' @param conf_force Character vector of forced cut expressions.&quot;                                            
[15] &quot;#' @param conf.cont_medians Character vector of continuous confounders to cut at median.&quot;                    
[16] &quot;#' @param conf.cont_medians_force Character vector of additional continuous confounders to force median cut.&quot;
[17] &quot;#' @param replace_med_grf Logical. If TRUE, removes median cuts that overlap with GRF cuts.&quot;                 
[18] &quot;#' @param defaultcut_names Character vector of confounders to force default cuts.&quot;                           
[19] &quot;#' @param cut_type Character. \&quot;default\&quot; or \&quot;median\&quot; for cut strategy.&quot;                                   
[20] &quot;#' @param exclude_cuts Character vector of cut expressions to exclude.&quot;                                      

$subgroup_search
 [1] &quot;# minp = Minimum prevalence rate&quot;                                                                          
 [2] &quot;# Only combinations where all factors have prevalance at least minp are evaluated&quot;                         
 [3] &quot;# Minimum difference in subgroup sample size&quot;                                                              
 [4] &quot;# Max subgroup size is n: After first factor x1 is added, the sample size for&quot;                             
 [5] &quot;# the subgroup is then n(x1), say.   If combining with next factor x2&quot;                                     
 [6] &quot;# does not reduce the sample size by rmin, then consider this combination \&quot;redundant\&quot;&quot;                   
 [7] &quot;# Adding d.min to require min(Events) per treatment arm (d0.min for control, d1.min for treatment)&quot;        
 [8] &quot;# covs.in[isin,]&lt;-unlist(lapply(covs.in[isin,],function(x){ifelse(x==1,0,1)})) # slower&quot;                   
 [9] &quot;&quot;                                                                                                          
[10] &quot;&quot;                                                                                                          
[11] &quot;&quot;                                                                                                          
[12] &quot;#' Get all combinations of subgroup factors up to maxk&quot;                                                    
[13] &quot;#'&quot;                                                                                                        
[14] &quot;#' Generates all possible combinations of subgroup factors up to a specified maximum size.&quot;                
[15] &quot;#'&quot;                                                                                                        
[16] &quot;#' @param L Integer. Number of subgroup factors.&quot;                                                          
[17] &quot;#' @param maxk Integer. Maximum number of factors in a combination.&quot;                                       
[18] &quot;#' @return List with \\code{max_count} (total combinations) and \\code{indices_list} (indices for each k).&quot;
[19] &quot;#' @importFrom utils combn&quot;                                                                                
[20] &quot;#' @export&quot;                                                                                                
</code></pre></div><div class="user-msg"><strong>User:</strong> OK. Proceed with coding and don't need to explain your plan again.</div><div class="bot-msg"><strong>ADW:</strong> <p>üü¢Working:</p>
<pre><code class="language-R"># Display the full contents of each file for detailed inspection
helpers_content &lt;- readLines('get_FSdata_helpers.R')
fsdata_content &lt;- readLines('get_FSdata.R')
subgroup_content &lt;- readLines('subgroup_search.R')

list(
  get_FSdata_helpers = helpers_content,
  get_FSdata = fsdata_content,
  subgroup_search = subgroup_content
)
</code></pre></div><div class="bot-msg"><strong>ADW:</strong> <p>‚úîÔ∏èTerminal output:</p>
<pre><code class="language-shell">$get_FSdata_helpers
  [1] &quot;&quot;                                                                                                     
  [2] &quot;#' Check if a variable is continuous&quot;                                                                 
  [3] &quot;#'&quot;                                                                                                   
  [4] &quot;#' Determines if a variable is continuous based on the number of unique values.&quot;                      
  [5] &quot;#'&quot;                                                                                                   
  [6] &quot;#' @param x A vector.&quot;                                                                                
  [7] &quot;#' @param cutoff Integer. Minimum number of unique values to be considered continuous.&quot;               
  [8] &quot;#' @return 1 if continuous, 2 if not.&quot;                                                                
  [9] &quot;#' @export&quot;                                                                                           
 [10] &quot;&quot;                                                                                                     
 [11] &quot;is.continuous &lt;- function(x,cutoff = 4){ifelse(length(unique(x))&gt;=cutoff,1,2)}&quot;                       
 [12] &quot;&quot;                                                                                                     
 [13] &quot;#' 25th Percentile (Quantile Low)&quot;                                                                    
 [14] &quot;#'&quot;                                                                                                   
 [15] &quot;#' Returns the 25th percentile of a numeric vector.&quot;                                                  
 [16] &quot;#'&quot;                                                                                                   
 [17] &quot;#' @param x A numeric vector.&quot;                                                                        
 [18] &quot;#' @return Numeric value of the 25th percentile.&quot;                                                     
 [19] &quot;#' @importFrom stats quantile&quot;                                                                        
 [20] &quot;#' @export&quot;                                                                                           
 [21] &quot;&quot;                                                                                                     
 [22] &quot;qlow &lt;- function(x) c(quantile(x,0.25))&quot;                                                              
 [23] &quot;&quot;                                                                                                     
 [24] &quot;&quot;                                                                                                     
 [25] &quot;#' 75th Percentile (Quantile High)&quot;                                                                   
 [26] &quot;#'&quot;                                                                                                   
 [27] &quot;#' Returns the 75th percentile of a numeric vector.&quot;                                                  
 [28] &quot;#'&quot;                                                                                                   
 [29] &quot;#' @param x A numeric vector.&quot;                                                                        
 [30] &quot;#' @return Numeric value of the 75th percentile.&quot;                                                     
 [31] &quot;#' @importFrom stats quantile&quot;                                                                        
 [32] &quot;#' @export&quot;                                                                                           
 [33] &quot;&quot;                                                                                                     
 [34] &quot;qhigh &lt;- function(x) c(quantile(x,0.75))&quot;                                                             
 [35] &quot;&quot;                                                                                                     
 [36] &quot;# For continuous variables in conf_force_names&quot;                                                       
 [37] &quot;# setup for mean, median, qlow, and qhigh&quot;                                                            
 [38] &quot;&quot;                                                                                                     
 [39] &quot;#' Generate cut expressions for a variable&quot;                                                           
 [40] &quot;#'&quot;                                                                                                   
 [41] &quot;#' For a continuous variable, returns expressions for mean, median, qlow, and qhigh cuts.&quot;            
 [42] &quot;#'&quot;                                                                                                   
 [43] &quot;#' @param x Character. Variable name.&quot;                                                                
 [44] &quot;#' @return Character vector of cut expressions.&quot;                                                      
 [45] &quot;#' @export&quot;                                                                                           
 [46] &quot;&quot;                                                                                                     
 [47] &quot;cut_var &lt;- function(x){&quot;                                                                              
 [48] &quot;  mx &lt;- paste0(\&quot;mean(\&quot;,x,\&quot;)\&quot;)&quot;                                                                    
 [49] &quot;  a &lt;- paste0(x,\&quot; &lt;= \&quot;,mx)&quot;                                                                         
 [50] &quot;  mdx &lt;- paste0(\&quot;median(\&quot;,x,\&quot;)\&quot;)&quot;                                                                 
 [51] &quot;  b &lt;- paste0(x,\&quot; &lt;= \&quot;,mdx)&quot;                                                                        
 [52] &quot;  qlx &lt;- paste0(\&quot;qlow(\&quot;,x,\&quot;)\&quot;)&quot;                                                                   
 [53] &quot;  c &lt;- paste0(x,\&quot; &lt;= \&quot;,qlx)&quot;                                                                        
 [54] &quot;  qhx &lt;- paste0(\&quot;qhigh(\&quot;,x,\&quot;)\&quot;)&quot;                                                                  
 [55] &quot;  d &lt;- paste0(x,\&quot; &lt;= \&quot;,qhx)&quot;                                                                        
 [56] &quot;  return(c(a,b,c,d))&quot;                                                                                 
 [57] &quot;}&quot;                                                                                                    
 [58] &quot;&quot;                                                                                                     
 [59] &quot;#' Get forced cut expressions for variables&quot;                                                          
 [60] &quot;#'&quot;                                                                                                   
 [61] &quot;#' For each variable in \\code{conf.force.names}, returns cut expressions if continuous.&quot;             
 [62] &quot;#'&quot;                                                                                                   
 [63] &quot;#' @param df Data frame.&quot;                                                                             
 [64] &quot;#' @param conf.force.names Character vector of variable names.&quot;                                       
 [65] &quot;#' @param cont.cutoff Integer. Cutoff for continuous.&quot;                                                
 [66] &quot;#' @return Character vector of cut expressions.&quot;                                                      
 [67] &quot;#' @export&quot;                                                                                           
 [68] &quot;&quot;                                                                                                     
 [69] &quot;get_conf_force &lt;- function(df, conf.force.names, cont.cutoff = 4) {&quot;                                  
 [70] &quot;  # Validate input&quot;                                                                                   
 [71] &quot;  if (!is.data.frame(df)) stop(\&quot;df must be a data.frame.\&quot;)&quot;                                         
 [72] &quot;  if (!is.character(conf.force.names)) stop(\&quot;conf.force.names must be a character vector.\&quot;)&quot;        
 [73] &quot;  res &lt;- list()&quot;                                                                                      
 [74] &quot;  for (name in conf.force.names) {&quot;                                                                   
 [75] &quot;    if (!name %in% names(df)) {&quot;                                                                      
 [76] &quot;      warning(paste(\&quot;Variable\&quot;, name, \&quot;not found in data frame. Skipping.\&quot;))&quot;                     
 [77] &quot;      next&quot;                                                                                           
 [78] &quot;    }&quot;                                                                                                
 [79] &quot;    var_data &lt;- df[[name]]&quot;                                                                           
 [80] &quot;    # Check if variable is continuous&quot;                                                                
 [81] &quot;    flag_cont &lt;- is.continuous(var_data, cutoff = cont.cutoff)&quot;                                       
 [82] &quot;    if (flag_cont == 1) {&quot;                                                                            
 [83] &quot;      # Create mean, median, qlow, and qhigh cuts&quot;                                                    
 [84] &quot;      cuts &lt;- cut_var(x = name)&quot;                                                                      
 [85] &quot;      res[[name]] &lt;- cuts&quot;                                                                            
 [86] &quot;    } else {&quot;                                                                                         
 [87] &quot;      res[[name]] &lt;- NULL&quot;                                                                            
 [88] &quot;    }&quot;                                                                                                
 [89] &quot;  }&quot;                                                                                                  
 [90] &quot;  # Flatten to character vector if needed&quot;                                                            
 [91] &quot;  unlist(res)&quot;                                                                                        
 [92] &quot;}&quot;                                                                                                    
 [93] &quot;&quot;                                                                                                     
 [94] &quot;#' LASSO selection for Cox model&quot;                                                                     
 [95] &quot;#'&quot;                                                                                                   
 [96] &quot;#' Performs LASSO variable selection using Cox regression.&quot;                                           
 [97] &quot;#'&quot;                                                                                                   
 [98] &quot;#' @param df Data frame.&quot;                                                                             
 [99] &quot;#' @param confounders.name Character vector of confounder names.&quot;                                     
[100] &quot;#' @param outcome.name Character. Name of outcome variable.&quot;                                          
[101] &quot;#' @param event.name Character. Name of event indicator variable.&quot;                                    
[102] &quot;#' @param seedit Integer. Random seed.&quot;                                                               
[103] &quot;#' @return List with selected, omitted variables, coefficients, lambda, and fits.&quot;                    
[104] &quot;#' @importFrom glmnet cv.glmnet glmnet&quot;                                                               
[105] &quot;#' @importFrom survival Surv&quot;                                                                         
[106] &quot;#' @export&quot;                                                                                           
[107] &quot;&quot;                                                                                                     
[108] &quot;lasso_selection &lt;- function(df, confounders.name, outcome.name, event.name, seedit = 8316951) {&quot;      
[109] &quot;set.seed(seedit)&quot;                                                                                     
[110] &quot;# Package checks&quot;                                                                                     
[111] &quot;if (!requireNamespace(\&quot;glmnet\&quot;, quietly = TRUE)) stop(\&quot;Package 'glmnet' is required.\&quot;)&quot;           
[112] &quot;if (!requireNamespace(\&quot;survival\&quot;, quietly = TRUE)) stop(\&quot;Package 'survival' is required.\&quot;)&quot;       
[113] &quot;&quot;                                                                                                     
[114] &quot;  # Prepare the design matrix and response&quot;                                                           
[115] &quot;  x &lt;- as.matrix(df[, confounders.name, drop = FALSE])&quot;                                               
[116] &quot;&quot;                                                                                                     
[117] &quot;  y &lt;- survival::Surv(df[[outcome.name]], df[[event.name]])&quot;                                          
[118] &quot;&quot;                                                                                                     
[119] &quot;  # Fit Cox LASSO with cross-validation&quot;                                                              
[120] &quot;  cvfit &lt;- glmnet::cv.glmnet(x, y, family = \&quot;cox\&quot;, alpha = 1)&quot;                                      
[121] &quot;  lambda_min &lt;- cvfit$lambda.min&quot;                                                                     
[122] &quot;  fit &lt;- glmnet::glmnet(x, y, family = \&quot;cox\&quot;, alpha = 1, lambda = lambda_min)&quot;                      
[123] &quot;&quot;                                                                                                     
[124] &quot;  # Extract coefficients at lambda.min&quot;                                                               
[125] &quot;  coefs &lt;- as.vector(coef(fit))&quot;                                                                      
[126] &quot;  names(coefs) &lt;- rownames(coef(fit))&quot;                                                                
[127] &quot;&quot;                                                                                                     
[128] &quot;  # Determine selected and omitted variables&quot;                                                         
[129] &quot;  selected &lt;- names(coefs)[coefs != 0]&quot;                                                               
[130] &quot;  omitted &lt;- names(coefs)[coefs == 0]&quot;                                                                
[131] &quot;&quot;                                                                                                     
[132] &quot;  # Return results as a list&quot;                                                                         
[133] &quot;  list(&quot;                                                                                              
[134] &quot;    selected = selected,&quot;                                                                             
[135] &quot;    omitted = omitted,&quot;                                                                               
[136] &quot;    coefficients = coefs,&quot;                                                                            
[137] &quot;    lambda_min = lambda_min,&quot;                                                                         
[138] &quot;    cvfit = cvfit,&quot;                                                                                   
[139] &quot;    fit = fit&quot;                                                                                        
[140] &quot;  )&quot;                                                                                                  
[141] &quot;}&quot;                                                                                                    
[142] &quot;&quot;                                                                                                     
[143] &quot;&quot;                                                                                                     
[144] &quot;#' Filter a vector by LASSO-selected variables&quot;                                                       
[145] &quot;#'&quot;                                                                                                   
[146] &quot;#' Returns elements of \\code{x} that are in \\code{lassokeep}.&quot;                                      
[147] &quot;#'&quot;                                                                                                   
[148] &quot;#' @param x Character vector.&quot;                                                                        
[149] &quot;#' @param lassokeep Character vector of selected variables.&quot;                                          
[150] &quot;#' @return Filtered character vector or NULL.&quot;                                                        
[151] &quot;#' @export&quot;                                                                                           
[152] &quot;&quot;                                                                                                     
[153] &quot;filter_by_lassokeep &lt;- function(x, lassokeep) {&quot;                                                      
[154] &quot;  if (!is.null(x)) {&quot;                                                                                 
[155] &quot;    filtered &lt;- x[x %in% lassokeep]&quot;                                                                  
[156] &quot;    if (length(filtered) &gt; 0) {&quot;                                                                      
[157] &quot;      return(filtered)&quot;                                                                               
[158] &quot;    } else {&quot;                                                                                         
[159] &quot;      return(NULL)&quot;                                                                                   
[160] &quot;    }&quot;                                                                                                
[161] &quot;  }&quot;                                                                                                  
[162] &quot;  return(NULL)&quot;                                                                                       
[163] &quot;}&quot;                                                                                                    
[164] &quot;&quot;                                                                                                     
[165] &quot;#' Format subgroup labels for ForestSearch&quot;                                                           
[166] &quot;#'&quot;                                                                                                   
[167] &quot;#' Converts q-indexed subgroup codes to human-readable labels.&quot;                                       
[168] &quot;#'&quot;                                                                                                   
[169] &quot;#' @param Qsg Character vector of codes (e.g., 'q1.0', 'q2.1').&quot;                                      
[170] &quot;#' @param confs_labels Character vector of confounder labels.&quot;                                        
[171] &quot;#' @return Character vector of formatted subgroup labels.&quot;                                            
[172] &quot;#' @importFrom stringr str_length str_sub&quot;                                                            
[173] &quot;#' @export&quot;                                                                                           
[174] &quot;&quot;                                                                                                     
[175] &quot;FS_labels &lt;- function(Qsg, confs_labels) {&quot;                                                           
[176] &quot;  # Validate inputs&quot;                                                                                  
[177] &quot;  if (!is.character(Qsg)) stop(\&quot;Qsg must be a character vector.\&quot;)&quot;                                  
[178] &quot;  if (!is.character(confs_labels)) stop(\&quot;confs_labels must be a character vector.\&quot;)&quot;                
[179] &quot;&quot;                                                                                                     
[180] &quot;  # Use regex to extract index and action&quot;                                                            
[181] &quot;  # Pattern: q&lt;index&gt;.&lt;action&gt;, e.g., q1.0, q12.1, q123.0, q1234.1&quot;                                   
[182] &quot;  pattern &lt;- \&quot;^q(\\\\d+)\\\\.(\\\\d+)$\&quot;&quot;                                                            
[183] &quot;  matches &lt;- regexec(pattern, Qsg)&quot;                                                                   
[184] &quot;  parts &lt;- regmatches(Qsg, matches)&quot;                                                                  
[185] &quot;&quot;                                                                                                     
[186] &quot;  sg_labels &lt;- character(length(Qsg))&quot;                                                                
[187] &quot;&quot;                                                                                                     
[188] &quot;  for (i in seq_along(parts)) {&quot;                                                                      
[189] &quot;    if (length(parts[[i]]) == 3) {&quot;                                                                   
[190] &quot;      idx &lt;- as.numeric(parts[[i]][2])&quot;                                                               
[191] &quot;      action &lt;- as.numeric(parts[[i]][3])&quot;                                                            
[192] &quot;      if (!is.na(idx) &amp;&amp; idx &gt;= 1 &amp;&amp; idx &lt;= length(confs_labels)) {&quot;                                  
[193] &quot;        label &lt;- confs_labels[idx]&quot;                                                                   
[194] &quot;        if (action == 0) {&quot;                                                                           
[195] &quot;          sg_labels[i] &lt;- paste0(\&quot;!{\&quot;, label, \&quot;}\&quot;)&quot;                                               
[196] &quot;        } else if (action == 1) {&quot;                                                                    
[197] &quot;          sg_labels[i] &lt;- paste0(\&quot;{\&quot;, label, \&quot;}\&quot;)&quot;                                                
[198] &quot;        } else {&quot;                                                                                     
[199] &quot;          sg_labels[i] &lt;- NA&quot;                                                                         
[200] &quot;        }&quot;                                                                                            
[201] &quot;      } else {&quot;                                                                                       
[202] &quot;        sg_labels[i] &lt;- NA&quot;                                                                           
[203] &quot;      }&quot;                                                                                              
[204] &quot;    } else {&quot;                                                                                         
[205] &quot;      sg_labels[i] &lt;- NA&quot;                                                                             
[206] &quot;    }&quot;                                                                                                
[207] &quot;  }&quot;                                                                                                  
[208] &quot;  return(sg_labels)&quot;                                                                                  
[209] &quot;}&quot;                                                                                                    
[210] &quot;&quot;                                                                                                     
[211] &quot;&quot;                                                                                                     
[212] &quot;#' Process forced cut expression for a variable&quot;                                                      
[213] &quot;#'&quot;                                                                                                   
[214] &quot;#' Evaluates a cut expression (e.g., \&quot;age &lt;= mean(age)\&quot;) and returns the expression with the value.&quot;
[215] &quot;#'&quot;                                                                                                   
[216] &quot;#' @param expr Character string of the cut expression.&quot;                                               
[217] &quot;#' @param df Data frame.&quot;                                                                             
[218] &quot;#' @return Character string with evaluated value.&quot;                                                    
[219] &quot;#' @export&quot;                                                                                           
[220] &quot;&quot;                                                                                                     
[221] &quot;process_conf_force_expr &lt;- function(expr, df) {&quot;                                                      
[222] &quot;  # Match pattern: variable &lt;= function(variable)&quot;                                                    
[223] &quot;  # Examples: \&quot;age &lt;= mean(age)\&quot;, \&quot;size &lt;= qlow(size)\&quot;&quot;                                           
[224] &quot;  pattern &lt;- \&quot;^\\\\s*([a-zA-Z0-9_.]+)\\\\s*&lt;=\\\\s*([a-zA-Z]+)\\\\(([^)]+)\\\\)\\\\s*$\&quot;&quot;            
[225] &quot;  m &lt;- regexec(pattern, expr)&quot;                                                                        
[226] &quot;  matches &lt;- regmatches(expr, m)[[1]]&quot;                                                                
[227] &quot;  if (length(matches) == 0) {&quot;                                                                        
[228] &quot;    # If not matching, return as is&quot;                                                                  
[229] &quot;    return(expr)&quot;                                                                                     
[230] &quot;  }&quot;                                                                                                  
[231] &quot;  var &lt;- matches[2]&quot;                                                                                  
[232] &quot;  fun &lt;- matches[3]&quot;                                                                                  
[233] &quot;  arg &lt;- matches[4]&quot;                                                                                  
[234] &quot;  # Only proceed if var and arg match&quot;                                                                
[235] &quot;  if (!(var %in% colnames(df)) || !(arg %in% colnames(df))) return(expr)&quot;                             
[236] &quot;  # Evaluate the function&quot;                                                                            
[237] &quot;  if (fun == \&quot;mean\&quot;) {&quot;                                                                             
[238] &quot;    val &lt;- round(mean(df[[arg]], na.rm = TRUE), 1)&quot;                                                   
[239] &quot;  } else if (fun == \&quot;median\&quot;) {&quot;                                                                    
[240] &quot;    val &lt;- round(median(df[[arg]], na.rm = TRUE), 1)&quot;                                                 
[241] &quot;  } else if (fun == \&quot;qlow\&quot;) {&quot;                                                                      
[242] &quot;    val &lt;- round(quantile(df[[arg]], 0.25, na.rm = TRUE), 1)&quot;                                         
[243] &quot;  } else if (fun == \&quot;qhigh\&quot;) {&quot;                                                                     
[244] &quot;    val &lt;- round(quantile(df[[arg]], 0.75, na.rm = TRUE), 1)&quot;                                         
[245] &quot;  } else {&quot;                                                                                           
[246] &quot;    # Unknown function, return as is&quot;                                                                 
[247] &quot;    return(expr)&quot;                                                                                     
[248] &quot;  }&quot;                                                                                                  
[249] &quot;  # Return the evaluated expression&quot;                                                                  
[250] &quot;  paste0(var, \&quot; &lt;= \&quot;, val)&quot;                                                                         
[251] &quot;}&quot;                                                                                                    
[252] &quot;&quot;                                                                                                     
[253] &quot;&quot;                                                                                                     
[254] &quot;#' Get variable name from cut expression&quot;                                                             
[255] &quot;#'&quot;                                                                                                   
[256] &quot;#' Extracts the variable name from a cut expression.&quot;                                                 
[257] &quot;#'&quot;                                                                                                   
[258] &quot;#' @param thiscut Character string of the cut expression.&quot;                                            
[259] &quot;#' @param confounders.name Character vector of confounder names.&quot;                                     
[260] &quot;#' @return Character vector of variable names.&quot;                                                       
[261] &quot;#' @export&quot;                                                                                           
[262] &quot;&quot;                                                                                                     
[263] &quot;get_cut_name &lt;- function(thiscut, confounders.name) {&quot;                                                
[264] &quot;  cov_index &lt;- vapply(confounders.name, function(x) grepl(x, thiscut), logical(1))&quot;                   
[265] &quot;  confounders.name[cov_index]&quot;                                                                        
[266] &quot;}&quot;                                                                                                    
[267] &quot;&quot;                                                                                                     
[268] &quot;&quot;                                                                                                     
[269] &quot;#' Check if cut expression is for a continuous variable&quot;                                              
[270] &quot;#'&quot;                                                                                                   
[271] &quot;#' Determines if a cut expression refers to a continuous variable.&quot;                                   
[272] &quot;#'&quot;                                                                                                   
[273] &quot;#' @param thiscut Character string of the cut expression.&quot;                                            
[274] &quot;#' @param confounders.name Character vector of confounder names.&quot;                                     
[275] &quot;#' @param df Data frame.&quot;                                                                             
[276] &quot;#' @param cont.cutoff Integer. Cutoff for continuous.&quot;                                                
[277] &quot;#' @return Logical; TRUE if continuous, FALSE otherwise.&quot;                                             
[278] &quot;#' @export&quot;                                                                                           
[279] &quot;&quot;                                                                                                     
[280] &quot;is_flag_continuous &lt;- function(thiscut, confounders.name, df, cont.cutoff) {&quot;                         
[281] &quot;  cut_name &lt;- get_cut_name(thiscut, confounders.name)&quot;                                                
[282] &quot;  aa &lt;- df[, cut_name, drop = FALSE]&quot;                                                                 
[283] &quot;  # If multiple columns, check all; if any is continuous, return TRUE&quot;                                
[284] &quot;  any(vapply(aa, function(col) is.continuous(col, cutoff = cont.cutoff) == 1, logical(1)))&quot;           
[285] &quot;}&quot;                                                                                                    
[286] &quot;&quot;                                                                                                     
[287] &quot;&quot;                                                                                                     
[288] &quot;#' Check if cut expression should be dropped&quot;                                                         
[289] &quot;#'&quot;                                                                                                   
[290] &quot;#' Determines if a cut expression should be dropped (e.g., variable has &lt;=1 unique value).&quot;           
[291] &quot;#'&quot;                                                                                                   
[292] &quot;#' @param thiscut Character string of the cut expression.&quot;                                            
[293] &quot;#' @param confounders.name Character vector of confounder names.&quot;                                     
[294] &quot;#' @param df Data frame.&quot;                                                                             
[295] &quot;#' @return Logical; TRUE if should be dropped, FALSE otherwise.&quot;                                      
[296] &quot;#' @export&quot;                                                                                           
[297] &quot;&quot;                                                                                                     
[298] &quot;is_flag_drop &lt;- function(thiscut, confounders.name, df) {&quot;                                            
[299] &quot;  cut_name &lt;- get_cut_name(thiscut, confounders.name)&quot;                                                
[300] &quot;  aa &lt;- df[, cut_name, drop = FALSE]&quot;                                                                 
[301] &quot;  # If multiple columns, check all; if any has &lt;=1 unique value, return TRUE&quot;                         
[302] &quot;  any(vapply(aa, function(col) length(unique(col)) &lt;= 1, logical(1)))&quot;                                
[303] &quot;}&quot;                                                                                                    
[304] &quot;&quot;                                                                                                     
[305] &quot;&quot;                                                                                                     
[306] &quot;#' Disjunctive coding for factors (modified from ade4)&quot;                                               
[307] &quot;#'&quot;                                                                                                   
[308] &quot;#' Converts factor variables in a data frame to disjunctive (dummy) coding.&quot;                          
[309] &quot;#'&quot;                                                                                                   
[310] &quot;#' @param df Data frame with factor variables.&quot;                                                       
[311] &quot;#' @return Data frame with dummy-coded variables.&quot;                                                    
[312] &quot;#' @export&quot;                                                                                           
[313] &quot;&quot;                                                                                                     
[314] &quot;acm.disjctif&lt;-function (df)&quot;                                                                          
[315] &quot;{&quot;                                                                                                    
[316] &quot;  acm.util.df &lt;- function(i) {&quot;                                                                       
[317] &quot;    cl &lt;- df[, i]&quot;                                                                                    
[318] &quot;    cha &lt;- names(df)[i]&quot;                                                                              
[319] &quot;    n &lt;- length(cl)&quot;                                                                                  
[320] &quot;    cl &lt;- as.factor(cl)&quot;                                                                              
[321] &quot;    x &lt;- matrix(0, n, length(levels(cl)))&quot;                                                            
[322] &quot;    x[(1:n) + n * (unclass(cl) - 1)] &lt;- 1&quot;                                                            
[323] &quot;    dimnames(x) &lt;- list(row.names(df), paste(cha, levels(cl),&quot;                                        
[324] &quot;                                             sep = \&quot;.\&quot;))&quot;                                           
[325] &quot;    return(x)&quot;                                                                                        
[326] &quot;  }&quot;                                                                                                  
[327] &quot;  # For FAC(df) with only single variable&quot;                                                            
[328] &quot;  acm.util.df2 &lt;- function(i) {&quot;                                                                      
[329] &quot;    cl &lt;- df[, i]&quot;                                                                                    
[330] &quot;    cha &lt;- colnames(df)[i]&quot;                                                                           
[331] &quot;    n &lt;- length(cl)&quot;                                                                                  
[332] &quot;    cl &lt;- as.factor(cl)&quot;                                                                              
[333] &quot;    x &lt;- matrix(0, n, length(levels(cl)))&quot;                                                            
[334] &quot;    x[(1:n) + n * (unclass(cl) - 1)] &lt;- 1&quot;                                                            
[335] &quot;    dimnames(x) &lt;- list(row.names(df), paste(cha, levels(cl),&quot;                                        
[336] &quot;                                             sep = \&quot;.\&quot;))&quot;                                           
[337] &quot;    return(x)&quot;                                                                                        
[338] &quot;  }&quot;                                                                                                  
[339] &quot;  if(!is.null(ncol(df)) &amp; ncol(df)&gt;1) G &lt;- lapply(1:ncol(df), acm.util.df)&quot;                           
[340] &quot;  if(!is.null(ncol(df)) &amp; ncol(df)==1) G &lt;- lapply(1, acm.util.df2)&quot;                                  
[341] &quot;  G &lt;- data.frame(G, check.names = FALSE)&quot;                                                            
[342] &quot;  return(G)&quot;                                                                                          
[343] &quot;}&quot;                                                                                                    
[344] &quot;&quot;                                                                                                     
[345] &quot;&quot;                                                                                                     
[346] &quot;#' Dummy coding for data frame (numeric and factor)&quot;                                                  
[347] &quot;#'&quot;                                                                                                   
[348] &quot;#' Converts numeric and factor variables in a data frame to dummy-coded format.&quot;                      
[349] &quot;#'&quot;                                                                                                   
[350] &quot;#' @param df Data frame.&quot;                                                                             
[351] &quot;#' @return Data frame with numeric and dummy-coded factor variables.&quot;                                 
[352] &quot;#' @export&quot;                                                                                           
[353] &quot;&quot;                                                                                                     
[354] &quot;dummy2 &lt;- function(df) {&quot;                                                                             
[355] &quot;  NUM &lt;- function(dataframe)dataframe[,sapply(dataframe,is.numeric)]&quot;                                 
[356] &quot;  FAC &lt;- function(dataframe)dataframe[,sapply(dataframe,is.factor)]&quot;                                  
[357] &quot;  if (is.null(ncol(NUM(df)))){&quot;                                                                       
[358] &quot;    DF &lt;- data.frame(NUM(df), acm.disjctif(FAC(df)))&quot;                                                 
[359] &quot;    names(DF)[1] &lt;- colnames(df)[which(sapply(df, is.numeric))]&quot;                                      
[360] &quot;  } else {&quot;                                                                                           
[361] &quot;    if (!is.null(ncol(FAC(df))) &amp;&amp; ncol(FAC(df))&gt;0) DF &lt;- data.frame(NUM(df), acm.disjctif(FAC(df)))&quot; 
[362] &quot;    if (!is.null(ncol(FAC(df))) | ncol(FAC(df))==0) DF &lt;- data.frame(NUM(df))&quot;                        
[363] &quot;    if (is.null(ncol(FAC(df)))){&quot;                                                                     
[364] &quot;      temp &lt;- as.matrix(FAC(df))&quot;                                                                     
[365] &quot;      colnames(temp)[1] &lt;- colnames(df)[which(sapply(df, is.factor))]&quot;                                
[366] &quot;      df.fac &lt;- acm.disjctif(temp)&quot;                                                                   
[367] &quot;      DF &lt;- data.frame(NUM(df), df.fac)&quot;                                                              
[368] &quot;    }&quot;                                                                                                
[369] &quot;  }&quot;                                                                                                  
[370] &quot;  return(DF)&quot;                                                                                         
[371] &quot;}&quot;                                                                                                    
[372] &quot;&quot;                                                                                                     
[373] &quot;#' Dummy coding for data frame (numeric and factor)&quot;                                                  
[374] &quot;#'&quot;                                                                                                   
[375] &quot;#' Converts numeric and factor variables in a data frame to dummy-coded format.&quot;                      
[376] &quot;#'&quot;                                                                                                   
[377] &quot;#' @param df Data frame.&quot;                                                                             
[378] &quot;#' @return Data frame with numeric and dummy-coded factor variables.&quot;                                 
[379] &quot;#' @export&quot;                                                                                           
[380] &quot;&quot;                                                                                                     
[381] &quot;dummy &lt;- function(df) {&quot;                                                                              
[382] &quot;  NUM &lt;- function(dataframe)dataframe[,sapply(dataframe,is.numeric)]&quot;                                 
[383] &quot;  FAC &lt;- function(dataframe)dataframe[,sapply(dataframe,is.factor)]&quot;                                  
[384] &quot;  if (is.null(ncol(NUM(df)))){&quot;                                                                       
[385] &quot;    DF &lt;- data.frame(NUM(df), acm.disjctif(FAC(df)))&quot;                                                 
[386] &quot;    names(DF)[1] &lt;- colnames(df)[which(sapply(df, is.numeric))]&quot;                                      
[387] &quot;  } else {&quot;                                                                                           
[388] &quot;    if (!is.null(ncol(FAC(df)))) DF &lt;- data.frame(NUM(df), acm.disjctif(FAC(df)))&quot;                    
[389] &quot;    if (is.null(ncol(FAC(df)))){&quot;                                                                     
[390] &quot;      temp &lt;- as.matrix(FAC(df))&quot;                                                                     
[391] &quot;      colnames(temp)[1] &lt;- colnames(df)[which(sapply(df, is.factor))]&quot;                                
[392] &quot;      df.fac &lt;- acm.disjctif(temp)&quot;                                                                   
[393] &quot;      DF &lt;- data.frame(NUM(df), df.fac)&quot;                                                              
[394] &quot;    }&quot;                                                                                                
[395] &quot;  }&quot;                                                                                                  
[396] &quot;  return(DF)&quot;                                                                                         
[397] &quot;}&quot;                                                                                                    
[398] &quot;&quot;                                                                                                     
[399] &quot;#' Trailing zeros in binary representation&quot;                                                           
[400] &quot;#'&quot;                                                                                                   
[401] &quot;#' Returns the number of trailing zeros in the binary representation of an integer.&quot;                  
[402] &quot;#'&quot;                                                                                                   
[403] &quot;#' @param kk Integer.&quot;                                                                                
[404] &quot;#' @return Integer count of trailing zeros.&quot;                                                          
[405] &quot;#' @export&quot;                                                                                           
[406] &quot;&quot;                                                                                                     
[407] &quot;ztrail &lt;- function(kk){&quot;                                                                              
[408] &quot;  ii &lt;- 1&quot;                                                                                            
[409] &quot;  zz &lt;- kk&quot;                                                                                           
[410] &quot;  while(zz%%2 == 0){&quot;                                                                                 
[411] &quot;    ii &lt;- ii+1&quot;                                                                                       
[412] &quot;    zz &lt;- zz/2&quot;                                                                                       
[413] &quot;  }&quot;                                                                                                  
[414] &quot;  return(ii)&quot;                                                                                         
[415] &quot;}&quot;                                                                                                    
[416] &quot;&quot;                                                                                                     
[417] &quot;#' Flip 1/0 value&quot;                                                                                    
[418] &quot;#'&quot;                                                                                                   
[419] &quot;#' Flips a binary value: returns 0 if input is 1, returns 1 if input is 0.&quot;                           
[420] &quot;#'&quot;                                                                                                   
[421] &quot;#' @param x Integer (0 or 1).&quot;                                                                        
[422] &quot;#' @return Integer (0 or 1).&quot;                                                                         
[423] &quot;#' @export&quot;                                                                                           
[424] &quot;&quot;                                                                                                     
[425] &quot;one.zero &lt;- function(x){&quot;                                                                             
[426] &quot;  if (x == 1){&quot;                                                                                       
[427] &quot;    x &lt;- 0}&quot;                                                                                          
[428] &quot;  else {&quot;                                                                                             
[429] &quot;    x &lt;- 1}&quot;                                                                                          
[430] &quot;  return(x)&quot;                                                                                          
[431] &quot;}&quot;                                                                                                    

$get_FSdata
  [1] &quot;&quot;                                                                                                                                              
  [2] &quot;#' ForestSearch Data Preparation and Feature Selection&quot;                                                                                        
  [3] &quot;#'&quot;                                                                                                                                            
  [4] &quot;#' Prepares a dataset for ForestSearch, including options for LASSO-based dimension reduction,&quot;                                                
  [5] &quot;#' GRF cuts, forced cuts, and flexible cut strategies. Returns a list with the processed data,&quot;                                                
  [6] &quot;#' subgroup factor names, cut expressions, and LASSO selection results.&quot;                                                                       
  [7] &quot;#'&quot;                                                                                                                                            
  [8] &quot;#' @param df Data frame containing the data.&quot;                                                                                                  
  [9] &quot;#' @param use_lasso Logical. Whether to use LASSO for dimension reduction.&quot;                                                                    
 [10] &quot;#' @param use_grf Logical. Whether to use GRF cuts.&quot;                                                                                           
 [11] &quot;#' @param grf_cuts Character vector of GRF cut expressions.&quot;                                                                                   
 [12] &quot;#' @param confounders.name Character vector of confounder variable names.&quot;                                                                     
 [13] &quot;#' @param cont.cutoff Integer. Cutoff for continuous variable determination.&quot;                                                                  
 [14] &quot;#' @param conf_force Character vector of forced cut expressions.&quot;                                                                              
 [15] &quot;#' @param conf.cont_medians Character vector of continuous confounders to cut at median.&quot;                                                      
 [16] &quot;#' @param conf.cont_medians_force Character vector of additional continuous confounders to force median cut.&quot;                                  
 [17] &quot;#' @param replace_med_grf Logical. If TRUE, removes median cuts that overlap with GRF cuts.&quot;                                                   
 [18] &quot;#' @param defaultcut_names Character vector of confounders to force default cuts.&quot;                                                             
 [19] &quot;#' @param cut_type Character. \&quot;default\&quot; or \&quot;median\&quot; for cut strategy.&quot;                                                                     
 [20] &quot;#' @param exclude_cuts Character vector of cut expressions to exclude.&quot;                                                                        
 [21] &quot;#' @param outcome.name Character. Name of outcome variable.&quot;                                                                                   
 [22] &quot;#' @param event.name Character. Name of event indicator variable.&quot;                                                                             
 [23] &quot;#' @param details Logical. If TRUE, prints details during execution.&quot;                                                                          
 [24] &quot;#' @importFrom stringr str_length str_sub&quot;                                                                                                     
 [25] &quot;#' @importFrom stats median quantile&quot;                                                                                                          
 [26] &quot;#' @export&quot;                                                                                                                                    
 [27] &quot;&quot;                                                                                                                                              
 [28] &quot;get_FSdata &lt;- function(df, use_lasso = FALSE, use_grf = FALSE, grf_cuts = NULL ,confounders.name,&quot;                                             
 [29] &quot;                     cont.cutoff = 4,conf_force = NULL, conf.cont_medians = NULL, conf.cont_medians_force = NULL,&quot;                             
 [30] &quot;                     replace_med_grf = TRUE, defaultcut_names = NULL, cut_type = \&quot;default\&quot;, exclude_cuts = NULL,&quot;                            
 [31] &quot;                     outcome.name = \&quot;tte\&quot;, event.name = \&quot;event\&quot;, details=TRUE){&quot;                                                           
 [32] &quot;&quot;                                                                                                                                              
 [33] &quot;  # convert to data.frame and return data.table&quot;                                                                                               
 [34] &quot;if(!is.data.frame(df))  df &lt;- as.data.frame(df)&quot;                                                                                               
 [35] &quot;&quot;                                                                                                                                              
 [36] &quot;  # Check that all required columns are present&quot;                                                                                               
 [37] &quot;  missing_cols &lt;- setdiff(c(confounders.name, outcome.name, event.name), names(df))&quot;                                                           
 [38] &quot;  if(length(missing_cols) &gt; 0) stop(\&quot;Missing columns in data: \&quot;, paste(missing_cols, collapse = \&quot;, \&quot;))&quot;                                    
 [39] &quot;&quot;                                                                                                                                              
 [40] &quot;  # Check for NAs in key columns&quot;                                                                                                              
 [41] &quot;  key_cols &lt;- c(confounders.name, outcome.name, event.name)&quot;                                                                                   
 [42] &quot;  if(anyNA(df[, key_cols, drop = FALSE])) warning(\&quot;NAs detected in key columns. Consider handling missing data (default is complete-case).\&quot;)&quot;
 [43] &quot;&quot;                                                                                                                                              
 [44] &quot;  # Check that outcome and event columns are numeric&quot;                                                                                          
 [45] &quot;  if(!is.numeric(df[[outcome.name]])) stop(\&quot;Outcome column must be numeric.\&quot;)&quot;                                                               
 [46] &quot;  if(!is.numeric(df[[event.name]])) stop(\&quot;Event column must be numeric (0/1).\&quot;)&quot;                                                             
 [47] &quot;&quot;                                                                                                                                              
 [48] &quot;  # Check that confounders are numeric or factors&quot;                                                                                             
 [49] &quot;&quot;                                                                                                                                              
 [50] &quot;  types &lt;- sapply(df[confounders.name], function(x) is.numeric(x) || is.factor(x))&quot;                                                            
 [51] &quot;  if (!all(types)) stop(\&quot;All confounders must be numeric or factor.\&quot;)&quot;                                                                       
 [52] &quot;&quot;                                                                                                                                              
 [53] &quot;  #toget_complete &lt;- complete.cases(df1[, c(confounders.name, outcome.name, event.name)])&quot;                                                     
 [54] &quot;  #df &lt;- df1[toget_complete,]&quot;                                                                                                                 
 [55] &quot;&quot;                                                                                                                                              
 [56] &quot;  df &lt;- df[complete.cases(df[, c(confounders.name, outcome.name, event.name)]), ]&quot;                                                             
 [57] &quot;&quot;                                                                                                                                              
 [58] &quot;  # Remove&quot;                                                                                                                                    
 [59] &quot;  #print(names(df))&quot;                                                                                                                           
 [60] &quot;&quot;                                                                                                                                              
 [61] &quot;    # Default cuts forced per defaultcut_names&quot;                                                                                                
 [62] &quot;  if(!is.null(defaultcut_names)){&quot;                                                                                                             
 [63] &quot;    conf_force_default &lt;- get_conf_force(df = df,conf.force.names = defaultcut_names,cont.cutoff = 4)&quot;                                         
 [64] &quot;    # append to conf_force&quot;                                                                                                                    
 [65] &quot;    conf_force &lt;- c(conf_force,conf_force_default)&quot;                                                                                            
 [66] &quot;  }&quot;                                                                                                                                           
 [67] &quot;&quot;                                                                                                                                              
 [68] &quot;  # If grf was attempted but NO cuts were found then considering no cuts per grf&quot;                                                              
 [69] &quot;  if(use_grf &amp;&amp; is.null(grf_cuts)) use_grf &lt;- FALSE&quot;                                                                                           
 [70] &quot;&quot;                                                                                                                                              
 [71] &quot;  if(use_lasso &amp;  (is.null(outcome.name) | is.null(event.name))) stop(\&quot;Cox variable names needed for lasso (outcome and event)\&quot;)&quot;            
 [72] &quot;&quot;                                                                                                                                              
 [73] &quot;  flag_continuous &lt;- vapply(&quot;                                                                                                                  
 [74] &quot;    confounders.name,&quot;                                                                                                                         
 [75] &quot;    function(var) {&quot;                                                                                                                           
 [76] &quot;      aa &lt;- df[[var]]&quot;                                                                                                                         
 [77] &quot;      c(is.continuous(aa, cutoff = cont.cutoff) ==1)&quot;                                                                                          
 [78] &quot;    },&quot;                                                                                                                                        
 [79] &quot;    logical(1)&quot;                                                                                                                                
 [80] &quot;    )&quot;                                                                                                                                         
 [81] &quot;  if(details){&quot;                                                                                                                                
 [82] &quot;    cat(\&quot;# of continuous/categorical characteristics\&quot;,c(sum(flag_continuous),sum(!flag_continuous)),\&quot;\\n\&quot;)&quot;                                
 [83] &quot;    if(sum(flag_continuous) &gt; 0)  cat(\&quot;Continuous characteristics:\&quot;,c(confounders.name[flag_continuous]),\&quot;\\n\&quot;)&quot;                           
 [84] &quot;    if(sum(!flag_continuous) &gt; 0)   cat(\&quot;Categorical characteristics:\&quot;,c(confounders.name[!flag_continuous]),\&quot;\\n\&quot;)&quot;                       
 [85] &quot;  }&quot;                                                                                                                                           
 [86] &quot;&quot;                                                                                                                                              
 [87] &quot;  if(sum(flag_continuous) == 0) conf.categorical &lt;- confounders.name&quot;                                                                          
 [88] &quot;  if(sum(flag_continuous) &gt; 0) conf.categorical &lt;- confounders.name[!flag_continuous]&quot;                                                         
 [89] &quot;&quot;                                                                                                                                              
 [90] &quot;  # If there are no median cuts (either \&quot;conf.cont_medians\&quot; or \&quot;conf.cont_medians_force\&quot;)&quot;                                                 
 [91] &quot;  # then we initialize all continuous confounders to be cut&quot;                                                                                   
 [92] &quot;  if(is.null(conf.cont_medians) &amp; is.null(conf.cont_medians_force) &amp; sum(flag_continuous) &gt; 0){&quot;                                               
 [93] &quot;    conf.cont_medians &lt;- confounders.name[flag_continuous]&quot;                                                                                    
 [94] &quot;  }&quot;                                                                                                                                           
 [95] &quot;  lassokeep &lt;- NULL&quot;                                                                                                                           
 [96] &quot;  lassoomit &lt;- NULL&quot;                                                                                                                           
 [97] &quot;  if(use_lasso){&quot;                                                                                                                              
 [98] &quot;    # Reduce dimension via Cox lasso&quot;                                                                                                          
 [99] &quot;    get_lasso &lt;- lasso_selection(&quot;                                                                                                             
[100] &quot;      df = dfa,&quot;                                                                                                                               
[101] &quot;      confounders.name = confounders.name,&quot;                                                                                                    
[102] &quot;      outcome.name = outcome.name,&quot;                                                                                                            
[103] &quot;      event.name = event.name&quot;                                                                                                                 
[104] &quot;    )&quot;                                                                                                                                         
[105] &quot;    lassokeep &lt;- get_lasso$selected&quot;                                                                                                           
[106] &quot;    lassoomit &lt;- get_lasso$omitted&quot;                                                                                                            
[107] &quot;&quot;                                                                                                                                              
[108] &quot;  if(details){&quot;                                                                                                                                
[109] &quot;    cat(\&quot;## Prior to lasso:\&quot;, c(conf.cont_medians), \&quot;\\n\&quot;)&quot;                                                                                
[110] &quot;    cat(\&quot;#### Lasso selection results\&quot;, \&quot;\\n\&quot;)&quot;                                                                                            
[111] &quot;      print(get_lasso$fit$beta)&quot;                                                                                                               
[112] &quot;      cat(\&quot;Cox-LASSO selected:\&quot;,c(lassokeep),\&quot;\\n\&quot;)&quot;                                                                                       
[113] &quot;      cat(\&quot;Cox-LASSO not selected:\&quot;,c(lassoomit),\&quot;\\n\&quot;)&quot;                                                                                   
[114] &quot;      cat(\&quot;### End Lasso selection\&quot;, \&quot;\\n\&quot;)&quot;                                                                                               
[115] &quot;  }&quot;                                                                                                                                           
[116] &quot;  # If any selected per lasso&quot;                                                                                                                 
[117] &quot;    if (length(lassokeep) &gt; 0) {&quot;                                                                                                              
[118] &quot;      conf.cont_medians &lt;- filter_by_lassokeep(conf.cont_medians, lassokeep)&quot;                                                                  
[119] &quot;      conf.categorical  &lt;- filter_by_lassokeep(conf.categorical, lassokeep)&quot;                                                                   
[120] &quot;    }&quot;                                                                                                                                         
[121] &quot;if(details)  cat(\&quot;## After lasso:\&quot;, c(conf.cont_medians), \&quot;\\n\&quot;)&quot;                                                                          
[122] &quot;  } # Done Lasso&quot;                                                                                                                              
[123] &quot;&quot;                                                                                                                                              
[124] &quot;  # If forcing any cuts, then done below&quot;                                                                                                      
[125] &quot;  if (use_lasso &amp;&amp; cut_type == \&quot;default\&quot;) {&quot;                                                                                                 
[126] &quot;    conf_force_lasso &lt;- NULL&quot;                                                                                                                  
[127] &quot;    # Override conf.cont_medians&quot;                                                                                                              
[128] &quot;    # conf.cont_medians are continuous factors selected per lasso&quot;                                                                             
[129] &quot;    # Create default cuts for conf.cont_medians NOT in defaultcut_names&quot;                                                                       
[130] &quot;    if (!is.null(defaultcut_names)) {&quot;                                                                                                         
[131] &quot;      # If not already contained in defaultcut_names&quot;                                                                                          
[132] &quot;      lasso_tocut &lt;- setdiff(conf.cont_medians, defaultcut_names)&quot;                                                                             
[133] &quot;    } else {&quot;                                                                                                                                  
[134] &quot;      lasso_tocut &lt;- conf.cont_medians&quot;                                                                                                        
[135] &quot;    }&quot;                                                                                                                                         
[136] &quot;    if (length(lasso_tocut) &gt; 0) {&quot;                                                                                                            
[137] &quot;      conf_force_lasso &lt;- get_conf_force(df = df, conf.force.names = lasso_tocut, cont.cutoff = 4)&quot;                                            
[138] &quot;    }&quot;                                                                                                                                         
[139] &quot;    # Override cuts at medians&quot;                                                                                                                
[140] &quot;    conf.cont_medians &lt;- NULL&quot;                                                                                                                 
[141] &quot;    # Append to conf_force&quot;                                                                                                                    
[142] &quot;    conf_force &lt;- c(conf_force, conf_force_lasso)&quot;                                                                                             
[143] &quot;    # These will be cut and conf.cont_medians is now reset&quot;                                                                                    
[144] &quot;    if (details) {&quot;                                                                                                                            
[145] &quot;      cat(\&quot;Default cuts included from Lasso:\&quot;, c(conf_force_lasso), \&quot;\\n\&quot;)&quot;                                                                
[146] &quot;      cat(\&quot;Categorical after Lasso:\&quot;, c(conf.categorical), \&quot;\\n\&quot;)&quot;                                                                         
[147] &quot;    }&quot;                                                                                                                                         
[148] &quot;  }&quot;                                                                                                                                           
[149] &quot;  if (use_lasso &amp;&amp; cut_type == \&quot;median\&quot;) {&quot;                                                                                                  
[150] &quot;    if (!is.null(defaultcut_names)) {&quot;                                                                                                         
[151] &quot;      conf.cont_medians &lt;- setdiff(conf.cont_medians, defaultcut_names)&quot;                                                                       
[152] &quot;    }&quot;                                                                                                                                         
[153] &quot;    if (details) {&quot;                                                                                                                            
[154] &quot;      cat(\&quot;Median cuts included from Lasso:\&quot;, c(conf.cont_medians), \&quot;\\n\&quot;)&quot;                                                                
[155] &quot;      cat(\&quot;Categorical after Lasso:\&quot;, c(conf.categorical), \&quot;\\n\&quot;)&quot;                                                                         
[156] &quot;    }&quot;                                                                                                                                         
[157] &quot;  }&quot;                                                                                                                                           
[158] &quot;  if (!use_lasso &amp;&amp; cut_type == \&quot;default\&quot;) {&quot;                                                                                                
[159] &quot;    conf_force_add &lt;- NULL&quot;                                                                                                                    
[160] &quot;    # Override conf.cont_medians&quot;                                                                                                              
[161] &quot;    # Create default cuts for conf.cont_medians not in defaultcut_names&quot;                                                                       
[162] &quot;    if (!is.null(defaultcut_names)) {&quot;                                                                                                         
[163] &quot;      tocut &lt;- setdiff(conf.cont_medians, defaultcut_names)&quot;                                                                                   
[164] &quot;      if (length(tocut) &gt; 0) {&quot;                                                                                                                
[165] &quot;        conf_force_add &lt;- get_conf_force(df = df, conf.force.names = tocut, cont.cutoff = 4)&quot;                                                  
[166] &quot;      }&quot;                                                                                                                                       
[167] &quot;      # Override cuts at medians&quot;                                                                                                              
[168] &quot;      conf.cont_medians &lt;- NULL&quot;                                                                                                               
[169] &quot;    }&quot;                                                                                                                                         
[170] &quot;    if (is.null(defaultcut_names)) {&quot;                                                                                                          
[171] &quot;      tocut &lt;- conf.cont_medians&quot;                                                                                                              
[172] &quot;      if (length(tocut) &gt; 0) {&quot;                                                                                                                
[173] &quot;        conf_force_add &lt;- get_conf_force(df = df, conf.force.names = tocut, cont.cutoff = 4)&quot;                                                  
[174] &quot;      }&quot;                                                                                                                                       
[175] &quot;      # Override cuts at medians&quot;                                                                                                              
[176] &quot;      conf.cont_medians &lt;- NULL&quot;                                                                                                               
[177] &quot;    }&quot;                                                                                                                                         
[178] &quot;    # Append to conf_force&quot;                                                                                                                    
[179] &quot;    conf_force &lt;- c(conf_force, conf_force_add)&quot;                                                                                               
[180] &quot;    if (details) {&quot;                                                                                                                            
[181] &quot;      toprint &lt;- min(20, length(conf_force_add))&quot;                                                                                              
[182] &quot;      cat(\&quot;Default cuts included (1st 20)\&quot;, c(conf_force_add[1:toprint]), \&quot;\\n\&quot;)&quot;                                                          
[183] &quot;      cat(\&quot;Categorical:\&quot;, c(conf.categorical), \&quot;\\n\&quot;)&quot;                                                                                     
[184] &quot;    }&quot;                                                                                                                                         
[185] &quot;  }&quot;                                                                                                                                           
[186] &quot;  if (!use_lasso &amp;&amp; cut_type == \&quot;median\&quot;) {&quot;                                                                                                 
[187] &quot;    if (!is.null(defaultcut_names)) {&quot;                                                                                                         
[188] &quot;       conf.cont_medians &lt;- setdiff(conf.cont_medians, defaultcut_names)&quot;                                                                      
[189] &quot;     }&quot;                                                                                                                                        
[190] &quot;    if (details) {&quot;                                                                                                                            
[191] &quot;      toprint &lt;- min(20, length(conf.cont_medians))&quot;                                                                                           
[192] &quot;      cat(\&quot;Median cuts included:\&quot;, c(conf.cont_medians[1:toprint]), \&quot;\\n\&quot;)&quot;                                                                
[193] &quot;      cat(\&quot;Categorical:\&quot;, c(conf.categorical), \&quot;\\n\&quot;)&quot;                                                                                     
[194] &quot;    }&quot;                                                                                                                                         
[195] &quot;  }&quot;                                                                                                                                           
[196] &quot;&quot;                                                                                                                                              
[197] &quot;  if(!is.null(conf.cont_medians_force)){&quot;                                                                                                      
[198] &quot;    conf.cont_medians&lt;-c(conf.cont_medians,conf.cont_medians_force)&quot;                                                                           
[199] &quot;  }&quot;                                                                                                                                           
[200] &quot;  if(details &amp; use_grf){&quot;                                                                                                                      
[201] &quot;    cat(\&quot;Factors per GRF:\&quot;,c(grf_cuts),\&quot;\\n\&quot;)&quot;                                                                                             
[202] &quot;  }&quot;                                                                                                                                           
[203] &quot;  if(details &amp; use_grf &amp; length(conf.cont_medians)&gt;0){&quot;                                                                                        
[204] &quot;    toprint &lt;- min(20,length(conf.cont_medians))&quot;                                                                                              
[205] &quot;    cat(\&quot;Continuous factors initially cut at medians:\&quot;,c(conf.cont_medians[1:toprint]),\&quot;\\n\&quot;)&quot;                                             
[206] &quot;  }&quot;                                                                                                                                           
[207] &quot;  # Remove any factors to cut at median if already in GRF&quot;                                                                                     
[208] &quot;  # Remove any factors to cut at median if already in GRF&quot;                                                                                     
[209] &quot;  if (replace_med_grf) {&quot;                                                                                                                      
[210] &quot;    if (use_grf &amp;&amp; length(conf.cont_medians) &gt; 0 &amp;&amp; length(grf_cuts) &gt; 0) {&quot;                                                                   
[211] &quot;      # Find which conf.cont_medians are present in any grf_cuts&quot;                                                                              
[212] &quot;      to_exclude &lt;- vapply(&quot;                                                                                                                   
[213] &quot;        conf.cont_medians,&quot;                                                                                                                    
[214] &quot;        function(x) any(grepl(x, grf_cuts)),&quot;                                                                                                  
[215] &quot;        logical(1)&quot;                                                                                                                            
[216] &quot;      )&quot;                                                                                                                                       
[217] &quot;      # Update conf.cont_medians&quot;                                                                                                              
[218] &quot;      if (any(to_exclude)) {&quot;                                                                                                                  
[219] &quot;        conf.cont_medians &lt;- conf.cont_medians[!to_exclude]&quot;                                                                                   
[220] &quot;        if (length(conf.cont_medians) == 0) conf.cont_medians &lt;- NULL&quot;                                                                         
[221] &quot;      }&quot;                                                                                                                                       
[222] &quot;    }&quot;                                                                                                                                         
[223] &quot;    if (details &amp;&amp; use_grf &amp;&amp; length(conf.cont_medians) &gt; 0) {&quot;                                                                                
[224] &quot;      cat(\&quot;Factors after removing any duplicates also in GRF:\&quot;, conf.cont_medians, \&quot;\\n\&quot;)&quot;                                                 
[225] &quot;    }&quot;                                                                                                                                         
[226] &quot;  }&quot;                                                                                                                                           
[227] &quot;&quot;                                                                                                                                              
[228] &quot;  if(details &amp; cut_type==\&quot;median\&quot; &amp; use_lasso &amp; length(conf.cont_medians)==0){&quot;                                                              
[229] &quot;    cat(\&quot;***conf.cont_medians is NULL --&gt; NO MEDIAN CUTS per lasso***\&quot;,\&quot;\\n\&quot;)&quot;                                                             
[230] &quot;  }&quot;                                                                                                                                           
[231] &quot;&quot;                                                                                                                                              
[232] &quot;  # Re-introduce conf.cont_force_medians&quot;                                                                                                      
[233] &quot;  if(!is.null(conf.cont_medians_force)) conf.cont_medians &lt;- c(conf.cont_medians,conf.cont_medians_force)&quot;                                     
[234] &quot;  conf.cont_Medcuts&lt;-NULL&quot;                                                                                                                     
[235] &quot;  medians &lt;- sapply(conf.cont_medians, function(x) round(median(df[[x]]), 2))&quot;                                                                 
[236] &quot;  conf.cont_Medcuts_vec &lt;- paste0(conf.cont_medians, ' &lt;= ', medians)&quot;                                                                         
[237] &quot;  conf.cont_Medcuts_vec&quot;                                                                                                                       
[238] &quot;  confs&lt;-c(conf.categorical,conf.cont_Medcuts)&quot;                                                                                                
[239] &quot;  # At this stage, these are confs per Lasso (GRF step is next)&quot;                                                                               
[240] &quot;  if(use_lasso) confs_lasso &lt;- confs&quot;                                                                                                          
[241] &quot;  # Factors included per GRF not in confs_lasso&quot;                                                                                               
[242] &quot;  if(use_grf){&quot;                                                                                                                                
[243] &quot;    if(details) cat('Initial GRF cuts included', grf_cuts, '\\n')&quot;                                                                             
[244] &quot;    if(length(confs) &gt; 0 &amp; length(grf_cuts) &gt; 0){&quot;                                                                                             
[245] &quot;      # Vectorized check: keep only grf_cuts not matching any confs&quot;                                                                           
[246] &quot;      flag_omit &lt;- sapply(grf_cuts, function(cut) any(sapply(confs, function(x) grepl(x, cut))))&quot;                                              
[247] &quot;      grf_cuts_keep &lt;- grf_cuts[!flag_omit]&quot;                                                                                                   
[248] &quot;      confs &lt;- unique(c(confs, grf_cuts_keep))&quot;                                                                                                
[249] &quot;    }&quot;                                                                                                                                         
[250] &quot;    if(length(confs) == 0 &amp; length(grf_cuts) &gt; 0){&quot;                                                                                            
[251] &quot;      grf_cuts_keep &lt;- grf_cuts&quot;                                                                                                               
[252] &quot;      confs &lt;- unique(c(confs, grf_cuts_keep))&quot;                                                                                                
[253] &quot;    }&quot;                                                                                                                                         
[254] &quot;  }&quot;                                                                                                                                           
[255] &quot;  if(use_lasso &amp; use_grf){&quot;                                                                                                                    
[256] &quot;    which_both &lt;- (confs %in% confs_lasso)&quot;                                                                                                    
[257] &quot;    if(details &amp; length(which_both) &gt;0){&quot;                                                                                                      
[258] &quot;      cat(\&quot;Factors included per GRF (not in lasso)\&quot;,c(confs[!which_both]),\&quot;\\n\&quot;)&quot;                                                          
[259] &quot;    }&quot;                                                                                                                                         
[260] &quot;  }&quot;                                                                                                                                           
[261] &quot;  conf_forceNew &lt;- vapply(&quot;                                                                                                                    
[262] &quot;    conf_force,&quot;                                                                                                                               
[263] &quot;    process_conf_force_expr,&quot;                                                                                                                  
[264] &quot;    FUN.VALUE = character(1),&quot;                                                                                                                 
[265] &quot;    df = df&quot;                                                                                                                                   
[266] &quot;  )&quot;                                                                                                                                           
[267] &quot;  if(!is.null(conf_force)) confs &lt;- unique(c(confs,conf_forceNew))&quot;                                                                            
[268] &quot;  # Excluding cuts&quot;                                                                                                                            
[269] &quot;  if(!is.null(exclude_cuts)){&quot;                                                                                                                 
[270] &quot;    # Remove the restricted cuts (eg., not allowing a variable to be \&quot;&lt;=\&quot;)&quot;                                                                  
[271] &quot;    for(ee in 1:length(exclude_cuts)){&quot;                                                                                                        
[272] &quot;      to_exclude &lt;- grepl(exclude_cuts[ee],confs)&quot;                                                                                             
[273] &quot;      confs &lt;- confs[!to_exclude]&quot;                                                                                                             
[274] &quot;    }&quot;                                                                                                                                         
[275] &quot;  }&quot;                                                                                                                                           
[276] &quot;  n_confs&lt;-length(confs)&quot;                                                                                                                      
[277] &quot;  if(n_confs==0) stop(\&quot;Error in FS dataset prior to flag drop\&quot;)&quot;                                                                             
[278] &quot;  # Arrange by continuous and categorical&quot;                                                                                                     
[279] &quot;  # Classify as continuous or categorical&quot;                                                                                                     
[280] &quot;  # The function flag_continuous and flag_drop execute the following via vapply&quot;                                                               
[281] &quot;  #flag_continuous&lt;-rep(NA,length(confs))&quot;                                                                                                     
[282] &quot;  #flag_drop&lt;-rep(NA,length(confs)) # Flag factors with only 1 level and drop&quot;                                                                 
[283] &quot;  # for(ccs in 1:length(confs)){&quot;                                                                                                              
[284] &quot;  #   thiscut&lt;-confs[ccs]&quot;                                                                                                                     
[285] &quot;  #   # Covariate corresponding to&quot;                                                                                                            
[286] &quot;  #   cov_index&lt;-c(unlist(lapply(confounders.name,function(x){grepl(x,thiscut)})))&quot;                                                            
[287] &quot;  #   cut_name&lt;-confounders.name[cov_index]&quot;                                                                                                   
[288] &quot;  #   aa&lt;-df[,c(cut_name)]&quot;                                                                                                                    
[289] &quot;  #   flag_continuous[ccs]&lt;-(is.continuous(aa,cutoff=cont.cutoff)==1)&quot;                                                                         
[290] &quot;  #   flag_drop[ccs]&lt;-(length(unique(aa))&lt;=1)&quot;                                                                                                 
[291] &quot;  # }&quot;                                                                                                                                         
[292] &quot;  flag_continuous &lt;- vapply(&quot;                                                                                                                  
[293] &quot;    confs,&quot;                                                                                                                                    
[294] &quot;    is_flag_continuous,&quot;                                                                                                                       
[295] &quot;    FUN.VALUE = logical(1),&quot;                                                                                                                   
[296] &quot;    confounders.name = confounders.name,&quot;                                                                                                      
[297] &quot;    df = df,&quot;                                                                                                                                  
[298] &quot;    cont.cutoff = cont.cutoff&quot;                                                                                                                 
[299] &quot;  )&quot;                                                                                                                                           
[300] &quot;  flag_drop &lt;- vapply(&quot;                                                                                                                        
[301] &quot;    confs,&quot;                                                                                                                                    
[302] &quot;    is_flag_drop,&quot;                                                                                                                             
[303] &quot;    FUN.VALUE = logical(1),&quot;                                                                                                                   
[304] &quot;    confounders.name = confounders.name,&quot;                                                                                                      
[305] &quot;    df = df&quot;                                                                                                                                   
[306] &quot;  )&quot;                                                                                                                                           
[307] &quot;  if(details &amp; any(flag_drop)){&quot;                                                                                                               
[308] &quot;    cat(\&quot;Dropping variables (only 1 level):\&quot;,c(confs[flag_drop]),\&quot;\\n\&quot;)&quot;                                                                   
[309] &quot;  }&quot;                                                                                                                                           
[310] &quot;  conf.categorical&lt;-confs[!flag_continuous &amp; !flag_drop]&quot;                                                                                      
[311] &quot;  conf.cont_cuts &lt;- NULL&quot;                                                                                                                      
[312] &quot;  if(sum(flag_continuous)&gt;0){&quot;                                                                                                                 
[313] &quot;    conf.cont_cuts&lt;-confs[flag_continuous &amp; !flag_drop]&quot;                                                                                       
[314] &quot;  }&quot;                                                                                                                                           
[315] &quot;  # Note, possibility that a cut point only has 1 level&quot;                                                                                       
[316] &quot;  # Drop any such factors&quot;                                                                                                                     
[317] &quot;  flag_drop2&lt;-NULL&quot;                                                                                                                            
[318] &quot;   if(length(conf.cont_cuts)&gt;=1){&quot;                                                                                                             
[319] &quot;    flag_drop2 &lt;- sapply(conf.cont_cuts, function(thiscut) {&quot;                                                                                  
[320] &quot;      qcheck &lt;- as.factor(ifelse(eval(parse(text=thiscut), envir=df), 1, 0))&quot;                                                                  
[321] &quot;      length(unique(qcheck)) &lt;= 1&quot;                                                                                                             
[322] &quot;    })&quot;                                                                                                                                        
[323] &quot;    if(details &amp; any(flag_drop2)){&quot;                                                                                                            
[324] &quot;      cat(\&quot;Dropping variables (cut only has 1 level)\&quot;,c(conf.cont_cuts[flag_drop2]),\&quot;\\n\&quot;)&quot;                                                
[325] &quot;    }&quot;                                                                                                                                         
[326] &quot;    conf.cont_cuts&lt;-conf.cont_cuts[!flag_drop2]&quot;                                                                                               
[327] &quot;} # flag_drop2&quot;                                                                                                                                
[328] &quot;  # n_confs after drop1 and drop2&quot;                                                                                                             
[329] &quot;  n_confs&lt;-n_confs-(sum(flag_drop)+sum(flag_drop2))&quot;                                                                                           
[330] &quot;  confs&lt;-c(conf.cont_cuts,conf.categorical)&quot;                                                                                                   
[331] &quot;  if(length(confs)!=n_confs) stop(\&quot;Error in categorical and continuous classifications\&quot;)&quot;                                                    
[332] &quot;  # These will be names q1,..,qK (say)&quot;                                                                                                        
[333] &quot;  names_new&lt;-c(unlist(lapply(c(1:length(confs)),function(x){paste0(\&quot;q\&quot;,x,sep=\&quot;\&quot;)})))&quot;                                                      
[334] &quot;  for(i in seq_along(conf.cont_cuts)) {&quot;                                                                                                       
[335] &quot;    thiscut &lt;- conf.cont_cuts[i]&quot;                                                                                                              
[336] &quot;    df[[names_new[i]]] &lt;- as.factor(as.numeric(ifelse(eval(parse(text=thiscut), envir=df), 1, 0)))&quot;                                            
[337] &quot;  }&quot;                                                                                                                                           
[338] &quot;  # Add categorical cuts as new columns&quot;                                                                                                       
[339] &quot;  offset &lt;- length(conf.cont_cuts)&quot;                                                                                                            
[340] &quot;  for(i in seq_along(conf.categorical)) {&quot;                                                                                                     
[341] &quot;    thiscut &lt;- conf.categorical[i]&quot;                                                                                                            
[342] &quot;    df[[names_new[i + offset]]] &lt;- as.factor(as.numeric(eval(parse(text=thiscut), envir=df)))&quot;                                                 
[343] &quot;  }&quot;                                                                                                                                           
[344] &quot;  # NOTE: include check that all confs are 0,1 (not TRUE, FALSE)&quot;                                                                              
[345] &quot;  check_factors&lt;-apply(df[,c(names_new)],2,function(x){c(unique(x))})&quot;                                                                         
[346] &quot;  if(any(c(check_factors) %in% c(\&quot;TRUE\&quot;,\&quot;FALSE\&quot;))) stop(\&quot;Error in factor setup\&quot;)&quot;                                                        
[347] &quot;  if(details){&quot;                                                                                                                                
[348] &quot;    cat(\&quot;# of candidate subgroup factors=\&quot;,c(length(confs)),\&quot;\\n\&quot;)&quot;                                                                        
[349] &quot;    print(confs)&quot;                                                                                                                              
[350] &quot;  }&quot;                                                                                                                                           
[351] &quot;  return(list(df = df, confs_names = names_new, confs = confs, lassokeep = lassokeep, lassoomit = lassoomit))&quot;                                 
[352] &quot;}&quot;                                                                                                                                             

$subgroup_search
  [1] &quot;# minp = Minimum prevalence rate&quot;                                                                                                     
  [2] &quot;# Only combinations where all factors have prevalance at least minp are evaluated&quot;                                                    
  [3] &quot;# Minimum difference in subgroup sample size&quot;                                                                                         
  [4] &quot;# Max subgroup size is n: After first factor x1 is added, the sample size for&quot;                                                        
  [5] &quot;# the subgroup is then n(x1), say.   If combining with next factor x2&quot;                                                                
  [6] &quot;# does not reduce the sample size by rmin, then consider this combination \&quot;redundant\&quot;&quot;                                              
  [7] &quot;# Adding d.min to require min(Events) per treatment arm (d0.min for control, d1.min for treatment)&quot;                                   
  [8] &quot;# covs.in[isin,]&lt;-unlist(lapply(covs.in[isin,],function(x){ifelse(x==1,0,1)})) # slower&quot;                                              
  [9] &quot;&quot;                                                                                                                                     
 [10] &quot;&quot;                                                                                                                                     
 [11] &quot;&quot;                                                                                                                                     
 [12] &quot;#' Get all combinations of subgroup factors up to maxk&quot;                                                                               
 [13] &quot;#'&quot;                                                                                                                                   
 [14] &quot;#' Generates all possible combinations of subgroup factors up to a specified maximum size.&quot;                                           
 [15] &quot;#'&quot;                                                                                                                                   
 [16] &quot;#' @param L Integer. Number of subgroup factors.&quot;                                                                                     
 [17] &quot;#' @param maxk Integer. Maximum number of factors in a combination.&quot;                                                                  
 [18] &quot;#' @return List with \\code{max_count} (total combinations) and \\code{indices_list} (indices for each k).&quot;                           
 [19] &quot;#' @importFrom utils combn&quot;                                                                                                           
 [20] &quot;#' @export&quot;                                                                                                                           
 [21] &quot;&quot;                                                                                                                                     
 [22] &quot;get_combinations_info &lt;- function(L, maxk) {&quot;                                                                                         
 [23] &quot;  # Calculate max_count&quot;                                                                                                              
 [24] &quot;  max_count &lt;- 0&quot;                                                                                                                     
 [25] &quot;  indices_list &lt;- list()&quot;                                                                                                             
 [26] &quot;  for (k in 1:maxk) {&quot;                                                                                                                
 [27] &quot;    indices_k &lt;- base::t(combn(L, k))&quot;                                                                                                
 [28] &quot;    indices_list[[paste0(\&quot;k\&quot;, k)]] &lt;- indices_k&quot;                                                                                    
 [29] &quot;    max_count &lt;- max_count + nrow(indices_k)&quot;                                                                                         
 [30] &quot;  }&quot;                                                                                                                                  
 [31] &quot;  # Consistency check&quot;                                                                                                                
 [32] &quot;  tot_counts &lt;- sum(sapply(indices_list, nrow))&quot;                                                                                      
 [33] &quot;  if (tot_counts != max_count) stop(\&quot;Error with maximum combinations for kmax = \&quot;, maxk)&quot;                                           
 [34] &quot;  list(&quot;                                                                                                                              
 [35] &quot;    max_count = max_count,&quot;                                                                                                           
 [36] &quot;    indices_list = indices_list&quot;                                                                                                      
 [37] &quot;  )&quot;                                                                                                                                  
 [38] &quot;}&quot;                                                                                                                                    
 [39] &quot;&quot;                                                                                                                                     
 [40] &quot;&quot;                                                                                                                                     
 [41] &quot;#' Get subgroup membership vector&quot;                                                                                                    
 [42] &quot;#'&quot;                                                                                                                                   
 [43] &quot;#' Returns a vector indicating subgroup membership (1 if all selected factors are present, 0 otherwise).&quot;                             
 [44] &quot;#'&quot;                                                                                                                                   
 [45] &quot;#' @param zz Matrix or data frame of subgroup factor indicators.&quot;                                                                     
 [46] &quot;#' @param covs.in Numeric vector indicating which factors are selected (1 = included).&quot;                                               
 [47] &quot;#' @return Numeric vector of subgroup membership (1/0).&quot;                                                                              
 [48] &quot;#' @export&quot;                                                                                                                           
 [49] &quot;&quot;                                                                                                                                     
 [50] &quot;get_subgroup_membership &lt;- function(zz, covs.in) {&quot;                                                                                   
 [51] &quot;  x &lt;- zz[, which(covs.in == 1), drop = FALSE]&quot;                                                                                       
 [52] &quot;  if (ncol(x) == 0) return(rep(1, nrow(zz)))&quot;                                                                                         
 [53] &quot;  apply(x, 1, function(row) all(row == 1))&quot;                                                                                           
 [54] &quot;}&quot;                                                                                                                                    
 [55] &quot;&quot;                                                                                                                                     
 [56] &quot;#' Get indicator vector for selected subgroup factors&quot;                                                                                
 [57] &quot;#'&quot;                                                                                                                                   
 [58] &quot;#' Returns a vector indicating which factors are included in a subgroup combination.&quot;                                                 
 [59] &quot;#'&quot;                                                                                                                                   
 [60] &quot;#' @param kk Integer. Index of the combination.&quot;                                                                                      
 [61] &quot;#' @param maxk Integer. Maximum number of factors in a combination.&quot;                                                                  
 [62] &quot;#' @param L Integer. Number of subgroup factors.&quot;                                                                                     
 [63] &quot;#' @param counts_1factor Integer. Number of single-factor combinations.&quot;                                                              
 [64] &quot;#' @param index_1factor Matrix of indices for single-factor combinations.&quot;                                                            
 [65] &quot;#' @param counts_2factor Integer. Number of two-factor combinations.&quot;                                                                 
 [66] &quot;#' @param index_2factor Matrix of indices for two-factor combinations.&quot;                                                               
 [67] &quot;#' @param counts_3factor Integer. Number of three-factor combinations.&quot;                                                               
 [68] &quot;#' @param index_3factor Matrix of indices for three-factor combinations.&quot;                                                             
 [69] &quot;#' @return Numeric vector indicating selected factors (1 = included, 0 = not included).&quot;                                              
 [70] &quot;#' @export&quot;                                                                                                                           
 [71] &quot;&quot;                                                                                                                                     
 [72] &quot;get_covs_in &lt;- function(kk, maxk, L,&quot;                                                                                                 
 [73] &quot;                        counts_1factor, index_1factor,&quot;                                                                               
 [74] &quot;                        counts_2factor = NULL, index_2factor = NULL,&quot;                                                                 
 [75] &quot;                        counts_3factor = NULL, index_3factor = NULL) {&quot;                                                               
 [76] &quot;  covs.in &lt;- rep(0, L)&quot;                                                                                                               
 [77] &quot;  if (kk &lt;= counts_1factor) {&quot;                                                                                                        
 [78] &quot;    which1 &lt;- index_1factor[kk]&quot;                                                                                                      
 [79] &quot;    covs.in[which1] &lt;- 1.0&quot;                                                                                                           
 [80] &quot;  } else if (maxk == 2 &amp;&amp; kk &gt; counts_1factor) {&quot;                                                                                     
 [81] &quot;    kk_new &lt;- kk - counts_1factor&quot;                                                                                                    
 [82] &quot;    which1 &lt;- index_2factor[kk_new, 1]&quot;                                                                                               
 [83] &quot;    which2 &lt;- index_2factor[kk_new, 2]&quot;                                                                                               
 [84] &quot;    covs.in[c(which1, which2)] &lt;- 1.0&quot;                                                                                                
 [85] &quot;  } else if (maxk == 3) {&quot;                                                                                                            
 [86] &quot;    if (kk &gt; counts_1factor &amp;&amp; kk &lt;= (counts_1factor + counts_2factor)) {&quot;                                                            
 [87] &quot;      kk_new &lt;- kk - counts_1factor&quot;                                                                                                  
 [88] &quot;      which1 &lt;- index_2factor[kk_new, 1]&quot;                                                                                             
 [89] &quot;      which2 &lt;- index_2factor[kk_new, 2]&quot;                                                                                             
 [90] &quot;      covs.in[c(which1, which2)] &lt;- 1.0&quot;                                                                                              
 [91] &quot;    }&quot;                                                                                                                                
 [92] &quot;    if (kk &gt; (counts_1factor + counts_2factor)) {&quot;                                                                                    
 [93] &quot;      kk_new &lt;- kk - (counts_1factor + counts_2factor)&quot;                                                                               
 [94] &quot;      which1 &lt;- index_3factor[kk_new, 1]&quot;                                                                                             
 [95] &quot;      which2 &lt;- index_3factor[kk_new, 2]&quot;                                                                                             
 [96] &quot;      which3 &lt;- index_3factor[kk_new, 3]&quot;                                                                                             
 [97] &quot;      covs.in[c(which1, which2, which3)] &lt;- 1.0&quot;                                                                                      
 [98] &quot;    }&quot;                                                                                                                                
 [99] &quot;  }&quot;                                                                                                                                  
[100] &quot;  covs.in&quot;                                                                                                                            
[101] &quot;}&quot;                                                                                                                                    
[102] &quot;&quot;                                                                                                                                     
[103] &quot;#' Extract redundancy flag for subgroup combinations&quot;                                                                                 
[104] &quot;#'&quot;                                                                                                                                   
[105] &quot;#' Checks if adding each factor to a subgroup reduces the sample size by at least \\code{rmin}.&quot;                                      
[106] &quot;#'&quot;                                                                                                                                   
[107] &quot;#' @param x Matrix of subgroup factor indicators.&quot;                                                                                    
[108] &quot;#' @param rmin Integer. Minimum required reduction in sample size.&quot;                                                                   
[109] &quot;#' @return List with \\code{id.x} (membership vector) and \\code{flag.redundant} (logical).&quot;                                          
[110] &quot;#' @export&quot;                                                                                                                           
[111] &quot;&quot;                                                                                                                                     
[112] &quot;extract_idx_flagredundancy &lt;- function(x, rmin) {&quot;                                                                                    
[113] &quot;  n &lt;- nrow(x)&quot;                                                                                                                       
[114] &quot;  id.x &lt;- rep(1, n)&quot;                                                                                                                  
[115] &quot;  flag.redundant &lt;- FALSE&quot;                                                                                                            
[116] &quot;  nx.last &lt;- n&quot;                                                                                                                       
[117] &quot;  for (m in 1:ncol(x)) {&quot;                                                                                                             
[118] &quot;    if (!flag.redundant) {&quot;                                                                                                           
[119] &quot;      id.x &lt;- id.x * x[, m]&quot;                                                                                                          
[120] &quot;      nx.this &lt;- sum(id.x)&quot;                                                                                                           
[121] &quot;      if (nx.last - nx.this &lt;= rmin) flag.redundant &lt;- TRUE&quot;                                                                          
[122] &quot;      nx.last &lt;- nx.this&quot;                                                                                                             
[123] &quot;    }&quot;                                                                                                                                
[124] &quot;  }&quot;                                                                                                                                  
[125] &quot;  list(id.x = id.x, flag.redundant = flag.redundant)&quot;                                                                                 
[126] &quot;}&quot;                                                                                                                                    
[127] &quot;&quot;                                                                                                                                     
[128] &quot;#' Subgroup search for treatment effect heterogeneity&quot;                                                                                
[129] &quot;#'&quot;                                                                                                                                   
[130] &quot;#' Searches for subgroups with treatment effect heterogeneity using combinations of candidate factors.&quot;                               
[131] &quot;#' Evaluates subgroups for minimum prevalence, event counts, and hazard ratio threshold.&quot;                                             
[132] &quot;#'&quot;                                                                                                                                   
[133] &quot;#' @param Y Numeric vector of outcome (e.g., time-to-event).&quot;                                                                         
[134] &quot;#' @param Event Numeric vector of event indicators (0/1).&quot;                                                                            
[135] &quot;#' @param Treat Numeric vector of treatment group indicators (0/1).&quot;                                                                  
[136] &quot;#' @param ID Optional vector of subject IDs.&quot;                                                                                         
[137] &quot;#' @param Z Matrix or data frame of candidate subgroup factors (binary indicators).&quot;                                                  
[138] &quot;#' @param n.min Integer. Minimum subgroup size.&quot;                                                                                      
[139] &quot;#' @param d0.min Integer. Minimum number of events in control.&quot;                                                                       
[140] &quot;#' @param d1.min Integer. Minimum number of events in treatment.&quot;                                                                     
[141] &quot;#' @param hr.threshold Numeric. Hazard ratio threshold for subgroup selection.&quot;                                                       
[142] &quot;#' @param max.minutes Numeric. Maximum minutes for search.&quot;                                                                           
[143] &quot;#' @param minp Numeric. Minimum prevalence rate for each factor.&quot;                                                                     
[144] &quot;#' @param rmin Integer. Minimum required reduction in sample size when adding a factor.&quot;                                              
[145] &quot;#' @param details Logical. Print details during execution.&quot;                                                                           
[146] &quot;#' @param maxk Integer. Maximum number of factors in a subgroup.&quot;                                                                     
[147] &quot;#'&quot;                                                                                                                                   
[148] &quot;#' @return List with found subgroups, maximum HR, search time, and configuration info.&quot;                                               
[149] &quot;#'&quot;                                                                                                                                   
[150] &quot;#' @importFrom data.table data.table setorder&quot;                                                                                        
[151] &quot;#' @importFrom survival coxph Surv survfit&quot;                                                                                           
[152] &quot;#' @importFrom utils combn&quot;                                                                                                           
[153] &quot;#' @export&quot;                                                                                                                           
[154] &quot;&quot;                                                                                                                                     
[155] &quot;subgroup.search &lt;- function(Y,Event,Treat,ID = NULL,Z,n.min = 30,d0.min = 15,d1.min = 15,&quot;                                            
[156] &quot;hr.threshold = 1.0,max.minutes = 30,minp = 0.05,rmin = 5,details = FALSE,maxk = 2){&quot;                                                  
[157] &quot;  temp &lt;- cbind(Y,Event,Treat,Z)&quot;                                                                                                     
[158] &quot;  temp &lt;- na.exclude(temp)&quot;                                                                                                           
[159] &quot;  yy &lt;- temp[,1]&quot;                                                                                                                     
[160] &quot;  dd &lt;- temp[,2]&quot;                                                                                                                     
[161] &quot;  tt &lt;- temp[,3]&quot;                                                                                                                     
[162] &quot;  zz &lt;- temp[,-c(1,2,3)]&quot;                                                                                                             
[163] &quot;  n &lt;- length(yy)&quot;                                                                                                                    
[164] &quot;  L &lt;- ncol(zz)&quot;                                                                                                                      
[165] &quot;  covs.in &lt;- as.matrix(rep(0,L)) # Initially no members&quot;                                                                              
[166] &quot;  # Store results appending to HR.model.k&quot;                                                                                            
[167] &quot;  HR.model.k &lt;- NULL&quot;                                                                                                                 
[168] &quot;  limit_all&lt;-(2**L)-1 # All-possible configurations including redundancies&quot;                                                           
[169] &quot;  # Maximum number of combinations among factors &lt;= maxk&quot;                                                                             
[170] &quot;  if(maxk == 1) max_count &lt;- L&quot;                                                                                                       
[171] &quot;  if(maxk == 2){&quot;                                                                                                                     
[172] &quot;  # choose(L,2)+choose(L,1)&quot;                                                                                                          
[173] &quot;  max_count &lt;- (L*(L-1)/2) + L&quot;                                                                                                       
[174] &quot;  }&quot;                                                                                                                                  
[175] &quot;  if(maxk==3){&quot;                                                                                                                       
[176] &quot;  choose(L,3)+choose(L,2)+choose(L,1)&quot;                                                                                                
[177] &quot;  max_count &lt;- ((L*(L-2)*(L-1))/6)+(L*(L-1)/2) + L&quot;                                                                                   
[178] &quot;  }&quot;                                                                                                                                  
[179] &quot;  if(maxk == 1){&quot;                                                                                                                     
[180] &quot;    index_1factor &lt;- t(combn(L, 1))&quot;                                                                                                  
[181] &quot;    counts_1factor &lt;- nrow(index_1factor)&quot;                                                                                            
[182] &quot;    tot_counts &lt;- counts_1factor&quot;                                                                                                     
[183] &quot;    if(tot_counts != max_count) stop(\&quot;Error with maximum combinations kmax=2\&quot;)&quot;                                                     
[184] &quot;  }&quot;                                                                                                                                  
[185] &quot;  if(maxk == 2){&quot;                                                                                                                     
[186] &quot;  index_2factor &lt;- t(combn(L, 2))&quot;                                                                                                    
[187] &quot;  counts_2factor &lt;- nrow(index_2factor)&quot;                                                                                              
[188] &quot;  index_1factor &lt;- t(combn(L, 1))&quot;                                                                                                    
[189] &quot;  counts_1factor &lt;- nrow(index_1factor)&quot;                                                                                              
[190] &quot;  tot_counts &lt;- counts_2factor+counts_1factor&quot;                                                                                        
[191] &quot;  if(tot_counts != max_count) stop(\&quot;Error with maximum combinations kmax=2\&quot;)&quot;                                                       
[192] &quot;  }&quot;                                                                                                                                  
[193] &quot;  if(maxk == 3){&quot;                                                                                                                     
[194] &quot;    index_3factor &lt;- t(combn(L, 3))&quot;                                                                                                  
[195] &quot;    counts_3factor &lt;- nrow(index_3factor)&quot;                                                                                            
[196] &quot;    index_2factor &lt;- t(combn(L, 2))&quot;                                                                                                  
[197] &quot;    counts_2factor &lt;- nrow(index_2factor)&quot;                                                                                            
[198] &quot;    index_1factor &lt;- t(combn(L, 1))&quot;                                                                                                  
[199] &quot;    counts_1factor &lt;- nrow(index_1factor)&quot;                                                                                            
[200] &quot;    tot_counts &lt;- counts_3factor+counts_2factor+counts_1factor&quot;                                                                       
[201] &quot;    if(tot_counts != max_count) stop(\&quot;Error with maximum combinations kmax=2\&quot;)&quot;                                                     
[202] &quot;  }&quot;                                                                                                                                  
[203] &quot;  if(details){&quot;                                                                                                                       
[204] &quot;    cat(\&quot;Number of possible configurations (&lt;= maxk): maxk, # &lt;= maxk\&quot;,c(maxk,max_count),\&quot;\\n\&quot;)&quot;                                  
[205] &quot;  }&quot;                                                                                                                                  
[206] &quot;  t.start&lt;-proc.time()[3]&quot;                                                                                                            
[207] &quot;  t.sofar&lt;-0&quot;                                                                                                                         
[208] &quot;  # Loop through single-factor subgroups first&quot;                                                                                       
[209] &quot;  results_list &lt;- lapply(1:tot_counts, function(kk) {&quot;                                                                                
[210] &quot;    covs.in &lt;- get_covs_in(&quot;                                                                                                          
[211] &quot;      kk, maxk, L,&quot;                                                                                                                   
[212] &quot;      counts_1factor, index_1factor,&quot;                                                                                                 
[213] &quot;      counts_2factor, index_2factor,&quot;                                                                                                 
[214] &quot;      counts_3factor, index_3factor&quot;                                                                                                  
[215] &quot;    )&quot;                                                                                                                                
[216] &quot;    k.in &lt;- sum(covs.in)&quot;                                                                                                             
[217] &quot;    t.now &lt;- proc.time()[3]&quot;                                                                                                          
[218] &quot;    t.sofar &lt;- (t.now - t.start) / 60&quot;                                                                                                
[219] &quot;    if (t.sofar &gt; max.minutes) return(NULL)&quot;                                                                                          
[220] &quot;    if (k.in &gt; maxk) return(NULL)&quot;                                                                                                    
[221] &quot;&quot;                                                                                                                                     
[222] &quot;    selected_cols &lt;- which(covs.in == 1)&quot;                                                                                             
[223] &quot;    x &lt;- zz[, selected_cols, drop = FALSE]&quot;                                                                                           
[224] &quot;&quot;                                                                                                                                     
[225] &quot;    xpx &lt;- t(x) %*% x&quot;                                                                                                                
[226] &quot;    if (!all(xpx &gt; 0)) return(NULL)&quot;                                                                                                  
[227] &quot;&quot;                                                                                                                                     
[228] &quot;    get_idx_rflag &lt;- extract_idx_flagredundancy(x, rmin)&quot;                                                                             
[229] &quot;&quot;                                                                                                                                     
[230] &quot;    id.x &lt;- get_idx_rflag$id.x&quot;                                                                                                       
[231] &quot;    flag.redundant &lt;- get_idx_rflag$flag.redundant&quot;                                                                                   
[232] &quot;&quot;                                                                                                                                     
[233] &quot;    rm(\&quot;get_idx_rflag\&quot;)&quot;                                                                                                            
[234] &quot;&quot;                                                                                                                                     
[235] &quot;    d1 &lt;- sum((dd * tt)[which(id.x == 1)])&quot;                                                                                           
[236] &quot;    d0 &lt;- sum((dd * (1 - tt))[which(id.x == 1)])&quot;                                                                                     
[237] &quot;    nx &lt;- sum(id.x)&quot;                                                                                                                  
[238] &quot;&quot;                                                                                                                                     
[239] &quot;    crit3 &lt;- all(apply(x, 2, mean) &gt;= minp)&quot;                                                                                          
[240] &quot;&quot;                                                                                                                                     
[241] &quot;    if (!flag.redundant &amp;&amp; d1 &gt;= d1.min &amp;&amp; d0 &gt;= d0.min &amp;&amp; nx &gt; n.min &amp;&amp; crit3) {&quot;                                                    
[242] &quot;      data.x &lt;- data.table::data.table(Y = yy, E = dd, Treat = tt, id.x = id.x)&quot;                                                      
[243] &quot;      df.x &lt;- data.x[id.x == 1]&quot;                                                                                                      
[244] &quot;      hr.cox &lt;- try(summary(coxph(Surv(Y, E) ~ Treat, data = df.x, robust = FALSE))$conf.int, TRUE)&quot;                                  
[245] &quot;      if (!inherits(hr.cox, \&quot;try-error\&quot;)) {&quot;                                                                                        
[246] &quot;        if (hr.cox[1] &gt; hr.threshold) {&quot;                                                                                              
[247] &quot;          meds &lt;- summary(survfit(Surv(Y, E) ~ Treat, data = df.x))$table[, \&quot;median\&quot;]&quot;                                              
[248] &quot;          m0 &lt;- meds[1]&quot;                                                                                                              
[249] &quot;          m1 &lt;- meds[2]&quot;                                                                                                              
[250] &quot;          id.group &lt;- kk&quot;                                                                                                             
[251] &quot;          hr.this &lt;- c(id.group, sum(covs.in), nx, d0 + d1, d1, m1, m0, hr.cox[c(1, 3, 4)], covs.in)&quot;                                 
[252] &quot;          return(hr.this)&quot;                                                                                                            
[253] &quot;        }&quot;                                                                                                                            
[254] &quot;      }&quot;                                                                                                                              
[255] &quot;    }&quot;                                                                                                                                
[256] &quot;    return(NULL)&quot;                                                                                                                     
[257] &quot;  })&quot;                                                                                                                                 
[258] &quot;&quot;                                                                                                                                     
[259] &quot;  # Filter out NULLs and combine results&quot;                                                                                             
[260] &quot;  HR.model.k &lt;- base::do.call(rbind, Filter(Negate(is.null), results_list))&quot;                                                          
[261] &quot;&quot;                                                                                                                                     
[262] &quot;   t.end&lt;-proc.time()[3]&quot;                                                                                                             
[263] &quot;   t.min&lt;-(t.end-t.start)/60&quot;                                                                                                         
[264] &quot;&quot;                                                                                                                                     
[265] &quot;  if(details){&quot;                                                                                                                       
[266] &quot;    cat(\&quot;Events criteria for control,exp=\&quot;,c(d0.min,d1.min),\&quot;\\n\&quot;)&quot;                                                               
[267] &quot;    cat(\&quot;*Subgroup Searching Minutes=*\&quot;,c(t.min),\&quot;\\n\&quot;)&quot;                                                                          
[268] &quot;    }&quot;                                                                                                                                
[269] &quot;&quot;                                                                                                                                     
[270] &quot;  out.found&lt;-NULL&quot;                                                                                                                    
[271] &quot;  if(!is.null(HR.model.k)){&quot;                                                                                                          
[272] &quot;    hr.out &lt;- data.table::data.table(HR.model.k)&quot;                                                                                     
[273] &quot;    names(hr.out)&lt;-c(\&quot;grp\&quot;,\&quot;K\&quot;,\&quot;n\&quot;,\&quot;E\&quot;,\&quot;d1\&quot;,\&quot;m1\&quot;,\&quot;m0\&quot;,\&quot;HR\&quot;,\&quot;L(HR)\&quot;,\&quot;U(HR)\&quot;,colnames(Z))&quot;                          
[274] &quot;    rownames(hr.out)&lt;-NULL&quot;                                                                                                           
[275] &quot;    hr.out &lt;- data.table::setorder(hr.out,-HR,K)&quot;                                                                                     
[276] &quot;    out.found &lt;- list(hr.subgroups = hr.out)&quot;                                                                                         
[277] &quot;  }&quot;                                                                                                                                  
[278] &quot;  if(is.null(out.found)){&quot;                                                                                                            
[279] &quot;  if(details)    cat(\&quot;NO subgroup candidate found (FS)\&quot;,\&quot;\\n\&quot;)&quot;                                                                   
[280] &quot;  return(NULL)&quot;                                                                                                                       
[281] &quot;  } else{&quot;                                                                                                                            
[282] &quot;  if(details) cat(\&quot;Subgroup candidate(s) found (FS)\&quot;,\&quot;\\n\&quot;)&quot;                                                                      
[283] &quot;  max_sg_est &lt;- max(hr.out[[\&quot;HR\&quot;]])&quot;                                                                                                
[284] &quot;  return(list(out.found = out.found, max_sg_est = max_sg_est, time_search = t.sofar,L = L,max_count = max_count, prop_max_count = 1))&quot;
[285] &quot;  }&quot;                                                                                                                                  
[286] &quot;}&quot;                                                                                                                                    
</code></pre></div><div class="user-msg"><strong>User:</strong> Continue answering the question based on the results.</div><div class="bot-msg"><strong>ADW:</strong> <p>Here is a summary of the inspection results for your three R files:</p>
<h3>1. <code>get_FSdata_helpers.R</code></h3>
<p>This file contains a suite of helper functions for data preparation and feature selection, including:
- <strong>is.continuous</strong>: Checks if a variable is continuous based on a cutoff for unique values.
- <strong>qlow/qhigh</strong>: Computes the 25th and 75th percentiles.
- <strong>cut_var/get_conf_force</strong>: Generates cut expressions for continuous variables and retrieves forced cut expressions.
- <strong>lasso_selection</strong>: Performs LASSO variable selection for Cox regression.
- <strong>filter_by_lassokeep</strong>: Filters variables by those selected via LASSO.
- <strong>FS_labels</strong>: Formats subgroup labels for ForestSearch.
- <strong>process_conf_force_expr</strong>: Evaluates cut expressions and replaces them with actual values.
- <strong>get_cut_name/is_flag_continuous/is_flag_drop</strong>: Utilities for handling cut expressions and checking their properties.
- <strong>acm.disjctif/dummy/dummy2</strong>: Functions for dummy coding of categorical variables.
- <strong>ztrail/one.zero</strong>: Utility functions for binary operations.</p>
<h3>2. <code>get_FSdata.R</code></h3>
<p>This file contains the main function:
- <strong>get_FSdata</strong>: Prepares a dataset for ForestSearch, handling LASSO-based dimension reduction, GRF cuts, forced cuts, and flexible cut strategies. It returns a list with processed data, subgroup factor names, cut expressions, and LASSO selection results. The function is highly configurable and checks for data integrity, missing values, and proper variable types.</p>
<h3>3. <code>subgroup_search.R</code></h3>
<p>This file contains functions for subgroup search:
- <strong>get_combinations_info</strong>: Generates all possible combinations of subgroup factors up to a specified size.
- <strong>get_subgroup_membership</strong>: Returns a vector indicating subgroup membership for selected factors.
- <strong>get_covs_in</strong>: Returns an indicator vector for selected subgroup factors.
- <strong>extract_idx_flagredundancy</strong>: Checks if adding a factor to a subgroup reduces sample size sufficiently.
- <strong>subgroup.search</strong>: Main function for searching subgroups with treatment effect heterogeneity, evaluating combinations for minimum prevalence, event counts, and hazard ratio threshold.</p>
<p>If you have a specific question or want to run/test any of these functions, please provide details or data, and I can proceed with code execution or further analysis.</p></div><div class="user-msg"><strong>User:</strong> üìÅ[grf_functions.R]</div><div class="user-msg"><strong>User:</strong> üìÅ[summary_utility_functions.R]</div><div class="user-msg"><strong>User:</strong> please inspect these functions, and do not explain steps</div><div class="bot-msg"><strong>ADW:</strong> <p>üü¢Working:</p>
<pre><code class="language-R"># Read and display the contents of the new R files for inspection
grf_content &lt;- readLines('grf_functions.R')
summary_utils_content &lt;- readLines('summary_utility_functions.R')

list(
  grf_functions = grf_content,
  summary_utility_functions = summary_utils_content
)
</code></pre></div><div class="bot-msg"><strong>ADW:</strong> <p>‚úîÔ∏èTerminal output:</p>
<pre><code class="language-shell">$grf_functions
  [1] &quot;#' GRF Subgroup Identification for Survival Data&quot;                                                                                                   
  [2] &quot;#'&quot;                                                                                                                                                 
  [3] &quot;#' Identifies subgroups with differential treatment effect using generalized random forests (GRF) and policy trees.&quot;                                
  [4] &quot;#'&quot;                                                                                                                                                 
  [5] &quot;#' @param data Data frame containing the analysis data.&quot;                                                                                            
  [6] &quot;#' @param confounders.name Character vector of confounder variable names.&quot;                                                                          
  [7] &quot;#' @param outcome.name Character. Name of outcome variable (e.g., time-to-event).&quot;                                                                  
  [8] &quot;#' @param event.name Character. Name of event indicator variable (0/1).&quot;                                                                            
  [9] &quot;#' @param id.name Character. Name of ID variable.&quot;                                                                                                  
 [10] &quot;#' @param treat.name Character. Name of treatment group variable (0/1).&quot;                                                                            
 [11] &quot;#' @param frac.tau Numeric. Fraction of tau for GRF horizon (default: 1.0).&quot;                                                                        
 [12] &quot;#' @param n.min Integer. Minimum subgroup size (default: 60).&quot;                                                                                      
 [13] &quot;#' @param dmin.grf Numeric. Minimum difference in subgroup mean (default: 0.0).&quot;                                                                    
 [14] &quot;#' @param RCT Logical. Is the data from a randomized controlled trial? (default: TRUE)&quot;                                                             
 [15] &quot;#' @param details Logical. Print details during execution (default: FALSE).&quot;                                                                        
 [16] &quot;#' @param sg.criterion Character. Subgroup selection criterion (\&quot;mDiff\&quot; or \&quot;Nsg\&quot;).&quot;                                                             
 [17] &quot;#' @param maxdepth Integer. Maximum tree depth (1, 2, or 3; default: 2).&quot;                                                                           
 [18] &quot;#' @param seedit Integer. Random seed (default: 8316951).&quot;                                                                                          
 [19] &quot;#'&quot;                                                                                                                                                 
 [20] &quot;#' @return A list with GRF results, including subgroup definition, tree cuts, and policy tree objects.&quot;                                             
 [21] &quot;#'&quot;                                                                                                                                                 
 [22] &quot;#' @importFrom grf causal_survival_forest&quot;                                                                                                          
 [23] &quot;#' @importFrom policytree double_robust_scores policy_tree&quot;                                                                                         
 [24] &quot;#' @importFrom stats aggregate&quot;                                                                                                                     
 [25] &quot;#' @export&quot;                                                                                                                                         
 [26] &quot;&quot;                                                                                                                                                   
 [27] &quot;grf.subg.harm.survival &lt;- function(data,confounders.name ,outcome.name ,event.name, id.name, treat.name, frac.tau = 1.0,n.min = 60, dmin.grf = 0.0,&quot;
 [28] &quot;RCT = TRUE, details = FALSE,sg.criterion = \&quot;mDiff\&quot;, maxdepth = 2,seedit = 8316951){&quot;                                                              
 [29] &quot;if(maxdepth&gt;3) stop(\&quot;Max depth at most 3\&quot;)&quot;                                                                                                       
 [30] &quot;&quot;                                                                                                                                                   
 [31] &quot;# original data.frame version&quot;                                                                                                                      
 [32] &quot;temp &lt;- as.matrix(data[,confounders.name])&quot;                                                                                                         
 [33] &quot;# Convert to numeric&quot;                                                                                                                               
 [34] &quot;X &lt;- apply(temp,2,as.numeric)&quot;                                                                                                                      
 [35] &quot;Y &lt;- data[,outcome.name]&quot;                                                                                                                           
 [36] &quot;W &lt;- data[,treat.name]&quot;                                                                                                                             
 [37] &quot;D &lt;- data[,event.name]&quot;                                                                                                                             
 [38] &quot;&quot;                                                                                                                                                   
 [39] &quot;tau.rmst &lt;- frac.tau * min(c(max(Y[W==1 &amp; D==1]),max(Y[W==0 &amp; D==1])))&quot;                                                                             
 [40] &quot;&quot;                                                                                                                                                   
 [41] &quot;if(RCT) cs.forest &lt;- try(suppressWarnings(grf::causal_survival_forest(X,Y,W,D,W.hat=0.5,horizon=tau.rmst,seed=seedit)),TRUE)&quot;                       
 [42] &quot;if(!RCT) cs.forest &lt;- try(suppressWarnings(grf::causal_survival_forest(X,Y,W,D,horizon=tau.rmst,seed=seedit)),TRUE)&quot;                                
 [43] &quot;&quot;                                                                                                                                                   
 [44] &quot;######################################################&quot;                                                                                             
 [45] &quot;# NOTE: GRF can assign all subjects to *a* treatment&quot;                                                                                               
 [46] &quot;# Restrict to trees with at least 1 split&quot;                                                                                                          
 [47] &quot;# Equivalently, restrict to SG's with #|H| &lt; N&quot;                                                                                                     
 [48] &quot;# SG cannot include all subjects&quot;                                                                                                                   
 [49] &quot;# This is for the SG identification stage:&quot;                                                                                                         
 [50] &quot;# If no SG found, then H^c=ITT (all subjects)&quot;                                                                                                      
 [51] &quot;######################################################&quot;                                                                                             
 [52] &quot;&quot;                                                                                                                                                   
 [53] &quot;n.max &lt;- length(Y)&quot;                                                                                                                                 
 [54] &quot;&quot;                                                                                                                                                   
 [55] &quot;# Compute doubly robust scores.&quot;                                                                                                                    
 [56] &quot;dr.scores &lt;- double_robust_scores(cs.forest)&quot;                                                                                                       
 [57] &quot;&quot;                                                                                                                                                   
 [58] &quot;# Fit trees of depths 1-3&quot;                                                                                                                          
 [59] &quot;tree1 &lt;- policytree::policy_tree(X, dr.scores, depth = 1)&quot;                                                                                          
 [60] &quot;# Print and plot the tree - action 1 corresponds to control, and 2 treated.&quot;                                                                        
 [61] &quot;# predicted=1 --&gt; treat rec. = control&quot;                                                                                                             
 [62] &quot;# predicted=2 --&gt; treat rec. = treated&quot;                                                                                                             
 [63] &quot;#data$predict.action&lt;-predict(tree, X)&quot;                                                                                                             
 [64] &quot;data$predict1.node &lt;- predict(tree1,X,type=\&quot;node.id\&quot;)&quot;                                                                                            
 [65] &quot;values1 &lt;- stats::aggregate(dr.scores, by = list(leaf.node = data$predict1.node),&quot;                                                                  
 [66] &quot;                    FUN = function(x) c(mean = mean(x), size=length(x), se = sd(x) / sqrt(length(x))))&quot;                                             
 [67] &quot;values1$diff &lt;- values1$control[,\&quot;mean\&quot;]-values1$treated[,\&quot;mean\&quot;]&quot;                                                                              
 [68] &quot;values1$Nsg &lt;- values1$control[,\&quot;size\&quot;]&quot;                                                                                                          
 [69] &quot;# Only subgroups with control.size &gt; nmin.harm&quot;                                                                                                     
 [70] &quot;values1 &lt;- values1[which(values1$control[,\&quot;size\&quot;] &gt;= n.min),]&quot;                                                                                    
 [71] &quot;values1$depth &lt;- 1.0&quot;                                                                                                                               
 [72] &quot;if(maxdepth==1) values &lt;- values1&quot;                                                                                                                  
 [73] &quot;tree2 &lt;- NULL&quot;                                                                                                                                      
 [74] &quot;if(maxdepth &gt;= 2){&quot;                                                                                                                                 
 [75] &quot;tree2 &lt;- policytree::policy_tree(X, dr.scores, depth = 2)&quot;                                                                                          
 [76] &quot;data$predict2.node &lt;- predict(tree2,X,type=\&quot;node.id\&quot;)&quot;                                                                                            
 [77] &quot;values2 &lt;- stats::aggregate(dr.scores, by = list(leaf.node = data$predict2.node),&quot;                                                                  
 [78] &quot;                     FUN = function(x) c(mean = mean(x), size=length(x), se = sd(x) / sqrt(length(x))))&quot;                                            
 [79] &quot;values2$diff &lt;- values2$control[,\&quot;mean\&quot;]-values2$treated[,\&quot;mean\&quot;]&quot;                                                                              
 [80] &quot;values2$Nsg &lt;- values2$control[,\&quot;size\&quot;]&quot;                                                                                                          
 [81] &quot;values2 &lt;- values2[which(values2$control[,\&quot;size\&quot;]&gt;=n.min),]&quot;                                                                                      
 [82] &quot;values2$depth &lt;- 2.0&quot;                                                                                                                               
 [83] &quot;}&quot;                                                                                                                                                  
 [84] &quot;if(maxdepth==2) values &lt;- rbind(values1,values2)&quot;                                                                                                   
 [85] &quot;&quot;                                                                                                                                                   
 [86] &quot;&quot;                                                                                                                                                   
 [87] &quot;tree3 &lt;- NULL&quot;                                                                                                                                      
 [88] &quot;# At most depth=3&quot;                                                                                                                                  
 [89] &quot;if(maxdepth==3){&quot;                                                                                                                                   
 [90] &quot;tree3 &lt;- policytree::policy_tree(X, dr.scores, depth = 3)&quot;                                                                                          
 [91] &quot;data$predict3.node &lt;- predict(tree3,X,type=\&quot;node.id\&quot;)&quot;                                                                                            
 [92] &quot;values3 &lt;- stats::aggregate(dr.scores, by = list(leaf.node = data$predict3.node),&quot;                                                                  
 [93] &quot;                     FUN = function(x) c(mean = mean(x), size=length(x), se = sd(x) / sqrt(length(x))))&quot;                                            
 [94] &quot;values3$diff &lt;- values3$control[,\&quot;mean\&quot;]-values3$treated[,\&quot;mean\&quot;]&quot;                                                                              
 [95] &quot;values3$Nsg &lt;- values3$control[,\&quot;size\&quot;]&quot;                                                                                                          
 [96] &quot;values3 &lt;- values3[which(values3$control[,\&quot;size\&quot;]&gt;=n.min),]&quot;                                                                                      
 [97] &quot;values3$depth &lt;- 3.0&quot;                                                                                                                               
 [98] &quot;values &lt;- rbind(values1,values2,values3)&quot;                                                                                                           
 [99] &quot;}&quot;                                                                                                                                                  
[100] &quot;&quot;                                                                                                                                                   
[101] &quot;# Check that 'values' has required columns&quot;                                                                                                         
[102] &quot;required_cols &lt;- c(\&quot;diff\&quot;, \&quot;depth\&quot;)&quot;                                                                                                            
[103] &quot;if (!all(required_cols %in% names(values))) {&quot;                                                                                                      
[104] &quot;  stop(\&quot;The 'values' data.frame must contain columns: \&quot;, paste(required_cols, collapse = \&quot;, \&quot;))&quot;                                                
[105] &quot;}&quot;                                                                                                                                                  
[106] &quot;# Initialize max.diff as NULL&quot;                                                                                                                      
[107] &quot;max.diff &lt;- NULL&quot;                                                                                                                                   
[108] &quot;# Select max.diff based on criterion&quot;                                                                                                               
[109] &quot;if (identical(sg.criterion, \&quot;mDiff\&quot;)) {&quot;                                                                                                          
[110] &quot;  if (nrow(values) == 0) stop(\&quot;'values' is empty.\&quot;)&quot;                                                                                              
[111] &quot;  loc.max &lt;- which.max(values$diff)&quot;                                                                                                                
[112] &quot;  max.diff &lt;- values[loc.max, , drop = FALSE]&quot;                                                                                                      
[113] &quot;} else if (identical(sg.criterion, \&quot;Nsg\&quot;)) {&quot;                                                                                                     
[114] &quot;  if (!\&quot;Nsg\&quot; %in% names(values)) stop(\&quot;'values' must contain column 'Nsg' for Nsg criterion.\&quot;)&quot;                                                 
[115] &quot;  values_new &lt;- values[values$diff &gt;= dmin.grf, , drop = FALSE]&quot;                                                                                    
[116] &quot;  if (nrow(values_new) == 0) stop(\&quot;No rows in 'values' meet the diff &gt;= dmin.grf criterion.\&quot;)&quot;                                                    
[117] &quot;  loc.max &lt;- which.max(values_new$Nsg)&quot;                                                                                                             
[118] &quot;  max.diff &lt;- values_new[loc.max, , drop = FALSE]&quot;                                                                                                  
[119] &quot;} else {&quot;                                                                                                                                           
[120] &quot;  stop(\&quot;Unknown sg.criterion: \&quot;, sg.criterion)&quot;                                                                                                   
[121] &quot;}&quot;                                                                                                                                                  
[122] &quot;# Check that max.diff has a 'depth' column&quot;                                                                                                         
[123] &quot;if (!\&quot;depth\&quot; %in% names(max.diff)) stop(\&quot;'max.diff' must contain column 'depth'.\&quot;)&quot;                                                             
[124] &quot;# Assign predict.node and tree based on depth&quot;                                                                                                      
[125] &quot;if (max.diff$depth == 1) {&quot;                                                                                                                         
[126] &quot;  data$predict.node &lt;- data$predict1.node&quot;                                                                                                          
[127] &quot;  tree &lt;- tree1&quot;                                                                                                                                    
[128] &quot;} else if (maxdepth &gt;= 2 &amp;&amp; max.diff$depth == 2) {&quot;                                                                                                 
[129] &quot;  data$predict.node &lt;- data$predict2.node&quot;                                                                                                          
[130] &quot;  tree &lt;- tree2&quot;                                                                                                                                    
[131] &quot;} else if (maxdepth &gt;= 3 &amp;&amp; max.diff$depth == 3) {&quot;                                                                                                 
[132] &quot;  data$predict.node &lt;- data$predict3.node&quot;                                                                                                          
[133] &quot;  tree &lt;- tree3&quot;                                                                                                                                    
[134] &quot;} else {&quot;                                                                                                                                           
[135] &quot;  stop(\&quot;No matching depth found for assignment.\&quot;)&quot;                                                                                                
[136] &quot;}&quot;                                                                                                                                                  
[137] &quot;if(details){&quot;                                                                                                                                       
[138] &quot;cat(\&quot;tau, maxdepth=\&quot;,c(tau.rmst,maxdepth),\&quot;\\n\&quot;)&quot;                                                                                               
[139] &quot;temp &lt;- values[,c(\&quot;leaf.node\&quot;,\&quot;control\&quot;,\&quot;depth\&quot;)]&quot;                                                                                            
[140] &quot;print(round(temp,2))&quot;                                                                                                                               
[141] &quot;temp &lt;- max.diff[,c(\&quot;leaf.node\&quot;,\&quot;control\&quot;,\&quot;depth\&quot;)]&quot;                                                                                          
[142] &quot;print(round(temp,2))&quot;                                                                                                                               
[143] &quot;}&quot;                                                                                                                                                  
[144] &quot;harm.est &lt;- NULL&quot;                                                                                                                                   
[145] &quot;sg.harm.id &lt;- NULL&quot;                                                                                                                                 
[146] &quot;# Restricting to SG less than N&quot;                                                                                                                    
[147] &quot;# As GRF can identify ITT population as a&quot;                                                                                                          
[148] &quot;# \&quot;tree\&quot; meeting dmin criteria;&quot;                                                                                                                  
[149] &quot;# However, this is not a subgroup&quot;                                                                                                                  
[150] &quot;&quot;                                                                                                                                                   
[151] &quot;if(max.diff[,\&quot;diff\&quot;] &gt;= dmin.grf &amp;&amp; max.diff[,\&quot;Nsg\&quot;] &lt; n.max){&quot;                                                                                 
[152] &quot;harm.est&lt;-max.diff&quot;                                                                                                                                 
[153] &quot;data$treat.recommend &lt;- ifelse(data$predict.node == max.diff$leaf.node,0,1)&quot;                                                                        
[154] &quot;sg_node &lt;- c(max.diff$leaf.node)&quot;                                                                                                                   
[155] &quot;grf_names &lt;- tree$columns&quot;                                                                                                                          
[156] &quot;tnodes &lt;- tree$nodes&quot;                                                                                                                               
[157] &quot;# Find terminal leaf for identified subgroup&quot;                                                                                                       
[158] &quot;# Search though indices of tnodes&quot;                                                                                                                  
[159] &quot;sg_cov&lt;-NULL&quot;                                                                                                                                       
[160] &quot;sg_cut&lt;-NULL&quot;                                                                                                                                       
[161] &quot;for(tt in 1:length(tnodes)){&quot;                                                                                                                       
[162] &quot;  temp &lt;- tnodes[[tt]]&quot;                                                                                                                             
[163] &quot;  if(!temp$is_leaf){&quot;                                                                                                                               
[164] &quot;    if(temp$left_child == sg_node | temp$right_child == sg_node){&quot;                                                                                  
[165] &quot;      sg_cov &lt;- temp$split_variable&quot;                                                                                                                
[166] &quot;      sg_cut &lt;- temp$split_value&quot;                                                                                                                   
[167] &quot;    }&quot;                                                                                                                                              
[168] &quot;  }&quot;                                                                                                                                                
[169] &quot;}&quot;                                                                                                                                                  
[170] &quot;vmax &lt;- paste0(grf_names[sg_cov],\&quot; &lt;= \&quot;)&quot;                                                                                                         
[171] &quot;vmax &lt;- paste0(vmax,sg_cut,sep=\&quot;\&quot;)&quot;                                                                                                               
[172] &quot;&quot;                                                                                                                                                   
[173] &quot;# Find all cuts for selected tree&quot;                                                                                                                  
[174] &quot;Vsg_cuts &lt;- NULL&quot;                                                                                                                                   
[175] &quot;Vsg_names &lt;- NULL&quot;                                                                                                                                  
[176] &quot;for(tt in 1:length(tnodes)){&quot;                                                                                                                       
[177] &quot;  temp &lt;- tnodes[[tt]]&quot;                                                                                                                             
[178] &quot;  if(!temp$is_leaf){&quot;                                                                                                                               
[179] &quot;    sg_cov &lt;- temp$split_variable&quot;                                                                                                                  
[180] &quot;    sg_cut &lt;- round(temp$split_value,2)&quot;                                                                                                            
[181] &quot;    vcut &lt;- paste0(grf_names[sg_cov],\&quot; &lt;= \&quot;)&quot;                                                                                                     
[182] &quot;    vcut &lt;- paste0(vcut,sg_cut,sep=\&quot;\&quot;)&quot;                                                                                                           
[183] &quot;    Vsg_cuts &lt;- c(Vsg_cuts,vcut)&quot;                                                                                                                   
[184] &quot;    Vsg_names &lt;- c(Vsg_names,grf_names[sg_cov])&quot;                                                                                                    
[185] &quot;  }&quot;                                                                                                                                                
[186] &quot;}&quot;                                                                                                                                                  
[187] &quot;&quot;                                                                                                                                                   
[188] &quot;# Tree 1&quot;                                                                                                                                           
[189] &quot;grf_names &lt;- tree1$columns&quot;                                                                                                                         
[190] &quot;tnodes &lt;- tree1$nodes&quot;                                                                                                                              
[191] &quot;Vsg1_cuts &lt;- NULL&quot;                                                                                                                                  
[192] &quot;Vsg1_names &lt;- NULL&quot;                                                                                                                                 
[193] &quot;for(tt in 1:length(tnodes)){&quot;                                                                                                                       
[194] &quot;  temp &lt;- tnodes[[tt]]&quot;                                                                                                                             
[195] &quot;  if(!temp$is_leaf){&quot;                                                                                                                               
[196] &quot;    sg_cov &lt;- temp$split_variable&quot;                                                                                                                  
[197] &quot;    sg_cut &lt;- round(temp$split_value,2)&quot;                                                                                                            
[198] &quot;    vcut &lt;- paste0(grf_names[sg_cov],\&quot; &lt;= \&quot;)&quot;                                                                                                     
[199] &quot;    vcut &lt;- paste0(vcut,sg_cut,sep=\&quot;\&quot;)&quot;                                                                                                           
[200] &quot;    Vsg1_cuts &lt;- c(Vsg1_cuts,vcut)&quot;                                                                                                                 
[201] &quot;    Vsg1_names &lt;- c(Vsg1_names,grf_names[sg_cov])&quot;                                                                                                  
[202] &quot;  }&quot;                                                                                                                                                
[203] &quot;}&quot;                                                                                                                                                  
[204] &quot;&quot;                                                                                                                                                   
[205] &quot;# Trees 2 and 3 (depth &gt;= 2)&quot;                                                                                                                       
[206] &quot;if(maxdepth &gt;=2){&quot;                                                                                                                                  
[207] &quot;grf_names &lt;- tree2$columns&quot;                                                                                                                         
[208] &quot;tnodes &lt;- tree2$nodes&quot;                                                                                                                              
[209] &quot;Vsg2_cuts &lt;- NULL&quot;                                                                                                                                  
[210] &quot;Vsg2_names &lt;- NULL&quot;                                                                                                                                 
[211] &quot;for(tt in 1:length(tnodes)){&quot;                                                                                                                       
[212] &quot;  temp &lt;- tnodes[[tt]]&quot;                                                                                                                             
[213] &quot;  if(!temp$is_leaf){&quot;                                                                                                                               
[214] &quot;    sg_cov &lt;- temp$split_variable&quot;                                                                                                                  
[215] &quot;    sg_cut &lt;- round(temp$split_value,2)&quot;                                                                                                            
[216] &quot;    vcut &lt;- paste0(grf_names[sg_cov],\&quot; &lt;= \&quot;)&quot;                                                                                                     
[217] &quot;    vcut &lt;- paste0(vcut,sg_cut,sep=\&quot;\&quot;)&quot;                                                                                                           
[218] &quot;    Vsg2_cuts &lt;- c(Vsg2_cuts,vcut)&quot;                                                                                                                 
[219] &quot;    Vsg2_names &lt;- c(Vsg2_names,grf_names[sg_cov])&quot;                                                                                                  
[220] &quot;  }&quot;                                                                                                                                                
[221] &quot;}&quot;                                                                                                                                                  
[222] &quot;&quot;                                                                                                                                                   
[223] &quot;Vsg3_cuts &lt;- NULL&quot;                                                                                                                                  
[224] &quot;Vsg3_names &lt;- NULL&quot;                                                                                                                                 
[225] &quot;if(maxdepth == 3){&quot;                                                                                                                                 
[226] &quot;grf_names &lt;- tree3$columns&quot;                                                                                                                         
[227] &quot;tnodes &lt;- tree3$nodes&quot;                                                                                                                              
[228] &quot;for(tt in 1:length(tnodes)){&quot;                                                                                                                       
[229] &quot;  temp &lt;- tnodes[[tt]]&quot;                                                                                                                             
[230] &quot;  if(!temp$is_leaf){&quot;                                                                                                                               
[231] &quot;    sg_cov &lt;- temp$split_variable&quot;                                                                                                                  
[232] &quot;    sg_cut &lt;- round(temp$split_value,2)&quot;                                                                                                            
[233] &quot;    vcut &lt;- paste0(grf_names[sg_cov],\&quot; &lt;= \&quot;)&quot;                                                                                                     
[234] &quot;    vcut &lt;- paste0(vcut,sg_cut,sep=\&quot;\&quot;)&quot;                                                                                                           
[235] &quot;    Vsg3_cuts &lt;- c(Vsg3_cuts,vcut)&quot;                                                                                                                 
[236] &quot;    Vsg3_names &lt;- c(Vsg3_names,grf_names[sg_cov])&quot;                                                                                                  
[237] &quot;  }&quot;                                                                                                                                                
[238] &quot; }&quot;                                                                                                                                                 
[239] &quot;}&quot;                                                                                                                                                  
[240] &quot;}&quot;                                                                                                                                                  
[241] &quot;&quot;                                                                                                                                                   
[242] &quot;if(details &amp;&amp; max.diff[,\&quot;diff\&quot;] &gt;= dmin.grf &amp; max.diff[,\&quot;Nsg\&quot;] &lt; n.max){&quot;                                                                       
[243] &quot;cat(\&quot;GRF subgroup found\&quot;,\&quot;\\n\&quot;)&quot;                                                                                                                
[244] &quot;cat(\&quot;All splits\&quot;,\&quot;\\n\&quot;)&quot;                                                                                                                        
[245] &quot;print(Vsg_cuts,2)&quot;                                                                                                                                  
[246] &quot;cat(\&quot;Terminating node at max.diff (sg.harm.id)\&quot;,\&quot;\\n\&quot;)&quot;                                                                                         
[247] &quot;print(vmax)&quot;                                                                                                                                        
[248] &quot;}&quot;                                                                                                                                                  
[249] &quot;&quot;                                                                                                                                                   
[250] &quot;result &lt;- list(data=data,&quot;                                                                                                                          
[251] &quot;grf.gsub=harm.est,&quot;                                                                                                                                 
[252] &quot;sg.harm.id=vmax,&quot;                                                                                                                                   
[253] &quot;tree.cuts=Vsg_cuts,&quot;                                                                                                                                
[254] &quot;tree.names=unique(Vsg_names),&quot;                                                                                                                      
[255] &quot;tree1.cuts=Vsg1_cuts,&quot;                                                                                                                              
[256] &quot;tree1.names=unique(Vsg1_names),&quot;                                                                                                                    
[257] &quot;tree2.cuts=Vsg2_cuts,&quot;                                                                                                                              
[258] &quot;tree2.names=unique(Vsg2_names),&quot;                                                                                                                    
[259] &quot;tree3.cuts=Vsg3_cuts,&quot;                                                                                                                              
[260] &quot;tree3.names=unique(Vsg3_names),&quot;                                                                                                                    
[261] &quot;harm.any=values[which(values$diff&gt;0),],&quot;                                                                                                            
[262] &quot;tree=tree,tau.rmst=tau.rmst,tree1=tree1,tree2=tree2,tree3=tree3)&quot;                                                                                   
[263] &quot;}&quot;                                                                                                                                                  
[264] &quot;if(max.diff[,\&quot;diff\&quot;]&lt;dmin.grf | max.diff[,\&quot;Nsg\&quot;] &gt;= n.max){&quot;                                                                                    
[265] &quot;if(details){&quot;                                                                                                                                       
[266] &quot;cat(\&quot;GRF subgroup NOT found\&quot;,\&quot;\\n\&quot;)&quot;                                                                                                            
[267] &quot;}&quot;                                                                                                                                                  
[268] &quot;harm.any &lt;- NULL&quot;                                                                                                                                   
[269] &quot;cand.sgs &lt;- which(values$diff&gt;0)&quot;                                                                                                                   
[270] &quot;if(length(cand.sgs)&gt;0) harm.any&lt;-values[cand.sgs,]&quot;                                                                                                 
[271] &quot;result &lt;- list(data=data,grf.gsub=harm.est,sg.harm.id=sg.harm.id,harm.any=harm.any,tree=tree,tau.rmst=tau.rmst,dmin.grf=dmin.grf,&quot;                  
[272] &quot;frac.tau=frac.tau,maxdepth=maxdepth,n.min=n.min)&quot;                                                                                                   
[273] &quot;}&quot;                                                                                                                                                  
[274] &quot;return(result)&quot;                                                                                                                                     
[275] &quot;}&quot;                                                                                                                                                  
[276] &quot;&quot;                                                                                                                                                   
[277] &quot;#' GRF Subgroup Evaluation and Performance Metrics&quot;                                                                                                 
[278] &quot;#'&quot;                                                                                                                                                 
[279] &quot;#' Evaluates the performance of GRF-identified subgroups, including hazard ratios, bias, and predictive values.&quot;                                    
[280] &quot;#'&quot;                                                                                                                                                 
[281] &quot;#' @param df Data frame containing the analysis data.&quot;                                                                                              
[282] &quot;#' @param grf.est List. Output from \\code{grf.subg.harm.survival}.&quot;                                                                                
[283] &quot;#' @param dgm List. Data-generating mechanism (truth) for simulation.&quot;                                                                              
[284] &quot;#' @param cox.formula.sim Formula for unadjusted Cox model.&quot;                                                                                        
[285] &quot;#' @param cox.formula.adj.sim Formula for adjusted Cox model.&quot;                                                                                      
[286] &quot;#' @param analysis Character. Analysis label (default: \&quot;GRF\&quot;).&quot;                                                                                   
[287] &quot;#' @param frac.tau Numeric. Fraction of tau for GRF horizon (default: 1.0).&quot;                                                                        
[288] &quot;#'&quot;                                                                                                                                                 
[289] &quot;#' @return Data frame with performance metrics (hazard ratios, bias, PPV, NPV, etc.).&quot;                                                              
[290] &quot;#'&quot;                                                                                                                                                 
[291] &quot;#' @importFrom survival coxph Surv&quot;                                                                                                                 
[292] &quot;#' @export&quot;                                                                                                                                         
[293] &quot;&quot;                                                                                                                                                   
[294] &quot;grf.estimates.out &lt;- function(df,grf.est=NULL,dgm=NULL,cox.formula.sim=NULL,cox.formula.adj.sim=NULL,analysis=\&quot;GRF\&quot;,frac.tau=1.0){&quot;               
[295] &quot;  p.cens&lt;-mean(1-df[,event.name])&quot;                                                                                                                  
[296] &quot;&quot;                                                                                                                                                   
[297] &quot;  Y&lt;-df[,outcome.name]&quot;                                                                                                                             
[298] &quot;  W&lt;-df[,treat.name]&quot;                                                                                                                               
[299] &quot;  D&lt;-df[,event.name]&quot;                                                                                                                               
[300] &quot;  taumax &lt;- frac.tau * min(c(max(Y[W==1 &amp; D==1]),max(Y[W==0 &amp; D==1])))&quot;                                                                             
[301] &quot;&quot;                                                                                                                                                   
[302] &quot;  if(!is.null(grf.est)) sg.harm.grf&lt;-grf.est$sg.harm.id&quot;                                                                                            
[303] &quot;  if(is.null(grf.est)) sg.harm.grf&lt;-NULL&quot;                                                                                                           
[304] &quot;&quot;                                                                                                                                                   
[305] &quot;    fit &lt;- summary(coxph(cox.formula.sim,data=df,robust=FALSE))$conf.int&quot;                                                                           
[306] &quot;    hr.itt&lt;-c(fit[1])&quot;                                                                                                                              
[307] &quot;    l.itt&lt;-c(fit[3])&quot;                                                                                                                               
[308] &quot;    u.itt&lt;-c(fit[4])&quot;                                                                                                                               
[309] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[310] &quot;&quot;                                                                                                                                                   
[311] &quot;    fit &lt;- summary(coxph(cox.formula.adj.sim,data=df,robust=FALSE))$conf.int&quot;                                                                       
[312] &quot;    hr.adj.itt&lt;-c(fit[1,1])&quot;                                                                                                                        
[313] &quot;    l.adj.itt&lt;-c(fit[1,3])&quot;                                                                                                                         
[314] &quot;    u.adj.itt&lt;-c(fit[1,4])&quot;                                                                                                                         
[315] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[316] &quot;&quot;                                                                                                                                                   
[317] &quot;&quot;                                                                                                                                                   
[318] &quot;  if(dgm$model==\&quot;null\&quot; &amp; !is.null(dgm$grf.harm.true)) stop(\&quot;For dgm model null grf.harm.true should be null\&quot;)&quot;                                  
[319] &quot;&quot;                                                                                                                                                   
[320] &quot;  # dgm$grf.harm.true=NULL --&gt; H does not exist&quot;                                                                                                    
[321] &quot;&quot;                                                                                                                                                   
[322] &quot;  # If H exists and found something&quot;                                                                                                                
[323] &quot;  if(!is.null(dgm$grf.harm.true) &amp; !is.null(sg.harm.grf)){&quot;                                                                                         
[324] &quot;    any.H&lt;-1.0&quot;                                                                                                                                     
[325] &quot;    dfout&lt;-grf.est$data&quot;                                                                                                                            
[326] &quot;    # PPV for H membership: Hpred --&gt; treat.reccomend=0 &amp; flag.harm=1&quot;                                                                              
[327] &quot;    # Pred H and true H&quot;                                                                                                                            
[328] &quot;    aa&lt;-with(dfout,sum(treat.recommend==0 &amp; flag.harm==1))&quot;                                                                                         
[329] &quot;    # Pred Hc and true H&quot;                                                                                                                           
[330] &quot;    bb&lt;-with(dfout,sum(treat.recommend==1 &amp; flag.harm==1))&quot;                                                                                         
[331] &quot;    # Pred H and true Hc&quot;                                                                                                                           
[332] &quot;    cc&lt;-with(dfout,sum(treat.recommend==0 &amp; flag.harm==0))&quot;                                                                                         
[333] &quot;    # Pred Hc and true Hc&quot;                                                                                                                          
[334] &quot;    dd&lt;-with(dfout,sum(treat.recommend==1 &amp; flag.harm==0))&quot;                                                                                         
[335] &quot;&quot;                                                                                                                                                   
[336] &quot;    size.H&lt;-with(dfout,sum(treat.recommend==0))&quot;                                                                                                    
[337] &quot;    size.Hc&lt;-with(dfout,sum(treat.recommend==1))&quot;                                                                                                   
[338] &quot;&quot;                                                                                                                                                   
[339] &quot;&quot;                                                                                                                                                   
[340] &quot;    # hr estimate with true H&quot;                                                                                                                      
[341] &quot;    #hr.H.true&lt;-c(summary(coxph(cox.formula.sim,data=subset(df,flag.harm==1),robust=TRUE))$conf.int[1])&quot;                                            
[342] &quot;    #hr.Hc.true&lt;-c(summary(coxph(cox.formula.sim,data=subset(df,flag.harm==0),robust=TRUE))$conf.int[1])&quot;                                           
[343] &quot;&quot;                                                                                                                                                   
[344] &quot;    fit&lt;-summary(coxph(cox.formula.sim,data=subset(df,flag.harm==1),robust=FALSE))$conf.int&quot;                                                        
[345] &quot;    hr.H.true&lt;-c(fit[1])&quot;                                                                                                                           
[346] &quot;    l.H.true&lt;-c(fit[3])&quot;                                                                                                                            
[347] &quot;    u.H.true&lt;-c(fit[4])&quot;                                                                                                                            
[348] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[349] &quot;&quot;                                                                                                                                                   
[350] &quot;    fit&lt;-summary(coxph(cox.formula.sim,data=subset(df,flag.harm==0),robust=FALSE))$conf.int&quot;                                                        
[351] &quot;    hr.Hc.true&lt;-c(fit[1])&quot;                                                                                                                          
[352] &quot;    l.Hc.true&lt;-c(fit[3])&quot;                                                                                                                           
[353] &quot;    u.Hc.true&lt;-c(fit[4])&quot;                                                                                                                           
[354] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[355] &quot;&quot;                                                                                                                                                   
[356] &quot;&quot;                                                                                                                                                   
[357] &quot;    # hr estimate with estimated H&quot;                                                                                                                 
[358] &quot;    #hr.H.hat&lt;-c(summary(coxph(cox.formula.sim,data=subset(dfout,treat.recommend==0),robust=TRUE))$conf.int[1])&quot;                                    
[359] &quot;    #hr.Hc.hat&lt;-c(summary(coxph(cox.formula.sim,data=subset(dfout,treat.recommend==1),robust=TRUE))$conf.int[1])&quot;                                   
[360] &quot;&quot;                                                                                                                                                   
[361] &quot;    fit&lt;-summary(coxph(cox.formula.sim,data=subset(dfout,treat.recommend==0),robust=FALSE))$conf.int&quot;                                               
[362] &quot;    hr.H.hat&lt;-c(fit[1])&quot;                                                                                                                            
[363] &quot;    l.H.hat&lt;-c(fit[3])&quot;                                                                                                                             
[364] &quot;    u.H.hat&lt;-c(fit[4])&quot;                                                                                                                             
[365] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[366] &quot;&quot;                                                                                                                                                   
[367] &quot;    fit&lt;-summary(coxph(cox.formula.sim,data=subset(dfout,treat.recommend==1),robust=FALSE))$conf.int&quot;                                               
[368] &quot;    hr.Hc.hat&lt;-c(fit[1])&quot;                                                                                                                           
[369] &quot;    l.Hc.hat&lt;-c(fit[3])&quot;                                                                                                                            
[370] &quot;    u.Hc.hat&lt;-c(fit[4])&quot;                                                                                                                            
[371] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[372] &quot;&quot;                                                                                                                                                   
[373] &quot;&quot;                                                                                                                                                   
[374] &quot;    # Bias1 w.r.t hr.H.true&quot;                                                                                                                        
[375] &quot;    b1.H&lt;-c(hr.H.hat-hr.H.true)&quot;                                                                                                                    
[376] &quot;    b2.H&lt;-c(hr.H.hat-dgm$hr.H.true)&quot;                                                                                                                
[377] &quot;&quot;                                                                                                                                                   
[378] &quot;    b1.Hc&lt;-c(hr.Hc.hat-hr.Hc.true)&quot;                                                                                                                 
[379] &quot;    b2.Hc&lt;-c(hr.Hc.hat-dgm$hr.Hc.true)&quot;                                                                                                             
[380] &quot;&quot;                                                                                                                                                   
[381] &quot;    ppv&lt;-aa/(aa+bb)&quot;                                                                                                                                
[382] &quot;    npv&lt;-dd/(cc+dd)&quot;                                                                                                                                
[383] &quot;    specificity&lt;-dd/(bb+dd)&quot;                                                                                                                        
[384] &quot;    sensitivity&lt;-aa/(aa+cc)&quot;                                                                                                                        
[385] &quot;&quot;                                                                                                                                                   
[386] &quot;    #cat(\&quot;PPV and NPV=\&quot;,c(ppv,npv),\&quot;\\n\&quot;)&quot;                                                                                                      
[387] &quot;    #cat(\&quot;Sensitivity and Specificity=\&quot;,c(specificity,sensitivity),\&quot;\\n\&quot;)&quot;                                                                      
[388] &quot;&quot;                                                                                                                                                   
[389] &quot;    # Identify truth in dgm&quot;                                                                                                                        
[390] &quot;    #found.1&lt;-sum(grepl(dgm$grf.harm.true[1],sg.harm.grf))&quot;                                                                                         
[391] &quot;    #found.2&lt;-sum(grepl(dgm$grf.harm.true[2],sg.harm.grf))&quot;                                                                                         
[392] &quot;    #found.both&lt;-as.numeric(c(found.1+found.2)==2)&quot;                                                                                                 
[393] &quot;&quot;                                                                                                                                                   
[394] &quot;    found.1&lt;-found.2&lt;-found.both&lt;-NA&quot;                                                                                                               
[395] &quot;&quot;                                                                                                                                                   
[396] &quot;    #found.al3&lt;-as.numeric(length(sg.harm.grf)&gt;=3)&quot;                                                                                                 
[397] &quot;    found.al3&lt;-NA&quot;                                                                                                                                  
[398] &quot;  }&quot;                                                                                                                                                
[399] &quot;&quot;                                                                                                                                                   
[400] &quot;  # If H exists and did NOT find something&quot;                                                                                                         
[401] &quot;  if(!is.null(dgm$grf.harm.true) &amp; is.null(sg.harm.grf)){&quot;                                                                                          
[402] &quot;    any.H&lt;-0&quot;                                                                                                                                       
[403] &quot;    size.H&lt;-0&quot;                                                                                                                                      
[404] &quot;    size.Hc&lt;-nrow(df)&quot;                                                                                                                              
[405] &quot;&quot;                                                                                                                                                   
[406] &quot;    # hr estimate with true H&quot;                                                                                                                      
[407] &quot;    #hr.H.true&lt;-c(summary(coxph(cox.formula.sim,data=subset(df,flag.harm==1),robust=TRUE))$conf.int[1])&quot;                                            
[408] &quot;    #hr.Hc.true&lt;-c(summary(coxph(cox.formula.sim,data=subset(df,flag.harm==0),robust=TRUE))$conf.int[1])&quot;                                           
[409] &quot;&quot;                                                                                                                                                   
[410] &quot;    fit &lt;- summary(coxph(cox.formula.sim,data=subset(df,flag.harm==1),robust=FALSE))$conf.int&quot;                                                      
[411] &quot;    hr.H.true&lt;-c(fit[1])&quot;                                                                                                                           
[412] &quot;    l.H.true&lt;-c(fit[3])&quot;                                                                                                                            
[413] &quot;    u.H.true&lt;-c(fit[4])&quot;                                                                                                                            
[414] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[415] &quot;&quot;                                                                                                                                                   
[416] &quot;    fit &lt;- summary(coxph(cox.formula.sim,data=subset(df,flag.harm==0),robust=FALSE))$conf.int&quot;                                                      
[417] &quot;    hr.Hc.true&lt;-c(fit[1])&quot;                                                                                                                          
[418] &quot;    l.Hc.true&lt;-c(fit[3])&quot;                                                                                                                           
[419] &quot;    u.Hc.true&lt;-c(fit[4])&quot;                                                                                                                           
[420] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[421] &quot;&quot;                                                                                                                                                   
[422] &quot;&quot;                                                                                                                                                   
[423] &quot;    # hr estimate with estimated H, in this case, does not exist&quot;                                                                                   
[424] &quot;    #hr.H.hat&lt;-NA&quot;                                                                                                                                  
[425] &quot;    # Define HC as ITT&quot;                                                                                                                             
[426] &quot;    #hr.Hc.hat&lt;-c(summary(coxph(cox.formula.sim,data=df,robust=TRUE))$conf.int[1])&quot;                                                                 
[427] &quot;&quot;                                                                                                                                                   
[428] &quot;    # hr estimate with estimated H, in this case, does not exist&quot;                                                                                   
[429] &quot;    hr.H.hat&lt;-NA&quot;                                                                                                                                   
[430] &quot;    l.H.hat&lt;-NA&quot;                                                                                                                                    
[431] &quot;    u.H.hat&lt;-NA&quot;                                                                                                                                    
[432] &quot;&quot;                                                                                                                                                   
[433] &quot;    # Define HC as ITT&quot;                                                                                                                             
[434] &quot;    # hr.Hc.hat&lt;-c(summary(coxph(cox.formula.sim,data=df,robust=FALSE))$conf.int[1])&quot;                                                               
[435] &quot;&quot;                                                                                                                                                   
[436] &quot;    fit &lt;- summary(coxph(cox.formula.sim,data=df,robust=FALSE))$conf.int&quot;                                                                           
[437] &quot;    hr.Hc.hat&lt;-c(fit[1])&quot;                                                                                                                           
[438] &quot;    l.Hc.hat&lt;-c(fit[3])&quot;                                                                                                                            
[439] &quot;    u.Hc.hat&lt;-c(fit[4])&quot;                                                                                                                            
[440] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[441] &quot;&quot;                                                                                                                                                   
[442] &quot;&quot;                                                                                                                                                   
[443] &quot;&quot;                                                                                                                                                   
[444] &quot;    # Bias1 w.r.t hr.H.true&quot;                                                                                                                        
[445] &quot;    b1.H&lt;-NA&quot;                                                                                                                                       
[446] &quot;    b2.H&lt;-NA&quot;                                                                                                                                       
[447] &quot;&quot;                                                                                                                                                   
[448] &quot;    b1.Hc&lt;-c(hr.Hc.hat-hr.Hc.true)&quot;                                                                                                                 
[449] &quot;    b2.Hc&lt;-c(hr.Hc.hat-dgm$hr.Hc.true)&quot;                                                                                                             
[450] &quot;&quot;                                                                                                                                                   
[451] &quot;    # no H found, treat.recommend==1 for all&quot;                                                                                                       
[452] &quot;    # Pred H and true H&quot;                                                                                                                            
[453] &quot;    #aa&lt;-with(dfout,sum(treat.recommend==0 &amp; flag.harm==1))&quot;                                                                                        
[454] &quot;    # NO H found&quot;                                                                                                                                   
[455] &quot;    aa&lt;-0&quot;                                                                                                                                          
[456] &quot;    # Pred Hc and true H&quot;                                                                                                                           
[457] &quot;    #bb&lt;-with(dfout,sum(treat.recommend==1 &amp; flag.harm==1))&quot;                                                                                        
[458] &quot;    # All treat.recommend=1&quot;                                                                                                                        
[459] &quot;    bb&lt;-with(df,sum(flag.harm==1))&quot;                                                                                                                 
[460] &quot;    # Pred H and true Hc&quot;                                                                                                                           
[461] &quot;    #cc&lt;-with(dfout,sum(treat.recommend==0 &amp; flag.harm==0))&quot;                                                                                        
[462] &quot;    cc&lt;-0&quot;                                                                                                                                          
[463] &quot;    # Pred Hc and true Hc&quot;                                                                                                                          
[464] &quot;    #dd&lt;-with(dfout,sum(treat.recommend==1 &amp; flag.harm==0))&quot;                                                                                        
[465] &quot;    dd&lt;-with(df,sum(flag.harm==0))&quot;                                                                                                                 
[466] &quot;&quot;                                                                                                                                                   
[467] &quot;    ppv&lt;-aa/(aa+bb)&quot;                                                                                                                                
[468] &quot;    npv&lt;-dd/(cc+dd)&quot;                                                                                                                                
[469] &quot;    specificity&lt;-dd/(bb+dd)&quot;                                                                                                                        
[470] &quot;    sensitivity&lt;-ifelse(aa==0,0,aa/(aa+cc))&quot;                                                                                                        
[471] &quot;&quot;                                                                                                                                                   
[472] &quot;    # Identify truth in dgm&quot;                                                                                                                        
[473] &quot;    #found.1&lt;-0&quot;                                                                                                                                    
[474] &quot;    #found.2&lt;-0&quot;                                                                                                                                    
[475] &quot;    #found.both&lt;-0&quot;                                                                                                                                 
[476] &quot;&quot;                                                                                                                                                   
[477] &quot;    found.1&lt;-found.2&lt;-found.both&lt;-NA&quot;                                                                                                               
[478] &quot;&quot;                                                                                                                                                   
[479] &quot;&quot;                                                                                                                                                   
[480] &quot;    found.al3&lt;-0&quot;                                                                                                                                   
[481] &quot;&quot;                                                                                                                                                   
[482] &quot;  }&quot;                                                                                                                                                
[483] &quot;&quot;                                                                                                                                                   
[484] &quot;&quot;                                                                                                                                                   
[485] &quot;  # If H does NOT exist and found something&quot;                                                                                                        
[486] &quot;  if(is.null(dgm$grf.harm.true) &amp; !is.null(sg.harm.grf)){&quot;                                                                                          
[487] &quot;    any.H&lt;-1.0&quot;                                                                                                                                     
[488] &quot;    dfout&lt;-grf.est$data&quot;                                                                                                                            
[489] &quot;    # PPV for H membership: Hpred --&gt; treat.reccomend=0 &amp; flag.harm=1&quot;                                                                              
[490] &quot;    # Pred H and true H&quot;                                                                                                                            
[491] &quot;    #aa&lt;-with(dfout,sum(treat.recommend==0 &amp; flag.harm==1))&quot;                                                                                        
[492] &quot;    # flag.harm=0 for all&quot;                                                                                                                          
[493] &quot;    aa&lt;-0&quot;                                                                                                                                          
[494] &quot;    # Pred Hc and true H&quot;                                                                                                                           
[495] &quot;    #bb&lt;-with(dfout,sum(treat.recommend==1 &amp; flag.harm==1))&quot;                                                                                        
[496] &quot;    bb&lt;-0&quot;                                                                                                                                          
[497] &quot;    # Pred H and true Hc&quot;                                                                                                                           
[498] &quot;    #cc&lt;-with(dfout,sum(treat.recommend==0 &amp; flag.harm==0))&quot;                                                                                        
[499] &quot;    cc&lt;-with(dfout,sum(treat.recommend==0))&quot;                                                                                                        
[500] &quot;    # Pred Hc and true Hc&quot;                                                                                                                          
[501] &quot;    #dd&lt;-with(dfout,sum(treat.recommend==1 &amp; flag.harm==0))&quot;                                                                                        
[502] &quot;    dd&lt;-with(dfout,sum(treat.recommend==1))&quot;                                                                                                        
[503] &quot;&quot;                                                                                                                                                   
[504] &quot;    size.H&lt;-with(dfout,sum(treat.recommend==0))&quot;                                                                                                    
[505] &quot;    size.Hc&lt;-with(dfout,sum(treat.recommend==1))&quot;                                                                                                   
[506] &quot;&quot;                                                                                                                                                   
[507] &quot;    # hr estimate with true H&quot;                                                                                                                      
[508] &quot;    #hr.H.true&lt;-NA&quot;                                                                                                                                 
[509] &quot;    # ITT&quot;                                                                                                                                          
[510] &quot;    #hr.Hc.true&lt;-c(summary(coxph(cox.formula.sim,data=df,robust=TRUE))$conf.int[1])&quot;                                                                
[511] &quot;&quot;                                                                                                                                                   
[512] &quot;    # hr estimate with true H&quot;                                                                                                                      
[513] &quot;    hr.H.true&lt;-NA&quot;                                                                                                                                  
[514] &quot;    l.H.true&lt;-NA&quot;                                                                                                                                   
[515] &quot;    u.H.true&lt;-NA&quot;                                                                                                                                   
[516] &quot;&quot;                                                                                                                                                   
[517] &quot;    # no H --&gt; ITT&quot;                                                                                                                                 
[518] &quot;    fit &lt;- summary(coxph(cox.formula.sim,data=df,robust=FALSE))$conf.int&quot;                                                                           
[519] &quot;    hr.Hc.true&lt;-c(fit[1])&quot;                                                                                                                          
[520] &quot;    l.Hc.true&lt;-c(fit[3])&quot;                                                                                                                           
[521] &quot;    u.Hc.true&lt;-c(fit[4])&quot;                                                                                                                           
[522] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[523] &quot;&quot;                                                                                                                                                   
[524] &quot;&quot;                                                                                                                                                   
[525] &quot;    # hr estimate with estimated H&quot;                                                                                                                 
[526] &quot;    #hr.H.hat&lt;-c(summary(coxph(cox.formula.sim,data=subset(dfout,treat.recommend==0),robust=TRUE))$conf.int[1])&quot;                                    
[527] &quot;    #hr.Hc.hat&lt;-c(summary(coxph(cox.formula.sim,data=subset(dfout,treat.recommend==1),robust=TRUE))$conf.int[1])&quot;                                   
[528] &quot;&quot;                                                                                                                                                   
[529] &quot;    # hr estimate with estimated H&quot;                                                                                                                 
[530] &quot;    fit &lt;- summary(coxph(cox.formula.sim,data=subset(dfout,treat.recommend==0),robust=FALSE))$conf.int&quot;                                             
[531] &quot;    hr.H.hat&lt;-c(fit[1])&quot;                                                                                                                            
[532] &quot;    l.H.hat&lt;-c(fit[3])&quot;                                                                                                                             
[533] &quot;    u.H.hat&lt;-c(fit[4])&quot;                                                                                                                             
[534] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[535] &quot;&quot;                                                                                                                                                   
[536] &quot;    fit &lt;- summary(coxph(cox.formula.sim,data=subset(dfout,treat.recommend==1),robust=FALSE))$conf.int&quot;                                             
[537] &quot;    hr.Hc.hat&lt;-c(fit[1])&quot;                                                                                                                           
[538] &quot;    l.Hc.hat&lt;-c(fit[3])&quot;                                                                                                                            
[539] &quot;    u.Hc.hat&lt;-c(fit[4])&quot;                                                                                                                            
[540] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[541] &quot;&quot;                                                                                                                                                   
[542] &quot;    # Bias1 w.r.t hr.H.true&quot;                                                                                                                        
[543] &quot;    b1.H&lt;-NA&quot;                                                                                                                                       
[544] &quot;    b2.H&lt;-NA&quot;                                                                                                                                       
[545] &quot;&quot;                                                                                                                                                   
[546] &quot;    b1.Hc&lt;-c(hr.Hc.hat-hr.Hc.true)&quot;                                                                                                                 
[547] &quot;    b2.Hc&lt;-c(hr.Hc.hat-dgm$hr.Hc.true)&quot;                                                                                                             
[548] &quot;&quot;                                                                                                                                                   
[549] &quot;    ppv&lt;-NA&quot;                                                                                                                                        
[550] &quot;    npv&lt;-dd/(cc+dd)&quot;                                                                                                                                
[551] &quot;    specificity&lt;-dd/(bb+dd)&quot;                                                                                                                        
[552] &quot;    sensitivity&lt;-aa/(aa+cc)&quot;                                                                                                                        
[553] &quot;&quot;                                                                                                                                                   
[554] &quot;    # Identify truth in dgm&quot;                                                                                                                        
[555] &quot;    # fs.harm.true will be null&quot;                                                                                                                    
[556] &quot;    # Still want to track how often v1.1 and v4.1 are found&quot;                                                                                        
[557] &quot;    #found.1&lt;-sum(grepl(c(\&quot;v1=1\&quot;),sg.harm.grf))&quot;                                                                                                  
[558] &quot;    #found.2&lt;-sum(grepl(c(\&quot;v4=1\&quot;),sg.harm.grf))&quot;                                                                                                  
[559] &quot;    #found.both&lt;-as.numeric(c(found.1+found.2)==2)&quot;                                                                                                 
[560] &quot;&quot;                                                                                                                                                   
[561] &quot;    found.1&lt;-found.2&lt;-found.both&lt;-NA&quot;                                                                                                               
[562] &quot;&quot;                                                                                                                                                   
[563] &quot;    #found.al3&lt;-as.numeric(length(sg.harm.grf)&gt;=3)&quot;                                                                                                 
[564] &quot;    found.al3&lt;-NA&quot;                                                                                                                                  
[565] &quot;    }&quot;                                                                                                                                              
[566] &quot;&quot;                                                                                                                                                   
[567] &quot;  # If H does NOT exist and did NOT find something&quot;                                                                                                 
[568] &quot;  # Define hat(Hc)=ITT&quot;                                                                                                                             
[569] &quot;  if(is.null(dgm$grf.harm.true) &amp; is.null(sg.harm.grf)){&quot;                                                                                           
[570] &quot;    any.H&lt;-0&quot;                                                                                                                                       
[571] &quot;    # **flag.harm=0 for all**&quot;                                                                                                                      
[572] &quot;    # Pred H and true H&quot;                                                                                                                            
[573] &quot;    #aa&lt;-with(dfout,sum(treat.recommend==0 &amp; flag.harm==1))&quot;                                                                                        
[574] &quot;    # flag.harm=0 for all&quot;                                                                                                                          
[575] &quot;    aa&lt;-0&quot;                                                                                                                                          
[576] &quot;    # Pred Hc and true H&quot;                                                                                                                           
[577] &quot;    #bb&lt;-with(dfout,sum(treat.recommend==1 &amp; flag.harm==1))&quot;                                                                                        
[578] &quot;    bb&lt;-0&quot;                                                                                                                                          
[579] &quot;    # Pred H and true Hc&quot;                                                                                                                           
[580] &quot;    #cc&lt;-with(dfout,sum(treat.recommend==0 &amp; flag.harm==0))&quot;                                                                                        
[581] &quot;    cc&lt;-0&quot;                                                                                                                                          
[582] &quot;    # Pred Hc and true Hc&quot;                                                                                                                          
[583] &quot;    #dd&lt;-with(dfout,sum(treat.recommend==1 &amp; flag.harm==0))&quot;                                                                                        
[584] &quot;    # Did NOT find anything --&gt; treat.recommend=1 for all&quot;                                                                                          
[585] &quot;    dd&lt;-nrow(df)&quot;                                                                                                                                   
[586] &quot;&quot;                                                                                                                                                   
[587] &quot;    size.H&lt;-0&quot;                                                                                                                                      
[588] &quot;    size.Hc&lt;-nrow(df)&quot;                                                                                                                              
[589] &quot;&quot;                                                                                                                                                   
[590] &quot;    # hr estimate with true H&quot;                                                                                                                      
[591] &quot;    #hr.H.true&lt;-NA&quot;                                                                                                                                 
[592] &quot;    # ITT&quot;                                                                                                                                          
[593] &quot;    #hr.Hc.true&lt;-c(summary(coxph(cox.formula.sim,data=df,robust=TRUE))$conf.int[1])&quot;                                                                
[594] &quot;&quot;                                                                                                                                                   
[595] &quot;    # hr estimate with true H&quot;                                                                                                                      
[596] &quot;    hr.H.true&lt;-NA&quot;                                                                                                                                  
[597] &quot;    l.H.true&lt;-NA&quot;                                                                                                                                   
[598] &quot;    u.H.true&lt;-NA&quot;                                                                                                                                   
[599] &quot;&quot;                                                                                                                                                   
[600] &quot;    # ITT&quot;                                                                                                                                          
[601] &quot;    fit &lt;- summary(coxph(cox.formula.sim,data=df,robust=FALSE))$conf.int&quot;                                                                           
[602] &quot;    hr.Hc.true&lt;-c(fit[1])&quot;                                                                                                                          
[603] &quot;    l.Hc.true&lt;-c(fit[3])&quot;                                                                                                                           
[604] &quot;    u.Hc.true&lt;-c(fit[4])&quot;                                                                                                                           
[605] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[606] &quot;&quot;                                                                                                                                                   
[607] &quot;&quot;                                                                                                                                                   
[608] &quot;    # hr estimate with estimated H&quot;                                                                                                                 
[609] &quot;    #hr.H.hat&lt;-NA&quot;                                                                                                                                  
[610] &quot;    #hr.Hc.hat&lt;-c(summary(coxph(cox.formula.sim,data=df,robust=TRUE))$conf.int[1])&quot;                                                                 
[611] &quot;&quot;                                                                                                                                                   
[612] &quot;    # hr estimate with estimated H&quot;                                                                                                                 
[613] &quot;    hr.H.hat&lt;-NA&quot;                                                                                                                                   
[614] &quot;    l.H.hat&lt;-NA&quot;                                                                                                                                    
[615] &quot;    u.H.hat&lt;-NA&quot;                                                                                                                                    
[616] &quot;&quot;                                                                                                                                                   
[617] &quot;    #hr.Hc.hat&lt;-c(summary(coxph(cox.formula.sim,data=df,robust=FALSE))$conf.int[1])&quot;                                                                
[618] &quot;    fit &lt;- summary(coxph(cox.formula.sim,data=df,robust=FALSE))$conf.int&quot;                                                                           
[619] &quot;    hr.Hc.hat&lt;-c(fit[1])&quot;                                                                                                                           
[620] &quot;    l.Hc.hat&lt;-c(fit[3])&quot;                                                                                                                            
[621] &quot;    u.Hc.hat&lt;-c(fit[4])&quot;                                                                                                                            
[622] &quot;    rm(\&quot;fit\&quot;)&quot;                                                                                                                                    
[623] &quot;&quot;                                                                                                                                                   
[624] &quot;&quot;                                                                                                                                                   
[625] &quot;    # Bias1 w.r.t hr.H.true&quot;                                                                                                                        
[626] &quot;    b1.H&lt;-NA&quot;                                                                                                                                       
[627] &quot;    b2.H&lt;-NA&quot;                                                                                                                                       
[628] &quot;&quot;                                                                                                                                                   
[629] &quot;    b1.Hc&lt;-c(hr.Hc.hat-hr.Hc.true)&quot;                                                                                                                 
[630] &quot;    b2.Hc&lt;-c(hr.Hc.hat-dgm$hr.Hc.true)&quot;                                                                                                             
[631] &quot;&quot;                                                                                                                                                   
[632] &quot;    ppv&lt;-NA&quot;                                                                                                                                        
[633] &quot;    npv&lt;-dd/(cc+dd)&quot;                                                                                                                                
[634] &quot;    specificity&lt;-dd/(bb+dd)&quot;                                                                                                                        
[635] &quot;    sensitivity&lt;-NA&quot;                                                                                                                                
[636] &quot;&quot;                                                                                                                                                   
[637] &quot;    # Identify truth in dgm&quot;                                                                                                                        
[638] &quot;    # fs.harm.true will be null&quot;                                                                                                                    
[639] &quot;    # Still want to track how often v1.1 and v4.1 are found&quot;                                                                                        
[640] &quot;&quot;                                                                                                                                                   
[641] &quot;    # I don't think these are correct&quot;                                                                                                              
[642] &quot;    #found.1&lt;-sum(grepl(c(\&quot;v1=1\&quot;),sg.harm.grf))&quot;                                                                                                  
[643] &quot;    #found.2&lt;-sum(grepl(c(\&quot;v4=1\&quot;),sg.harm.grf))&quot;                                                                                                  
[644] &quot;    #found.both&lt;-as.numeric(c(found.1+found.2)==2)&quot;                                                                                                 
[645] &quot;    found.1&lt;-found.2&lt;-found.both&lt;-NA&quot;                                                                                                               
[646] &quot;    #found.al3&lt;-as.numeric(length(sg.harm.grf)&gt;=3)&quot;                                                                                                 
[647] &quot;    found.al3&lt;-NA&quot;                                                                                                                                  
[648] &quot;  }&quot;                                                                                                                                                
[649] &quot;&quot;                                                                                                                                                   
[650] &quot;  df.res &lt;- data.frame(any.H,size.H,size.Hc,ppv,npv,specificity,sensitivity,found.1,found.2,found.both,found.al3,hr.H.true,&quot;                        
[651] &quot;                     hr.Hc.true,hr.H.hat,hr.Hc.hat,b1.H,b2.H,b1.Hc,b2.Hc,p.cens,analysis,taumax,hr.itt,l.itt,u.itt,&quot;                                
[652] &quot;                     hr.adj.itt,l.adj.itt,u.adj.itt,&quot;                                                                                               
[653] &quot;                     l.H.true,u.H.true,&quot;                                                                                                            
[654] &quot;                     l.Hc.true,u.Hc.true,&quot;                                                                                                          
[655] &quot;                     l.H.hat,u.H.hat,&quot;                                                                                                              
[656] &quot;                     l.Hc.hat,u.Hc.hat)&quot;                                                                                                            
[657] &quot;  return(df.res)&quot;                                                                                                                                   
[658] &quot;}&quot;                                                                                                                                                  
[659] &quot;&quot;                                                                                                                                                   
[660] &quot;&quot;                                                                                                                                                   

$summary_utility_functions
  [1] &quot;#' Format Hazard Ratio and Confidence Interval&quot;                                                                                                                
  [2] &quot;#'&quot;                                                                                                                                                            
  [3] &quot;#' Formats a hazard ratio and confidence interval for display.&quot;                                                                                                
  [4] &quot;#'&quot;                                                                                                                                                            
  [5] &quot;#' @param hrest Numeric vector with HR, lower, and upper confidence limits.&quot;                                                                                   
  [6] &quot;#' @return Character string formatted as \\\&quot;HR (lower, upper)\\\&quot;.&quot;                                                                                           
  [7] &quot;#' @export&quot;                                                                                                                                                    
  [8] &quot;&quot;                                                                                                                                                              
  [9] &quot;hrCI_format &lt;- function(hrest) {&quot;                                                                                                                              
 [10] &quot;  # hrest: vector with HR, lower, upper&quot;                                                                                                                       
 [11] &quot;  sprintf(\&quot;%.2f (%.2f, %.2f)\&quot;, hrest[1], hrest[2], hrest[3])&quot;                                                                                                
 [12] &quot;}&quot;                                                                                                                                                             
 [13] &quot;&quot;                                                                                                                                                              
 [14] &quot;#' Calculate n and percent&quot;                                                                                                                                    
 [15] &quot;#'&quot;                                                                                                                                                            
 [16] &quot;#' Returns count and percent for a vector relative to a denominator.&quot;                                                                                          
 [17] &quot;#'&quot;                                                                                                                                                            
 [18] &quot;#' @param x Vector of values.&quot;                                                                                                                                 
 [19] &quot;#' @param denom Denominator for percent calculation.&quot;                                                                                                          
 [20] &quot;#' @return Character string formatted as \\\&quot;n (percent%)\\\&quot;.&quot;                                                                                                
 [21] &quot;#' @export&quot;                                                                                                                                                    
 [22] &quot;&quot;                                                                                                                                                              
 [23] &quot;n_pcnt &lt;- function(x, denom) {&quot;                                                                                                                                
 [24] &quot;  n &lt;- length(x)&quot;                                                                                                                                              
 [25] &quot;  sprintf(\&quot;%d (%.1f%%)\&quot;, n, 100 * n / denom)&quot;                                                                                                                
 [26] &quot;}&quot;                                                                                                                                                             
 [27] &quot;&quot;                                                                                                                                                              
 [28] &quot;#' Prepare subgroup data for analysis&quot;                                                                                                                         
 [29] &quot;#'&quot;                                                                                                                                                            
 [30] &quot;#' Splits a data frame into two subgroups based on a flag and treatment scale.&quot;                                                                                
 [31] &quot;#'&quot;                                                                                                                                                            
 [32] &quot;#' @param df Data frame.&quot;                                                                                                                                      
 [33] &quot;#' @param SG_flag Character. Name of subgroup flag variable.&quot;                                                                                                  
 [34] &quot;#' @param est.scale Character. Effect scale (\&quot;hr\&quot; or \&quot;1/hr\&quot;).&quot;                                                                                             
 [35] &quot;#' @param treat.name Character. Name of treatment variable.&quot;                                                                                                   
 [36] &quot;#' @return List with subgroup data frames and treatment variable name.&quot;                                                                                        
 [37] &quot;#' @export&quot;                                                                                                                                                    
 [38] &quot;&quot;                                                                                                                                                              
 [39] &quot;prepare_subgroup_data &lt;- function(df, SG_flag, est.scale, treat.name) {&quot;                                                                                       
 [40] &quot;  if (est.scale == \&quot;1/hr\&quot;) {&quot;                                                                                                                                
 [41] &quot;    df$treat2 &lt;- 1 - df[, treat.name]&quot;                                                                                                                         
 [42] &quot;    treat.name &lt;- \&quot;treat2\&quot;&quot;                                                                                                                                  
 [43] &quot;  }&quot;                                                                                                                                                           
 [44] &quot;  df_0 &lt;- subset(df, df[, SG_flag] == 0)&quot;                                                                                                                      
 [45] &quot;  df_1 &lt;- subset(df, df[, SG_flag] == 1)&quot;                                                                                                                      
 [46] &quot;  list(df_0 = df_0, df_1 = df_1, treat.name = treat.name)&quot;                                                                                                     
 [47] &quot;}&quot;                                                                                                                                                             
 [48] &quot;&quot;                                                                                                                                                              
 [49] &quot;#' Cox model summary for subgroup&quot;                                                                                                                             
 [50] &quot;#'&quot;                                                                                                                                                            
 [51] &quot;#' Calculates hazard ratio and confidence interval for a subgroup using Cox regression.&quot;                                                                       
 [52] &quot;#'&quot;                                                                                                                                                            
 [53] &quot;#' @param Y Numeric vector of outcome.&quot;                                                                                                                        
 [54] &quot;#' @param E Numeric vector of event indicators.&quot;                                                                                                               
 [55] &quot;#' @param Treat Numeric vector of treatment indicators.&quot;                                                                                                       
 [56] &quot;#' @param Strata Vector of strata (optional).&quot;                                                                                                                 
 [57] &quot;#' @return Character string with formatted HR and CI.&quot;                                                                                                         
 [58] &quot;#' @importFrom survival coxph Surv&quot;                                                                                                                            
 [59] &quot;#' @export&quot;                                                                                                                                                    
 [60] &quot;&quot;                                                                                                                                                              
 [61] &quot;cox_summary &lt;- function(Y, E, Treat, Strata) {&quot;                                                                                                                
 [62] &quot;  fit &lt;- survival::coxph(survival::Surv(Y, E) ~ Treat + strata(Strata), robust = TRUE)&quot;                                                                        
 [63] &quot;  hr &lt;- summary(fit)$conf.int[c(1, 3, 4)]&quot;                                                                                                                     
 [64] &quot;  hrCI_format(hr)&quot;                                                                                                                                             
 [65] &quot;}&quot;                                                                                                                                                             
 [66] &quot;&quot;                                                                                                                                                              
 [67] &quot;#' KM median summary for subgroup&quot;                                                                                                                             
 [68] &quot;#'&quot;                                                                                                                                                            
 [69] &quot;#' Calculates median survival for each treatment group using Kaplan-Meier.&quot;                                                                                    
 [70] &quot;#'&quot;                                                                                                                                                            
 [71] &quot;#' @param Y Numeric vector of outcome.&quot;                                                                                                                        
 [72] &quot;#' @param E Numeric vector of event indicators.&quot;                                                                                                               
 [73] &quot;#' @param Treat Numeric vector of treatment indicators.&quot;                                                                                                       
 [74] &quot;#' @return Numeric vector of medians.&quot;                                                                                                                         
 [75] &quot;#' @importFrom survival survfit&quot;                                                                                                                               
 [76] &quot;#' @export&quot;                                                                                                                                                    
 [77] &quot;&quot;                                                                                                                                                              
 [78] &quot;km_summary &lt;- function(Y, E, Treat) {&quot;                                                                                                                         
 [79] &quot;  fit &lt;- summary(survival::survfit(survival::Surv(Y, E) ~ Treat))&quot;                                                                                             
 [80] &quot;  as.numeric(round(fit$table[, \&quot;median\&quot;], 1))&quot;                                                                                                               
 [81] &quot;}&quot;                                                                                                                                                             
 [82] &quot;&quot;                                                                                                                                                              
 [83] &quot;#' Calculate counts for subgroup summary&quot;                                                                                                                      
 [84] &quot;#'&quot;                                                                                                                                                            
 [85] &quot;#' Calculates sample size, treated count, and event count for a subgroup.&quot;                                                                                     
 [86] &quot;#'&quot;                                                                                                                                                            
 [87] &quot;#' @param Y Numeric vector of outcome.&quot;                                                                                                                        
 [88] &quot;#' @param E Numeric vector of event indicators.&quot;                                                                                                               
 [89] &quot;#' @param Treat Numeric vector of treatment indicators.&quot;                                                                                                       
 [90] &quot;#' @param N Integer. Total sample size.&quot;                                                                                                                       
 [91] &quot;#' @return List with formatted counts.&quot;                                                                                                                        
 [92] &quot;#' @export&quot;                                                                                                                                                    
 [93] &quot;&quot;                                                                                                                                                              
 [94] &quot;calculate_counts &lt;- function(Y, E, Treat, N) {&quot;                                                                                                                
 [95] &quot;  n &lt;- n_pcnt(Y, N)&quot;                                                                                                                                           
 [96] &quot;  n_treat &lt;- n_pcnt(Y[Treat == 1], length(Y))&quot;                                                                                                                 
 [97] &quot;  d &lt;- n_pcnt(Y[E == 1], length(Y))&quot;                                                                                                                           
 [98] &quot;  list(n = n, n_treat = n_treat, d = d)&quot;                                                                                                                       
 [99] &quot;}&quot;                                                                                                                                                             
[100] &quot;&quot;                                                                                                                                                              
[101] &quot;#' Calculate potential outcome hazard ratio&quot;                                                                                                                   
[102] &quot;#'&quot;                                                                                                                                                            
[103] &quot;#' Calculates the average hazard ratio from a potential outcome variable.&quot;                                                                                     
[104] &quot;#'&quot;                                                                                                                                                            
[105] &quot;#' @param df Data frame.&quot;                                                                                                                                      
[106] &quot;#' @param potentialOutcome.name Character. Name of potential outcome variable.&quot;                                                                                
[107] &quot;#' @return Numeric value of average hazard ratio.&quot;                                                                                                             
[108] &quot;#' @export&quot;                                                                                                                                                    
[109] &quot;&quot;                                                                                                                                                              
[110] &quot;calculate_potential_hr &lt;- function(df, potentialOutcome.name) {&quot;                                                                                               
[111] &quot;  loghr.po &lt;- df[, potentialOutcome.name]&quot;                                                                                                                     
[112] &quot;  round(exp(mean(loghr.po)), 2)&quot;                                                                                                                               
[113] &quot;}&quot;                                                                                                                                                             
[114] &quot;&quot;                                                                                                                                                              
[115] &quot;#' Format results for subgroup summary&quot;                                                                                                                        
[116] &quot;#'&quot;                                                                                                                                                            
[117] &quot;#' Formats results for subgroup summary table.&quot;                                                                                                                
[118] &quot;#'&quot;                                                                                                                                                            
[119] &quot;#' @param subgroup_name Character. Subgroup name.&quot;                                                                                                             
[120] &quot;#' @param n Character. Sample size.&quot;                                                                                                                           
[121] &quot;#' @param n_treat Character. Treated count.&quot;                                                                                                                   
[122] &quot;#' @param d Character. Event count.&quot;                                                                                                                           
[123] &quot;#' @param m1 Numeric. Median or RMST for treatment.&quot;                                                                                                           
[124] &quot;#' @param m0 Numeric. Median or RMST for control.&quot;                                                                                                             
[125] &quot;#' @param drmst Numeric. RMST difference.&quot;                                                                                                                     
[126] &quot;#' @param hr Character. Hazard ratio (formatted).&quot;                                                                                                             
[127] &quot;#' @param hr_a Character. Adjusted hazard ratio (optional).&quot;                                                                                                   
[128] &quot;#' @param hr_po Numeric. Potential outcome hazard ratio (optional).&quot;                                                                                           
[129] &quot;#' @param return_medians Logical. Use medians or RMST.&quot;                                                                                                        
[130] &quot;#' @return Character vector of results.&quot;                                                                                                                       
[131] &quot;#' @export&quot;                                                                                                                                                    
[132] &quot;&quot;                                                                                                                                                              
[133] &quot;format_results &lt;- function(subgroup_name, n, n_treat, d, m1, m0, drmst, hr, hr_a = NA, hr_po = NA, return_medians = TRUE) {&quot;                                   
[134] &quot;  if (is.na(hr_po)) {&quot;                                                                                                                                         
[135] &quot;    if (is.na(hr_a)) {&quot;                                                                                                                                        
[136] &quot;      res &lt;- c(subgroup_name, n, n_treat, d, m1, m0, drmst, hr)&quot;                                                                                               
[137] &quot;    } else {&quot;                                                                                                                                                  
[138] &quot;      res &lt;- c(subgroup_name, n, n_treat, d, m1, m0, drmst, hr, hr_a)&quot;                                                                                         
[139] &quot;    }&quot;                                                                                                                                                         
[140] &quot;  } else {&quot;                                                                                                                                                    
[141] &quot;    if (is.na(hr_a)) {&quot;                                                                                                                                        
[142] &quot;      res &lt;- c(subgroup_name, n, n_treat, d, m1, m0, drmst, hr, hr_po)&quot;                                                                                        
[143] &quot;    } else {&quot;                                                                                                                                                  
[144] &quot;      res &lt;- c(subgroup_name, n, n_treat, d, m1, m0, drmst, hr, hr_a, hr_po)&quot;                                                                                  
[145] &quot;    }&quot;                                                                                                                                                         
[146] &quot;  }&quot;                                                                                                                                                           
[147] &quot;  res&quot;                                                                                                                                                         
[148] &quot;}&quot;                                                                                                                                                             
[149] &quot;&quot;                                                                                                                                                              
[150] &quot;#' RMST calculation for subgroup&quot;                                                                                                                              
[151] &quot;#'&quot;                                                                                                                                                            
[152] &quot;#' Calculates restricted mean survival time (RMST) for a subgroup.&quot;                                                                                            
[153] &quot;#'&quot;                                                                                                                                                            
[154] &quot;#' @param df Data frame.&quot;                                                                                                                                      
[155] &quot;#' @param tte.name Character. Name of time-to-event variable.&quot;                                                                                                 
[156] &quot;#' @param event.name Character. Name of event indicator variable.&quot;                                                                                             
[157] &quot;#' @param treat.name Character. Name of treatment variable.&quot;                                                                                                   
[158] &quot;#' @return List with tau, RMST, RMST for treatment, RMST for control.&quot;                                                                                         
[159] &quot;#' @importFrom weightedSurv df_counting&quot;                                                                                                                       
[160] &quot;#' @export&quot;                                                                                                                                                    
[161] &quot;&quot;                                                                                                                                                              
[162] &quot;rmst_calculation &lt;- function(df,tte.name = \&quot;tte\&quot;,event.name = \&quot;event\&quot;,treat.name = \&quot;treat\&quot;){&quot;                                                            
[163] &quot;  if (!requireNamespace(\&quot;weightedSurv\&quot;, quietly = TRUE)) {&quot;                                                                                                  
[164] &quot;    stop(\&quot;Package 'weightedSurv' needed for this function to work. Please install it install_github('larry-leon/weightedSurv').\&quot;)&quot;                           
[165] &quot;  }&quot;                                                                                                                                                           
[166] &quot;  dfcount &lt;- df_counting(df, tte.name = tte.name, event.name = event.name, treat.name = treat.name, arms = c(\&quot;treat\&quot;,\&quot;control\&quot;), by.risk = 1)&quot;             
[167] &quot;  taumax &lt;- with(dfcount, max(at_points[ybar1 &gt; 0 &amp; ybar0 &gt;0]))&quot;                                                                                               
[168] &quot;  at_points &lt;- dfcount$at_points&quot;                                                                                                                              
[169] &quot;  tau_horizon &lt;- which(at_points &lt;= taumax)&quot;                                                                                                                   
[170] &quot;  surv1 &lt;- dfcount$surv1&quot;                                                                                                                                      
[171] &quot;  surv0 &lt;- dfcount$surv0&quot;                                                                                                                                      
[172] &quot;  dhat &lt;- c(surv1 - surv0)&quot;                                                                                                                                    
[173] &quot;  tpoints &lt;- at_points[tau_horizon]&quot;                                                                                                                           
[174] &quot;  dhat &lt;- dhat[tau_horizon]&quot;                                                                                                                                   
[175] &quot;  surv1 &lt;- surv1[tau_horizon]&quot;                                                                                                                                 
[176] &quot;  surv0 &lt;- surv0[tau_horizon]&quot;                                                                                                                                 
[177] &quot;  dt &lt;- diff(tpoints)&quot;                                                                                                                                         
[178] &quot;  mid_dhat &lt;- (head(dhat, -1) + tail(dhat, -1))/2&quot;                                                                                                             
[179] &quot;  cumulative_rmst &lt;- c(0, cumsum(mid_dhat * dt))&quot;                                                                                                              
[180] &quot;  rmst &lt;- cumulative_rmst[length(dhat)]&quot;                                                                                                                       
[181] &quot;  # m1&quot;                                                                                                                                                        
[182] &quot;  mid_dhat &lt;- (head(surv1, -1) + tail(surv1, -1))/2&quot;                                                                                                           
[183] &quot;  cumulative_rmst1 &lt;- c(0, cumsum(mid_dhat * dt))&quot;                                                                                                             
[184] &quot;  rmst1 &lt;- cumulative_rmst1[length(surv1)]&quot;                                                                                                                    
[185] &quot;  # m0&quot;                                                                                                                                                        
[186] &quot;  mid_dhat &lt;- (head(surv0, -1) + tail(surv0, -1))/2&quot;                                                                                                           
[187] &quot;  cumulative_rmst0 &lt;- c(0, cumsum(mid_dhat * dt))&quot;                                                                                                             
[188] &quot;  rmst0 &lt;- cumulative_rmst0[length(surv0)]&quot;                                                                                                                    
[189] &quot;&quot;                                                                                                                                                              
[190] &quot;  return(list(tau=taumax, rmst = signif(rmst,2), rmst1 = signif(rmst1,2), rmst0 = signif(rmst0,2)))&quot;                                                           
[191] &quot;}&quot;                                                                                                                                                             
[192] &quot;&quot;                                                                                                                                                              
[193] &quot;&quot;                                                                                                                                                              
[194] &quot;#' Analyze subgroup for summary table&quot;                                                                                                                         
[195] &quot;#'&quot;                                                                                                                                                            
[196] &quot;#' Analyzes a subgroup and returns formatted results for summary table.&quot;                                                                                       
[197] &quot;#'&quot;                                                                                                                                                            
[198] &quot;#' @param df_sub Data frame for subgroup.&quot;                                                                                                                     
[199] &quot;#' @param outcome.name Character. Name of outcome variable.&quot;                                                                                                   
[200] &quot;#' @param event.name Character. Name of event indicator variable.&quot;                                                                                             
[201] &quot;#' @param treat.name Character. Name of treatment variable.&quot;                                                                                                   
[202] &quot;#' @param strata.name Character. Name of strata variable (optional).&quot;                                                                                          
[203] &quot;#' @param subgroup_name Character. Subgroup name.&quot;                                                                                                             
[204] &quot;#' @param hr_a Character. Adjusted hazard ratio (optional).&quot;                                                                                                   
[205] &quot;#' @param potentialOutcome.name Character. Name of potential outcome variable (optional).&quot;                                                                     
[206] &quot;#' @param return_medians Logical. Use medians or RMST.&quot;                                                                                                        
[207] &quot;#' @param N Integer. Total sample size.&quot;                                                                                                                       
[208] &quot;#' @return Character vector of results.&quot;                                                                                                                       
[209] &quot;#' @export&quot;                                                                                                                                                    
[210] &quot;&quot;                                                                                                                                                              
[211] &quot;analyze_subgroup &lt;- function(df_sub, outcome.name, event.name, treat.name, strata.name, subgroup_name, hr_a, potentialOutcome.name, return_medians, N) {&quot;      
[212] &quot;  Y &lt;- df_sub[, outcome.name]&quot;                                                                                                                                 
[213] &quot;  E &lt;- df_sub[, event.name]&quot;                                                                                                                                   
[214] &quot;  Treat &lt;- df_sub[, treat.name]&quot;                                                                                                                               
[215] &quot;  Strata &lt;- if (is.null(strata.name)) rep(\&quot;All\&quot;, length(Y)) else df_sub[, strata.name]&quot;                                                                      
[216] &quot;&quot;                                                                                                                                                              
[217] &quot;  hr &lt;- cox_summary(Y, E, Treat, Strata)&quot;                                                                                                                      
[218] &quot;  meds &lt;- km_summary(Y, E, Treat)&quot;                                                                                                                             
[219] &quot;  rmst &lt;- rmst_calculation(df_sub, outcome.name, event.name, treat.name)&quot;                                                                                      
[220] &quot;  counts &lt;- calculate_counts(Y, E, Treat, N)&quot;                                                                                                                  
[221] &quot;  hr_po &lt;- if (!is.null(potentialOutcome.name)) calculate_potential_hr(df_sub, potentialOutcome.name) else NA&quot;                                                 
[222] &quot;&quot;                                                                                                                                                              
[223] &quot;  m1 &lt;- if (return_medians) meds[2] else rmst$rmst1&quot;                                                                                                           
[224] &quot;  m0 &lt;- if (return_medians) meds[1] else rmst$rmst0&quot;                                                                                                           
[225] &quot;&quot;                                                                                                                                                              
[226] &quot;  format_results(subgroup_name, counts$n, counts$n_treat, counts$d, m1, m0, rmst$rmst, hr, hr_a, hr_po, return_medians)&quot;                                       
[227] &quot;}&quot;                                                                                                                                                             
[228] &quot;&quot;                                                                                                                                                              
[229] &quot;#' Subgroup summary table estimates&quot;                                                                                                                           
[230] &quot;#'&quot;                                                                                                                                                            
[231] &quot;#' Returns a summary table of subgroup estimates (HR, RMST, medians, etc.).&quot;                                                                                   
[232] &quot;#'&quot;                                                                                                                                                            
[233] &quot;#' @param df Data frame.&quot;                                                                                                                                      
[234] &quot;#' @param SG_flag Character. Subgroup flag variable.&quot;                                                                                                          
[235] &quot;#' @param outcome.name Character. Name of outcome variable.&quot;                                                                                                   
[236] &quot;#' @param event.name Character. Name of event indicator variable.&quot;                                                                                             
[237] &quot;#' @param treat.name Character. Name of treatment variable.&quot;                                                                                                   
[238] &quot;#' @param strata.name Character. Name of strata variable (optional).&quot;                                                                                          
[239] &quot;#' @param hr_1a Character. Adjusted HR for subgroup 1 (optional).&quot;                                                                                             
[240] &quot;#' @param hr_0a Character. Adjusted HR for subgroup 0 (optional).&quot;                                                                                             
[241] &quot;#' @param potentialOutcome.name Character. Name of potential outcome variable (optional).&quot;                                                                     
[242] &quot;#' @param sg1_name Character. Name for subgroup 1.&quot;                                                                                                            
[243] &quot;#' @param sg0_name Character. Name for subgroup 0.&quot;                                                                                                            
[244] &quot;#' @param draws Integer. Number of draws for resampling (optional).&quot;                                                                                           
[245] &quot;#' @param details Logical. Print details.&quot;                                                                                                                     
[246] &quot;#' @param return_medians Logical. Use medians or RMST.&quot;                                                                                                        
[247] &quot;#' @param est.scale Character. Effect scale (\&quot;hr\&quot; or \&quot;1/hr\&quot;).&quot;                                                                                             
[248] &quot;#' @return Data frame of subgroup summary estimates.&quot;                                                                                                          
[249] &quot;#' @export&quot;                                                                                                                                                    
[250] &quot;&quot;                                                                                                                                                              
[251] &quot;SG_tab_estimates &lt;- function(df, SG_flag, outcome.name = \&quot;tte\&quot;, event.name = \&quot;event\&quot;, treat.name = \&quot;treat\&quot;, strata.name = NULL,&quot;                         
[252] &quot;                             hr_1a = NA, hr_0a = NA, potentialOutcome.name = NULL,&quot;                                                                            
[253] &quot;                             sg1_name = NULL, sg0_name = NULL, draws = 0,&quot;                                                                                     
[254] &quot;                             details = FALSE, return_medians = TRUE, est.scale = \&quot;hr\&quot;) {&quot;                                                                    
[255] &quot;  N &lt;- nrow(df)&quot;                                                                                                                                               
[256] &quot;  if (SG_flag != \&quot;ITT\&quot;) {&quot;                                                                                                                                   
[257] &quot;    subgroups &lt;- prepare_subgroup_data(df, SG_flag, est.scale, treat.name)&quot;                                                                                    
[258] &quot;    df_0 &lt;- subgroups$df_0&quot;                                                                                                                                    
[259] &quot;    df_1 &lt;- subgroups$df_1&quot;                                                                                                                                    
[260] &quot;    treat.name &lt;- subgroups$treat.name&quot;                                                                                                                        
[261] &quot;&quot;                                                                                                                                                              
[262] &quot;    res_0 &lt;- analyze_subgroup(df_0, outcome.name, event.name, treat.name, strata.name, sg0_name, hr_0a, potentialOutcome.name, return_medians, N)&quot;             
[263] &quot;    res_1 &lt;- analyze_subgroup(df_1, outcome.name, event.name, treat.name, strata.name, sg1_name, hr_1a, potentialOutcome.name, return_medians, N)&quot;             
[264] &quot;    res &lt;- rbind(res_0, res_1)&quot;                                                                                                                                
[265] &quot;&quot;                                                                                                                                                              
[266] &quot;    # Set column names&quot;                                                                                                                                        
[267] &quot;    if (is.na(hr_1a)) {&quot;                                                                                                                                       
[268] &quot;      if (is.null(potentialOutcome.name)) colnames(res) &lt;- c(\&quot;Subgroup\&quot;, \&quot;n\&quot;, \&quot;n1\&quot;, \&quot;events\&quot;, \&quot;m1\&quot;, \&quot;m0\&quot;, \&quot;RMST\&quot;, \&quot;HR (95% CI)\&quot;)&quot;              
[269] &quot;      else colnames(res) &lt;- c(\&quot;Subgroup\&quot;, \&quot;n\&quot;, \&quot;n1\&quot;, \&quot;events\&quot;, \&quot;m1\&quot;, \&quot;m0\&quot;, \&quot;RMST\&quot;, \&quot;HR (95% CI)\&quot;, \&quot;AHR(po)\&quot;)&quot;                                
[270] &quot;    } else {&quot;                                                                                                                                                  
[271] &quot;      if (is.null(potentialOutcome.name)) colnames(res) &lt;- c(\&quot;Subgroup\&quot;, \&quot;n\&quot;, \&quot;n1\&quot;, \&quot;events\&quot;, \&quot;m1\&quot;, \&quot;m0\&quot;, \&quot;RMST\&quot;, \&quot;HR (95% CI)\&quot;, \&quot;HR*\&quot;)&quot;     
[272] &quot;      else colnames(res) &lt;- c(\&quot;Subgroup\&quot;, \&quot;n\&quot;, \&quot;n1\&quot;, \&quot;events\&quot;, \&quot;m1\&quot;, \&quot;m0\&quot;, \&quot;RMST\&quot;, \&quot;HR (95% CI)\&quot;, \&quot;HR*\&quot;, \&quot;AHR(po)\&quot;)&quot;                       
[273] &quot;    }&quot;                                                                                                                                                         
[274] &quot;    return(res)&quot;                                                                                                                                               
[275] &quot;  } else {&quot;                                                                                                                                                    
[276] &quot;    res &lt;- analyze_subgroup(df, outcome.name, event.name, treat.name, strata.name, \&quot;ITT\&quot;, NA, potentialOutcome.name, return_medians, N)&quot;                     
[277] &quot;    if (is.na(hr_1a)) {&quot;                                                                                                                                       
[278] &quot;      if (is.null(potentialOutcome.name)) names(res) &lt;- c(\&quot;Subgroup\&quot;, \&quot;n\&quot;, \&quot;n1\&quot;, \&quot;events\&quot;, \&quot;m1\&quot;, \&quot;m0\&quot;, \&quot;RMST\&quot;, \&quot;HR (95% CI)\&quot;)&quot;                 
[279] &quot;      else names(res) &lt;- c(\&quot;Subgroup\&quot;, \&quot;n\&quot;, \&quot;n1\&quot;, \&quot;events\&quot;, \&quot;m1\&quot;, \&quot;m0\&quot;, \&quot;RMST\&quot;, \&quot;HR (95% CI)\&quot;, \&quot;AHR(po)\&quot;)&quot;                                   
[280] &quot;    } else {&quot;                                                                                                                                                  
[281] &quot;      if (is.null(potentialOutcome.name)) names(res) &lt;- c(\&quot;Subgroup\&quot;, \&quot;n\&quot;, \&quot;n1\&quot;, \&quot;events\&quot;, \&quot;m1\&quot;, \&quot;m0\&quot;, \&quot;RMST\&quot;, \&quot;HR (95% CI)\&quot;, \&quot;HR*\&quot;)&quot;        
[282] &quot;      else names(res) &lt;- c(\&quot;Subgroup\&quot;, \&quot;n\&quot;, \&quot;n1\&quot;, \&quot;events\&quot;, \&quot;m1\&quot;, \&quot;m0\&quot;, \&quot;RMST\&quot;, \&quot;HR (95% CI)\&quot;, \&quot;HR*\&quot;, \&quot;AHR(po)\&quot;)&quot;                          
[283] &quot;    }&quot;                                                                                                                                                         
[284] &quot;    return(res)&quot;                                                                                                                                               
[285] &quot;  }&quot;                                                                                                                                                           
[286] &quot;}&quot;                                                                                                                                                             
[287] &quot;&quot;                                                                                                                                                              
[288] &quot;#' Subgroup summary tables (gt output)&quot;                                                                                                                        
[289] &quot;#'&quot;                                                                                                                                                            
[290] &quot;#' Returns formatted summary tables for subgroups using the gt package, with customizable decimal precision.&quot;                                                  
[291] &quot;#'&quot;                                                                                                                                                            
[292] &quot;#' @param fs ForestSearch results object.&quot;                                                                                                                     
[293] &quot;#' @param which_df Character. Which data frame to use (\&quot;est\&quot; or \&quot;testing\&quot;).&quot;                                                                               
[294] &quot;#' @param est_caption Character. Caption for estimates table.&quot;                                                                                                 
[295] &quot;#' @param potentialOutcome.name Character. Name of potential outcome variable (optional).&quot;                                                                     
[296] &quot;#' @param hr_1a Character. Adjusted HR for subgroup 1 (optional).&quot;                                                                                             
[297] &quot;#' @param hr_0a Character. Adjusted HR for subgroup 0 (optional).&quot;                                                                                             
[298] &quot;#' @param ndecimals Integer. Number of decimals for formatted numbers (default: 3).&quot;                                                                           
[299] &quot;#'&quot;                                                                                                                                                            
[300] &quot;#' @return List with gt tables for estimates and subgroups.&quot;                                                                                                   
[301] &quot;#'&quot;                                                                                                                                                            
[302] &quot;#' @importFrom gt gt fmt_number tab_header&quot;                                                                                                                    
[303] &quot;#' @export&quot;                                                                                                                                                    
[304] &quot;&quot;                                                                                                                                                              
[305] &quot;sg_tables &lt;- function(fs, which_df = \&quot;est\&quot;, est_caption = \&quot;Training data estimates\&quot;, potentialOutcome.name = NULL, hr_1a = NA, hr_0a = NA, ndecimals = 3){&quot;
[306] &quot;&quot;                                                                                                                                                              
[307] &quot;  if (!requireNamespace(\&quot;gt\&quot;, quietly = TRUE)) {&quot;                                                                                                            
[308] &quot;    stop(\&quot;Package 'gt' required.\&quot;)&quot;                                                                                                                          
[309] &quot;  }&quot;                                                                                                                                                           
[310] &quot;&quot;                                                                                                                                                              
[311] &quot;  if(which_df == \&quot;est\&quot;) df &lt;- fs$df.est&quot;                                                                                                                     
[312] &quot;  if(which_df == \&quot;testing\&quot;) df &lt;- fs$df.test&quot;                                                                                                                
[313] &quot;&quot;                                                                                                                                                              
[314] &quot;  args_fs &lt;- fs$args_call_all&quot;                                                                                                                                 
[315] &quot;  args_tab &lt;- names(formals(SG_tab_estimates))&quot;                                                                                                                
[316] &quot;  # align with args_call_all&quot;                                                                                                                                  
[317] &quot;  args_tab_filtered &lt;- args_fs[args_fs %in% names(args_tab)]&quot;                                                                                                  
[318] &quot;  args_tab_filtered$df &lt;- df&quot;                                                                                                                                  
[319] &quot;  args_tab_filtered$sg0_name &lt;- \&quot;Questionable\&quot;&quot;                                                                                                              
[320] &quot;  args_tab_filtered$sg1_name &lt;- \&quot;Recommend\&quot;&quot;                                                                                                                 
[321] &quot;  args_tab_filtered$hr_1a &lt;- hr_1a&quot;                                                                                                                            
[322] &quot;  args_tab_filtered$hr_0a &lt;- hr_0a&quot;                                                                                                                            
[323] &quot;&quot;                                                                                                                                                              
[324] &quot;  # ITT estimates&quot;                                                                                                                                             
[325] &quot;  args_tab_filtered$SG_flag &lt;- \&quot;ITT\&quot;&quot;                                                                                                                        
[326] &quot;&quot;                                                                                                                                                              
[327] &quot;  aa &lt;- do.call(SG_tab_estimates, args_tab_filtered)&quot;                                                                                                          
[328] &quot;&quot;                                                                                                                                                              
[329] &quot;  args_tab_filtered$SG_flag &lt;- \&quot;treat.recommend\&quot;&quot;                                                                                                            
[330] &quot;&quot;                                                                                                                                                              
[331] &quot;  bb &lt;- do.call(SG_tab_estimates, args_tab_filtered)&quot;                                                                                                          
[332] &quot;&quot;                                                                                                                                                              
[333] &quot;  tab_est &lt;- as.data.frame(rbind(aa,bb))&quot;                                                                                                                      
[334] &quot;&quot;                                                                                                                                                              
[335] &quot;  tab_estimates &lt;- gt::gt(tab_est, caption = est_caption, auto_align = TRUE)&quot;                                                                                  
[336] &quot;&quot;                                                                                                                                                              
[337] &quot;  if(fs$sg_focus==\&quot;hr\&quot;) sg10  &lt;- as.data.frame(fs$grp.consistency$out_hr$result)&quot;                                                                            
[338] &quot;  if(fs$sg_focus %in% c(\&quot;minSG\&quot;,\&quot;hrMinSG\&quot;)) sg10  &lt;- as.data.frame(fs$grp.consistency$out_minSG$result)&quot;                                                   
[339] &quot;  if(fs$sg_focus %in% c(\&quot;maxSG\&quot;,\&quot;hrMaxSG\&quot;)) sg10  &lt;- as.data.frame(fs$grp.consistency$out_maxSG$result)&quot;                                                   
[340] &quot;&quot;                                                                                                                                                              
[341] &quot;  if(args_fs$maxk == 1){&quot;                                                                                                                                      
[342] &quot;    # Subgroup identification =\&quot;M.1\&quot;&quot;                                                                                                                        
[343] &quot;    # Consistency rate = \&quot;Pcons\&quot;&quot;                                                                                                                            
[344] &quot;    # hr = \&quot;hr\&quot;&quot;                                                                                                                                             
[345] &quot;    # sample size = \&quot;N\&quot;&quot;                                                                                                                                     
[346] &quot;    # Total events = \&quot;E\&quot;&quot;                                                                                                                                    
[347] &quot;    sg10 &lt;- sg10[,c(\&quot;M.1\&quot;,\&quot;N\&quot;,\&quot;E\&quot;,\&quot;hr\&quot;,\&quot;Pcons\&quot;)]&quot;                                                                                                    
[348] &quot;&quot;                                                                                                                                                              
[349] &quot;    if(args_fs$est.scale == \&quot;1/hr\&quot;){&quot;                                                                                                                        
[350] &quot;      sg10$hr &lt;- c(1/sg10$hr)&quot;                                                                                                                                 
[351] &quot;    }&quot;                                                                                                                                                         
[352] &quot;&quot;                                                                                                                                                              
[353] &quot;    sg10_out &lt;- sg10 |&gt; gr::gt() |&gt;&quot;                                                                                                                           
[354] &quot;      gt::fmt_number(columns=c(4,5),decimals = ndecimals) |&gt;&quot;                                                                                                  
[355] &quot;      gt::fmt_number(columns=c(2,3),decimals = 0) |&gt;&quot;                                                                                                          
[356] &quot;      gt::tab_header(title=\&quot;Subgroups formed by single-factors\&quot;,&quot;                                                                                            
[357] &quot;                 subtitle=\&quot;maxk=1\&quot;)&quot;                                                                                                                         
[358] &quot;  }&quot;                                                                                                                                                           
[359] &quot;  if(args_fs$maxk == 2){&quot;                                                                                                                                      
[360] &quot;    sg10 &lt;- sg10[,c(\&quot;M.1\&quot;,\&quot;M.2\&quot;,\&quot;N\&quot;,\&quot;E\&quot;,\&quot;hr\&quot;,\&quot;Pcons\&quot;)]&quot;                                                                                            
[361] &quot;&quot;                                                                                                                                                              
[362] &quot;    if(args_fs$est.scale==\&quot;1/hr\&quot;){&quot;                                                                                                                          
[363] &quot;      sg10$hr &lt;- c(1/sg10$hr)&quot;                                                                                                                                 
[364] &quot;    }&quot;                                                                                                                                                         
[365] &quot;&quot;                                                                                                                                                              
[366] &quot;    sg10_out &lt;- sg10 |&gt; gt::gt() |&gt;&quot;                                                                                                                           
[367] &quot;      gt::fmt_number(columns=c(5,6),decimals = ndecimals) |&gt;&quot;                                                                                                  
[368] &quot;      gt::fmt_number(columns=c(2,3),decimals = 0) |&gt;&quot;                                                                                                          
[369] &quot;      gt::tab_header(title=\&quot;Subgroups formed by two-factors\&quot;,&quot;                                                                                               
[370] &quot;                 subtitle=\&quot;maxk=2\&quot;)&quot;                                                                                                                         
[371] &quot;  }&quot;                                                                                                                                                           
[372] &quot;&quot;                                                                                                                                                              
[373] &quot;&quot;                                                                                                                                                              
[374] &quot;  return(list(tab_estimates = tab_estimates, sg10_out = sg10_out))&quot;                                                                                            
[375] &quot;}&quot;                                                                                                                                                             
</code></pre></div><div class="user-msg"><strong>User:</strong> Continue answering the question based on the results.</div><div class="bot-msg"><strong>ADW:</strong> <p>Here is a summary of the inspected functions from the two files:</p>
<hr />
<h3><code>grf_functions.R</code></h3>
<p>Contains two main functions for subgroup identification and evaluation using Generalized Random Forests (GRF):</p>
<ol>
<li><strong>grf.subg.harm.survival</strong></li>
<li>Identifies subgroups with differential treatment effect in survival data using GRF and policy trees.</li>
<li>Inputs: data, confounders, outcome/event/treatment/ID names, GRF parameters (e.g., tree depth, minimum subgroup size, etc.).</li>
<li>Outputs: List with GRF results, subgroup definitions, tree cuts, and policy tree objects.</li>
<li>
<p>Handles both RCT and non-RCT data, fits trees of depth 1-3, extracts subgroup-defining cuts, and selects subgroups based on mean difference or size criteria.</p>
</li>
<li>
<p><strong>grf.estimates.out</strong></p>
</li>
<li>Evaluates the performance of GRF-identified subgroups, including hazard ratios, bias, predictive values, etc.</li>
<li>Inputs: Data, GRF results, simulation truth (if available), Cox model formulas.</li>
<li>Outputs: Data frame with performance metrics (HR, bias, PPV, NPV, sensitivity, specificity, etc.).</li>
<li>Handles all cases: true subgroup exists and found, true subgroup exists and not found, no true subgroup but found, and neither exists nor found.</li>
</ol>
<hr />
<h3><code>summary_utility_functions.R</code></h3>
<p>Provides utility functions for summarizing and formatting subgroup analysis results:</p>
<ol>
<li><strong>hrCI_format</strong></li>
<li>
<p>Formats hazard ratio and confidence interval for display.</p>
</li>
<li>
<p><strong>n_pcnt</strong></p>
</li>
<li>
<p>Returns count and percent for a vector relative to a denominator.</p>
</li>
<li>
<p><strong>prepare_subgroup_data</strong></p>
</li>
<li>
<p>Splits a data frame into two subgroups based on a flag and treatment scale.</p>
</li>
<li>
<p><strong>cox_summary</strong></p>
</li>
<li>
<p>Calculates hazard ratio and confidence interval for a subgroup using Cox regression.</p>
</li>
<li>
<p><strong>km_summary</strong></p>
</li>
<li>
<p>Calculates median survival for each treatment group using Kaplan-Meier.</p>
</li>
<li>
<p><strong>calculate_counts</strong></p>
</li>
<li>
<p>Calculates sample size, treated count, and event count for a subgroup.</p>
</li>
<li>
<p><strong>calculate_potential_hr</strong></p>
</li>
<li>
<p>Calculates the average hazard ratio from a potential outcome variable.</p>
</li>
<li>
<p><strong>format_results</strong></p>
</li>
<li>
<p>Formats results for subgroup summary table.</p>
</li>
<li>
<p><strong>rmst_calculation</strong></p>
</li>
<li>
<p>Calculates restricted mean survival time (RMST) for a subgroup.</p>
</li>
<li>
<p><strong>analyze_subgroup</strong></p>
<ul>
<li>Analyzes a subgroup and returns formatted results for summary table.</li>
</ul>
</li>
<li>
<p><strong>SG_tab_estimates</strong></p>
<ul>
<li>Returns a summary table of subgroup estimates (HR, RMST, medians, etc.).</li>
</ul>
</li>
<li>
<p><strong>sg_tables</strong></p>
<ul>
<li>Returns formatted summary tables for subgroups using the gt package, with customizable decimal precision.</li>
</ul>
</li>
</ol>
<hr />
<p>If you need to run, test, or analyze any of these functions, or want to see how they work with your data, please provide further instructions or a dataset.</p></div><div class="user-msg"><strong>User:</strong> üìÅ[forestsearch_bootstrap_helpers.R]</div><div class="user-msg"><strong>User:</strong> please inspect</div><div class="bot-msg"><strong>ADW:</strong> <p>üü¢Working:</p>
<pre><code class="language-R"># Read and display the contents of the forestsearch_bootstrap_helpers.R file
bs_helpers_content &lt;- readLines('forestsearch_bootstrap_helpers.R')
bs_helpers_content
</code></pre></div><div class="bot-msg"><strong>ADW:</strong> <p>‚úîÔ∏èTerminal output:</p>
<pre><code class="language-shell">  [1] &quot;#' Count ID Occurrences in Bootstrap Sample&quot;                                                                                                         
  [2] &quot;#'&quot;                                                                                                                                                  
  [3] &quot;#' Counts the number of times an ID appears in a bootstrap sample.&quot;                                                                                  
  [4] &quot;#'&quot;                                                                                                                                                  
  [5] &quot;#' @param x ID value.&quot;                                                                                                                               
  [6] &quot;#' @param dfb Data frame of bootstrap sample.&quot;                                                                                                       
  [7] &quot;#' @return Integer count of occurrences.&quot;                                                                                                            
  [8] &quot;#' @export&quot;                                                                                                                                          
  [9] &quot;&quot;                                                                                                                                                    
 [10] &quot;count.id &lt;- function(x,dfb){&quot;                                                                                                                        
 [11] &quot;  sum(dfb$id==x)&quot;                                                                                                                                    
 [12] &quot;  }&quot;                                                                                                                                                 
 [13] &quot;&quot;                                                                                                                                                    
 [14] &quot;#' Calculate Covariance for Bootstrap Estimates&quot;                                                                                                     
 [15] &quot;#'&quot;                                                                                                                                                  
 [16] &quot;#' Calculates the covariance between a vector and bootstrap estimates.&quot;                                                                              
 [17] &quot;#'&quot;                                                                                                                                                  
 [18] &quot;#' @param x Numeric vector.&quot;                                                                                                                         
 [19] &quot;#' @param Est Numeric vector of bootstrap estimates.&quot;                                                                                                
 [20] &quot;#' @return Numeric value of covariance.&quot;                                                                                                             
 [21] &quot;#' @export&quot;                                                                                                                                          
 [22] &quot;&quot;                                                                                                                                                    
 [23] &quot;calc_cov &lt;- function(x,Est){&quot;                                                                                                                        
 [24] &quot;  mean(c((x-mean(x,na.rm=TRUE))*Est),na.rm=TRUE)&quot;                                                                                                    
 [25] &quot;}&quot;                                                                                                                                                   
 [26] &quot;&quot;                                                                                                                                                    
 [27] &quot;#' Confidence Interval for Estimate&quot;                                                                                                                 
 [28] &quot;#'&quot;                                                                                                                                                  
 [29] &quot;#' Calculates confidence interval for an estimate, optionally on log(HR) scale.&quot;                                                                     
 [30] &quot;#'&quot;                                                                                                                                                  
 [31] &quot;#' @param x Numeric estimate.&quot;                                                                                                                       
 [32] &quot;#' @param sd Numeric standard deviation.&quot;                                                                                                            
 [33] &quot;#' @param alpha Numeric significance level (default: 0.025).&quot;                                                                                        
 [34] &quot;#' @param scale Character. \&quot;hr\&quot; or \&quot;1/hr\&quot;.&quot;                                                                                                      
 [35] &quot;#' @param est.loghr Logical. Is estimate on log(HR) scale?&quot;                                                                                          
 [36] &quot;#' @return List with length, lower, upper, sd, and estimate.&quot;                                                                                        
 [37] &quot;#' @importFrom stats qnorm&quot;                                                                                                                          
 [38] &quot;#' @export&quot;                                                                                                                                          
 [39] &quot;&quot;                                                                                                                                                    
 [40] &quot;ci_est &lt;- function(x, sd, alpha = 0.025, scale = \&quot;hr\&quot;, est.loghr = TRUE) {&quot;                                                                        
 [41] &quot;  # Input validation&quot;                                                                                                                                
 [42] &quot;  if (!is.numeric(x) || length(x) != 1 || is.na(x) || is.infinite(x)) {&quot;                                                                             
 [43] &quot;    stop(\&quot;'x' must be a single, finite numeric value.\&quot;)&quot;                                                                                           
 [44] &quot;  }&quot;                                                                                                                                                 
 [45] &quot;  if (!is.numeric(sd) || length(sd) != 1 || is.na(sd) || is.infinite(sd) || sd &lt; 0) {&quot;                                                               
 [46] &quot;    stop(\&quot;'sd' must be a single, non-negative, finite numeric value.\&quot;)&quot;                                                                            
 [47] &quot;  }&quot;                                                                                                                                                 
 [48] &quot;  if (!is.numeric(alpha) || length(alpha) != 1 || is.na(alpha) || alpha &lt;= 0 || alpha &gt;= 0.5) {&quot;                                                     
 [49] &quot;    stop(\&quot;'alpha' must be a single numeric value between 0 and 0.5.\&quot;)&quot;                                                                             
 [50] &quot;  }&quot;                                                                                                                                                 
 [51] &quot;  if (!scale %in% c(\&quot;hr\&quot;, \&quot;1/hr\&quot;)) {&quot;                                                                                                            
 [52] &quot;    stop(\&quot;'scale' must be either 'hr' or '1/hr'.\&quot;)&quot;                                                                                                
 [53] &quot;  }&quot;                                                                                                                                                 
 [54] &quot;  if (!is.logical(est.loghr) || length(est.loghr) != 1 || is.na(est.loghr)) {&quot;                                                                       
 [55] &quot;    stop(\&quot;'est.loghr' must be a single logical value.\&quot;)&quot;                                                                                           
 [56] &quot;  }&quot;                                                                                                                                                 
 [57] &quot;&quot;                                                                                                                                                    
 [58] &quot;  c_alpha &lt;- qnorm(1 - alpha)&quot;                                                                                                                       
 [59] &quot;  c_low &lt;- x - c_alpha * sd&quot;                                                                                                                         
 [60] &quot;  c_up &lt;- x + c_alpha * sd&quot;                                                                                                                          
 [61] &quot;  est &lt;- x&quot;                                                                                                                                          
 [62] &quot;  new_low &lt;- c_low&quot;                                                                                                                                  
 [63] &quot;  new_up &lt;- c_up&quot;                                                                                                                                    
 [64] &quot;  out_sd &lt;- sd&quot;                                                                                                                                      
 [65] &quot;&quot;                                                                                                                                                    
 [66] &quot;  if (scale == \&quot;hr\&quot; &amp;&amp; est.loghr) {&quot;                                                                                                               
 [67] &quot;    est &lt;- exp(x)&quot;                                                                                                                                   
 [68] &quot;    out_sd &lt;- exp(x) * sd&quot;                                                                                                                           
 [69] &quot;    new_low &lt;- exp(c_low)&quot;                                                                                                                           
 [70] &quot;    new_up &lt;- exp(c_up)&quot;                                                                                                                             
 [71] &quot;  }&quot;                                                                                                                                                 
 [72] &quot;  if (scale == \&quot;1/hr\&quot; &amp;&amp; est.loghr) {&quot;                                                                                                             
 [73] &quot;    est &lt;- exp(-x)&quot;                                                                                                                                  
 [74] &quot;    out_sd &lt;- exp(-x) * sd&quot;                                                                                                                          
 [75] &quot;    new_low &lt;- exp(-c_up)&quot;                                                                                                                           
 [76] &quot;    new_up &lt;- exp(-c_low)&quot;                                                                                                                           
 [77] &quot;  }&quot;                                                                                                                                                 
 [78] &quot;  length &lt;- new_up - new_low&quot;                                                                                                                        
 [79] &quot;&quot;                                                                                                                                                    
 [80] &quot;  # Return as named list&quot;                                                                                                                            
 [81] &quot;  return(list(&quot;                                                                                                                                      
 [82] &quot;    length = length,&quot;                                                                                                                                
 [83] &quot;    lower = new_low,&quot;                                                                                                                                
 [84] &quot;    upper = new_up,&quot;                                                                                                                                 
 [85] &quot;    sd = out_sd,&quot;                                                                                                                                    
 [86] &quot;    est = est&quot;                                                                                                                                       
 [87] &quot;  ))&quot;                                                                                                                                                
 [88] &quot;}&quot;                                                                                                                                                   
 [89] &quot;&quot;                                                                                                                                                    
 [90] &quot;#' Bootstrap Confidence Interval and Bias Correction Results&quot;                                                                                        
 [91] &quot;#'&quot;                                                                                                                                                  
 [92] &quot;#' Calculates confidence intervals and bias-corrected estimates for bootstrap results.&quot;                                                              
 [93] &quot;#'&quot;                                                                                                                                                  
 [94] &quot;#' @param Hobs Numeric. Observed estimate.&quot;                                                                                                          
 [95] &quot;#' @param seHobs Numeric. Standard error of observed estimate.&quot;                                                                                      
 [96] &quot;#' @param H1_adj Numeric. Bias-corrected estimate 1.&quot;                                                                                                
 [97] &quot;#' @param H2_adj Numeric. Bias-corrected estimate 2 (optional).&quot;                                                                                     
 [98] &quot;#' @param ystar Matrix of bootstrap samples.&quot;                                                                                                        
 [99] &quot;#' @param cov_method Character. Covariance method (\&quot;standard\&quot; or \&quot;nocorrect\&quot;).&quot;                                                                  
[100] &quot;#' @param cov_trim Numeric. Trimming proportion for covariance (default: 0.0).&quot;                                                                      
[101] &quot;#' @param est.scale Character. \&quot;hr\&quot; or \&quot;1/hr\&quot;.&quot;                                                                                                  
[102] &quot;#' @param est.loghr Logical. Is estimate on log(HR) scale?&quot;                                                                                          
[103] &quot;#' @return Data.table with confidence intervals and estimates.&quot;                                                                                      
[104] &quot;#' @importFrom data.table data.table&quot;                                                                                                                
[105] &quot;#' @export&quot;                                                                                                                                          
[106] &quot;&quot;                                                                                                                                                    
[107] &quot;get_dfRes &lt;- function(Hobs, seHobs, H1_adj, H2_adj = NULL, ystar, cov_method = \&quot;standard\&quot;, cov_trim = 0.0, est.scale = \&quot;hr\&quot;, est.loghr = TRUE) {&quot;
[108] &quot;  # Check required package&quot;                                                                                                                          
[109] &quot;  if (!requireNamespace(\&quot;data.table\&quot;, quietly = TRUE)) {&quot;                                                                                          
[110] &quot;    stop(\&quot;Package 'data.table' is required.\&quot;)&quot;                                                                                                     
[111] &quot;  }&quot;                                                                                                                                                 
[112] &quot;  # Check required function&quot;                                                                                                                         
[113] &quot;  if (!exists(\&quot;get_targetEst\&quot;)) {&quot;                                                                                                                 
[114] &quot;    stop(\&quot;Function 'get_targetEst' must be defined in the environment.\&quot;)&quot;                                                                          
[115] &quot;  }&quot;                                                                                                                                                 
[116] &quot;  # Input validation&quot;                                                                                                                                
[117] &quot;  if (!is.numeric(Hobs) || length(Hobs) != 1 || is.na(Hobs) || is.infinite(Hobs)) {&quot;                                                                 
[118] &quot;    stop(\&quot;'Hobs' must be a single, finite numeric value.\&quot;)&quot;                                                                                        
[119] &quot;  }&quot;                                                                                                                                                 
[120] &quot;  if (!is.numeric(seHobs) || length(seHobs) != 1 || is.na(seHobs) || is.infinite(seHobs) || seHobs &lt; 0) {&quot;                                           
[121] &quot;    stop(\&quot;'seHobs' must be a single, non-negative, finite numeric value.\&quot;)&quot;                                                                        
[122] &quot;  }&quot;                                                                                                                                                 
[123] &quot;  if (missing(ystar)) {&quot;                                                                                                                             
[124] &quot;    stop(\&quot;'ystar' must be provided.\&quot;)&quot;                                                                                                             
[125] &quot;  }&quot;                                                                                                                                                 
[126] &quot;  if (!is.character(cov_method) || length(cov_method) != 1) {&quot;                                                                                       
[127] &quot;    stop(\&quot;'cov_method' must be a single character string.\&quot;)&quot;                                                                                       
[128] &quot;  }&quot;                                                                                                                                                 
[129] &quot;  if (!is.numeric(cov_trim) || length(cov_trim) != 1 || is.na(cov_trim) || cov_trim &lt; 0 || cov_trim &gt; 1) {&quot;                                          
[130] &quot;    stop(\&quot;'cov_trim' must be a single numeric value between 0 and 1.\&quot;)&quot;                                                                            
[131] &quot;  }&quot;                                                                                                                                                 
[132] &quot;  if (!est.scale %in% c(\&quot;hr\&quot;, \&quot;1/hr\&quot;)) {&quot;                                                                                                        
[133] &quot;    stop(\&quot;'est.scale' must be either 'hr' or '1/hr'.\&quot;)&quot;                                                                                            
[134] &quot;  }&quot;                                                                                                                                                 
[135] &quot;  if (!is.logical(est.loghr) || length(est.loghr) != 1 || is.na(est.loghr)) {&quot;                                                                       
[136] &quot;    stop(\&quot;'est.loghr' must be a single logical value.\&quot;)&quot;                                                                                           
[137] &quot;  }&quot;                                                                                                                                                 
[138] &quot;&quot;                                                                                                                                                    
[139] &quot;  # Un-adjusted&quot;                                                                                                                                     
[140] &quot;  cest &lt;- ci_est(x = Hobs, sd = seHobs, scale = est.scale, est.loghr = est.loghr)&quot;                                                                   
[141] &quot;  H0_lower &lt;- cest$lower&quot;                                                                                                                            
[142] &quot;  H0_upper &lt;- cest$upper&quot;                                                                                                                            
[143] &quot;  sdH0 &lt;- cest$sd&quot;                                                                                                                                   
[144] &quot;  H0 &lt;- cest$est&quot;                                                                                                                                    
[145] &quot;&quot;                                                                                                                                                    
[146] &quot;  est &lt;- get_targetEst(x = H1_adj, ystar = ystar, cov_method = cov_method, cov_trim = cov_trim)&quot;                                                     
[147] &quot;  q &lt;- est$target_est&quot;                                                                                                                               
[148] &quot;  se_new &lt;- est$sehat_new&quot;                                                                                                                           
[149] &quot;&quot;                                                                                                                                                    
[150] &quot;  cest &lt;- ci_est(x = q, sd = se_new, scale = est.scale, est.loghr = est.loghr)&quot;                                                                      
[151] &quot;  H1_lower &lt;- cest$lower&quot;                                                                                                                            
[152] &quot;  H1_upper &lt;- cest$upper&quot;                                                                                                                            
[153] &quot;  sdH1 &lt;- cest$sd&quot;                                                                                                                                   
[154] &quot;  H1 &lt;- cest$est&quot;                                                                                                                                    
[155] &quot;&quot;                                                                                                                                                    
[156] &quot;  outres &lt;- data.table::data.table(H0, sdH0, H0_lower, H0_upper, H1, sdH1, H1_lower, H1_upper)&quot;                                                      
[157] &quot;&quot;                                                                                                                                                    
[158] &quot;  if (!is.null(H2_adj)) {&quot;                                                                                                                           
[159] &quot;    est &lt;- get_targetEst(x = H2_adj, ystar = ystar, cov_method = cov_method, cov_trim = cov_trim)&quot;                                                   
[160] &quot;    q &lt;- est$target_est&quot;                                                                                                                             
[161] &quot;    se_new &lt;- est$sehat_new&quot;                                                                                                                         
[162] &quot;    cest &lt;- ci_est(x = q, sd = se_new, scale = est.scale, est.loghr = est.loghr)&quot;                                                                    
[163] &quot;    H2_lower &lt;- cest$lower&quot;                                                                                                                          
[164] &quot;    H2_upper &lt;- cest$upper&quot;                                                                                                                          
[165] &quot;    sdH2 &lt;- cest$sd&quot;                                                                                                                                 
[166] &quot;    H2 &lt;- cest$est&quot;                                                                                                                                  
[167] &quot;    outres &lt;- data.table::data.table(H0, sdH0, H0_lower, H0_upper,&quot;                                                                                  
[168] &quot;                                     H1, sdH1, H1_lower, H1_upper,&quot;                                                                                  
[169] &quot;                                     H2, sdH2, H2_lower, H2_upper)&quot;                                                                                  
[170] &quot;  }&quot;                                                                                                                                                 
[171] &quot;  return(outres)&quot;                                                                                                                                    
[172] &quot;}&quot;                                                                                                                                                   
[173] &quot;&quot;                                                                                                                                                    
[174] &quot;#' Target Estimate and Standard Error for Bootstrap&quot;                                                                                                 
[175] &quot;#'&quot;                                                                                                                                                  
[176] &quot;#' Calculates target estimate and standard error for bootstrap samples.&quot;                                                                             
[177] &quot;#'&quot;                                                                                                                                                  
[178] &quot;#' @param x Numeric vector of estimates.&quot;                                                                                                            
[179] &quot;#' @param ystar Matrix of bootstrap samples.&quot;                                                                                                        
[180] &quot;#' @param cov_method Character. Covariance method (\&quot;standard\&quot; or \&quot;nocorrect\&quot;).&quot;                                                                  
[181] &quot;#' @param cov_trim Numeric. Trimming proportion for covariance (default: 0.0).&quot;                                                                      
[182] &quot;#' @return List with target estimate, standard errors, and correction term.&quot;                                                                         
[183] &quot;#' @export&quot;                                                                                                                                          
[184] &quot;&quot;                                                                                                                                                    
[185] &quot;get_targetEst &lt;- function(x, ystar, cov_method = \&quot;standard\&quot;, cov_trim = 0.0) {&quot;                                                                    
[186] &quot;  mx &lt;- mean(x, na.rm = TRUE)&quot;                                                                                                                       
[187] &quot;  xc &lt;- c(x - mx)&quot;                                                                                                                                   
[188] &quot;  N &lt;- ncol(ystar)&quot;                                                                                                                                  
[189] &quot;  # Ystar_mat is (B x N) matrix&quot;                                                                                                                     
[190] &quot;  # Across columns of Ystar&quot;                                                                                                                         
[191] &quot;  if (cov_method == \&quot;standard\&quot; | cov_method == \&quot;nocorrect\&quot;) {&quot;                                                                                   
[192] &quot;    cov_i &lt;- apply(ystar, 2, calc_cov, Est = xc)&quot;                                                                                                    
[193] &quot;  }&quot;                                                                                                                                                 
[194] &quot;  # Implement correction&quot;                                                                                                                            
[195] &quot;  if (cov_method != \&quot;nocorrect\&quot;) {&quot;                                                                                                                
[196] &quot;    varhat &lt;- N * mean(cov_i^2)&quot;                                                                                                                     
[197] &quot;    seH &lt;- sqrt(varhat)&quot;                                                                                                                             
[198] &quot;    # Denominator in cov_i is B.eval:&quot;                                                                                                               
[199] &quot;    B.eval &lt;- sum(!is.na(xc))&quot;                                                                                                                       
[200] &quot;    # correction&quot;                                                                                                                                    
[201] &quot;    nb_ratio &lt;- N / (B.eval^2)&quot;                                                                                                                      
[202] &quot;    termc &lt;- nb_ratio * B.eval * mean(xc^2, na.rm = TRUE, trim = cov_trim)&quot;                                                                          
[203] &quot;    if (varhat &lt;= termc) {&quot;                                                                                                                          
[204] &quot;      varhat_new &lt;- varhat&quot;                                                                                                                          
[205] &quot;      seH_new &lt;- sqrt(varhat)&quot;                                                                                                                       
[206] &quot;    }&quot;                                                                                                                                               
[207] &quot;    if (varhat &gt; termc) {&quot;                                                                                                                           
[208] &quot;      varhat_new &lt;- varhat - termc&quot;                                                                                                                  
[209] &quot;      seH_new &lt;- sqrt(varhat_new)&quot;                                                                                                                   
[210] &quot;    }&quot;                                                                                                                                               
[211] &quot;  }&quot;                                                                                                                                                 
[212] &quot;  if (cov_method == \&quot;nocorrect\&quot;) {&quot;                                                                                                                
[213] &quot;    varhat &lt;- N * mean(cov_i^2, trim = cov_trim)&quot;                                                                                                    
[214] &quot;    seH &lt;- sqrt(varhat)&quot;                                                                                                                             
[215] &quot;    termc &lt;- 0.0&quot;                                                                                                                                    
[216] &quot;    varhat_new &lt;- varhat&quot;                                                                                                                            
[217] &quot;    seH_new &lt;- seH&quot;                                                                                                                                  
[218] &quot;  }&quot;                                                                                                                                                 
[219] &quot;  out &lt;- (list(target_est = mx, sehat = seH, sehat_new = seH_new, term_correct = termc, varhat = varhat_new))&quot;                                       
[220] &quot;  return(out)&quot;                                                                                                                                       
[221] &quot;}&quot;                                                                                                                                                   
[222] &quot;&quot;                                                                                                                                                    
[223] &quot;#' Fit Cox Model for Subgroup&quot;                                                                                                                       
[224] &quot;#'&quot;                                                                                                                                                  
[225] &quot;#' Fits a Cox model for a subgroup and returns estimate and standard error.&quot;                                                                         
[226] &quot;#'&quot;                                                                                                                                                  
[227] &quot;#' @param df_sg Data frame for subgroup.&quot;                                                                                                            
[228] &quot;#' @param cox.formula Cox model formula.&quot;                                                                                                            
[229] &quot;#' @param est.loghr Logical. Is estimate on log(HR) scale?&quot;                                                                                          
[230] &quot;#' @return List with estimate and standard error.&quot;                                                                                                   
[231] &quot;#' @importFrom survival coxph&quot;                                                                                                                       
[232] &quot;#' @export&quot;                                                                                                                                          
[233] &quot;&quot;                                                                                                                                                    
[234] &quot;get_Cox_sg &lt;- function(df_sg, cox.formula, est.loghr = TRUE) {&quot;                                                                                      
[235] &quot;  names_tocheck &lt;- all.vars(cox.formula)&quot;                                                                                                            
[236] &quot;  check &lt;- unlist(lapply(names_tocheck, grep, names(df_sg), value = TRUE))&quot;                                                                          
[237] &quot;  check2 &lt;- match(names_tocheck, check)&quot;                                                                                                             
[238] &quot;  if (sum(!is.na(check2)) != length(names_tocheck)) stop(\&quot;df_sg dataset NOT contain cox.formula variables\&quot;)&quot;                                       
[239] &quot;  # Fit Cox model with robust standard errors&quot;                                                                                                       
[240] &quot;  fit &lt;- summary(coxph(cox.formula, data = df_sg, robust = TRUE))$coefficients&quot;                                                                      
[241] &quot;  # log(hr) parameters&quot;                                                                                                                              
[242] &quot;  if (est.loghr) {&quot;                                                                                                                                  
[243] &quot;    bhat &lt;- c(fit[, \&quot;coef\&quot;])&quot;                                                                                                                      
[244] &quot;    est_obs &lt;- bhat&quot;                                                                                                                                 
[245] &quot;    se_obs &lt;- c(fit[, \&quot;robust se\&quot;])&quot;                                                                                                               
[246] &quot;  }&quot;                                                                                                                                                 
[247] &quot;  # Otherwise, hr&quot;                                                                                                                                   
[248] &quot;  if (!est.loghr) {&quot;                                                                                                                                 
[249] &quot;    bhat &lt;- c(fit[, \&quot;coef\&quot;])&quot;                                                                                                                      
[250] &quot;    est_obs &lt;- exp(bhat)&quot;                                                                                                                            
[251] &quot;    sebhat &lt;- c(fit[, \&quot;robust se\&quot;])&quot;                                                                                                               
[252] &quot;    se_obs &lt;- est_obs * sebhat&quot;                                                                                                                      
[253] &quot;  }&quot;                                                                                                                                                 
[254] &quot;  return(list(est_obs = est_obs, se_obs = se_obs))&quot;                                                                                                  
[255] &quot;}&quot;                                                                                                                                                   
[256] &quot;&quot;                                                                                                                                                    
[257] &quot;&quot;                                                                                                                                                    
[258] &quot;#' Coverage Indicator for Confidence Interval&quot;                                                                                                       
[259] &quot;#'&quot;                                                                                                                                                  
[260] &quot;#' Checks if a target value is covered by a confidence interval.&quot;                                                                                    
[261] &quot;#'&quot;                                                                                                                                                  
[262] &quot;#' @param lower Numeric lower bound.&quot;                                                                                                                
[263] &quot;#' @param upper Numeric upper bound.&quot;                                                                                                                
[264] &quot;#' @param target Numeric target value (default: 0).&quot;                                                                                                 
[265] &quot;#' @return List with coverage indicator and interval length.&quot;                                                                                        
[266] &quot;#' @export&quot;                                                                                                                                          
[267] &quot;&quot;                                                                                                                                                    
[268] &quot;ci_cover&lt;-function(lower,upper,target=0){&quot;                                                                                                           
[269] &quot;  if(length(target)==1){&quot;                                                                                                                            
[270] &quot;    cover&lt;-ifelse(lower&lt;=target &amp; upper&gt;=target,1,0)&quot;                                                                                                
[271] &quot;    LC&lt;-upper-lower&quot;                                                                                                                                 
[272] &quot;    return(list(cover=cover,LC=LC))&quot;                                                                                                                 
[273] &quot;  }&quot;                                                                                                                                                 
[274] &quot;if(length(target)&gt;1){&quot;                                                                                                                               
[275] &quot;LC&lt;-upper-lower&quot;                                                                                                                                     
[276] &quot;covers&lt;-NULL&quot;                                                                                                                                        
[277] &quot;for(tt in 1:length(target)){&quot;                                                                                                                        
[278] &quot;cover&lt;-ifelse(lower&lt;=target[tt] &amp; upper&gt;=target[tt],1,0)&quot;                                                                                            
[279] &quot;covers&lt;-c(covers,cover)&quot;                                                                                                                             
[280] &quot;}&quot;                                                                                                                                                   
[281] &quot;return(list(cover=covers,LC=LC))&quot;                                                                                                                    
[282] &quot;  }&quot;                                                                                                                                                 
[283] &quot;  }&quot;                                                                                                                                                 
[284] &quot;&quot;                                                                                                                                                    
[285] &quot;#' Bootstrap Confidence Intervals for Two Targets&quot;                                                                                                   
[286] &quot;#'&quot;                                                                                                                                                  
[287] &quot;#' Calculates confidence intervals for two bootstrap targets.&quot;                                                                                       
[288] &quot;#'&quot;                                                                                                                                                  
[289] &quot;#' @param Q1 Numeric vector of first target estimates.&quot;                                                                                              
[290] &quot;#' @param Q2 Numeric vector of second target estimates.&quot;                                                                                             
[291] &quot;#' @param ystar Matrix of bootstrap samples.&quot;                                                                                                        
[292] &quot;#' @return List with estimates, standard errors, and confidence intervals.&quot;                                                                          
[293] &quot;#' @export&quot;                                                                                                                                          
[294] &quot;&quot;                                                                                                                                                    
[295] &quot;getCIs&lt;-function(Q1,Q2,ystar){&quot;                                                                                                                      
[296] &quot;# Target 1&quot;                                                                                                                                          
[297] &quot;est&lt;-get_targetEst(x=Q1,ystar=ystar)&quot;                                                                                                                
[298] &quot;# If est.loghr=TRUE then on log(HR) scale&quot;                                                                                                           
[299] &quot;q1&lt;-est$target_est&quot;                                                                                                                                  
[300] &quot;#se1&lt;-est$sehat&quot;                                                                                                                                     
[301] &quot;se1_new&lt;-est$sehat_new&quot;                                                                                                                              
[302] &quot;se1&lt;-est$sehat&quot;                                                                                                                                      
[303] &quot;rm(\&quot;est\&quot;)&quot;                                                                                                                                         
[304] &quot;# use SE new&quot;                                                                                                                                        
[305] &quot;cest&lt;-ci_est(x=q1,sd=se1_new)&quot;                                                                                                                       
[306] &quot;H1_lower&lt;-cest$lower&quot;                                                                                                                                
[307] &quot;H1_upper&lt;-cest$upper&quot;                                                                                                                                
[308] &quot;rm(\&quot;cest\&quot;)&quot;                                                                                                                                        
[309] &quot;&quot;                                                                                                                                                    
[310] &quot;# Target 2&quot;                                                                                                                                          
[311] &quot;est&lt;-get_targetEst(x=Q2,ystar=ystar)&quot;                                                                                                                
[312] &quot;# Call this H.bc&quot;                                                                                                                                    
[313] &quot;q2&lt;-est$target_est&quot;                                                                                                                                  
[314] &quot;se2&lt;-est$sehat&quot;                                                                                                                                      
[315] &quot;se2_new&lt;-est$sehat_new&quot;                                                                                                                              
[316] &quot;rm(\&quot;est\&quot;)&quot;                                                                                                                                         
[317] &quot;cest&lt;-ci_est(x=q2,sd=se2_new)&quot;                                                                                                                       
[318] &quot;H2_lower&lt;-cest$lower&quot;                                                                                                                                
[319] &quot;H2_upper&lt;-cest$upper&quot;                                                                                                                                
[320] &quot;rm(\&quot;cest\&quot;)&quot;                                                                                                                                        
[321] &quot;return(list(q1=q1,se1=se1,se1_new=se1_new,H1_lower=H1_lower,H1_upper=H1_upper,&quot;                                                                      
[322] &quot;            q2=q2,se2=se2,se2_new=se2_new,H2_lower=H2_lower,H2_upper=H2_upper))&quot;                                                                     
[323] &quot;}&quot;                                                                                                                                                   
[324] &quot;&quot;                                                                                                                                                    
[325] &quot;#' Prepare Data for Bias Plot&quot;                                                                                                                       
[326] &quot;#'&quot;                                                                                                                                                  
[327] &quot;#' Prepares a data frame for plotting bias in bootstrap estimates.&quot;                                                                                  
[328] &quot;#'&quot;                                                                                                                                                  
[329] &quot;#' @param res Data frame of results.&quot;                                                                                                                
[330] &quot;#' @param dgm Data-generating mechanism (truth) for simulation.&quot;                                                                                     
[331] &quot;#' @return Data frame for bias plot.&quot;                                                                                                                
[332] &quot;#' @importFrom data.table data.table&quot;                                                                                                                
[333] &quot;#' @export&quot;                                                                                                                                          
[334] &quot;&quot;                                                                                                                                                    
[335] &quot;get_dfPlot&lt;-function(res,dgm){&quot;                                                                                                                      
[336] &quot;  hrH_true&lt;-dgm$hr.H.true&quot;                                                                                                                           
[337] &quot;  hrHc_true&lt;-dgm$hr.Hc.true&quot;                                                                                                                         
[338] &quot;  if(est.loghr &amp; est.scale==\&quot;loghr\&quot;){&quot;                                                                                                             
[339] &quot;    hrH_true&lt;-log(dgm$hr.H.true)&quot;                                                                                                                    
[340] &quot;    hrHc_true&lt;-log(dgm$hr.Hc.true)&quot;                                                                                                                  
[341] &quot;  }&quot;                                                                                                                                                 
[342] &quot;  res_new&lt;-within(res,{&quot;                                                                                                                             
[343] &quot;    b1H_1&lt;-100*(H1.bc-H_true)/H_true&quot;                                                                                                                
[344] &quot;    b1H_2&lt;-100*(H1.bc-hatH_causal)/hatH_causal&quot;                                                                                                      
[345] &quot;    b1H_3&lt;-100*(H1.bc-hrH_true)/hrH_true&quot;                                                                                                            
[346] &quot;&quot;                                                                                                                                                    
[347] &quot;    b2H_1&lt;-100*(H2.bc-H_true)/H_true&quot;                                                                                                                
[348] &quot;    b2H_2&lt;-100*(H2.bc-hatH_causal)/hatH_causal&quot;                                                                                                      
[349] &quot;    b2H_3&lt;-100*(H2.bc-hrH_true)/hrH_true&quot;                                                                                                            
[350] &quot;&quot;                                                                                                                                                    
[351] &quot;    b0H_1&lt;-100*(H_obs-H_true)/H_true&quot;                                                                                                                
[352] &quot;    b0H_2&lt;-100*(H_obs-hatH_causal)/hatH_causal&quot;                                                                                                      
[353] &quot;    b0H_3&lt;-100*(H_obs-hrH_true)/hrH_true&quot;                                                                                                            
[354] &quot;  }&quot;                                                                                                                                                 
[355] &quot;  )&quot;                                                                                                                                                 
[356] &quot;&quot;                                                                                                                                                    
[357] &quot;  df_bc&lt;-NULL&quot;                                                                                                                                       
[358] &quot;  # hr(H_true) target&quot;                                                                                                                               
[359] &quot;  res_new&lt;-data.table(res_new)&quot;                                                                                                                      
[360] &quot;  df_res&lt;-res_new[,c(\&quot;b1H_1\&quot;)]&quot;                                                                                                                    
[361] &quot;  df_res$est&lt;-\&quot;BC_1\&quot;&quot;                                                                                                                              
[362] &quot;  df_res$target&lt;-\&quot;H_true\&quot;&quot;                                                                                                                         
[363] &quot;  names(df_res)[1]&lt;-\&quot;bias\&quot;&quot;                                                                                                                        
[364] &quot;  df_bc&lt;-rbind(df_bc,df_res)&quot;                                                                                                                        
[365] &quot;&quot;                                                                                                                                                    
[366] &quot;  df_res&lt;-res_new[,c(\&quot;b2H_1\&quot;)]&quot;                                                                                                                    
[367] &quot;  df_res$est&lt;-\&quot;BC_2\&quot;&quot;                                                                                                                              
[368] &quot;  df_res$target&lt;-\&quot;H_true\&quot;&quot;                                                                                                                         
[369] &quot;  names(df_res)[1]&lt;-\&quot;bias\&quot;&quot;                                                                                                                        
[370] &quot;  df_bc&lt;-rbind(df_bc,df_res)&quot;                                                                                                                        
[371] &quot;&quot;                                                                                                                                                    
[372] &quot;  df_res&lt;-res_new[,c(\&quot;b0H_1\&quot;)]&quot;                                                                                                                    
[373] &quot;  df_res$est&lt;-\&quot;Obs\&quot;&quot;                                                                                                                               
[374] &quot;  df_res$target&lt;-\&quot;H_true\&quot;&quot;                                                                                                                         
[375] &quot;  names(df_res)[1]&lt;-\&quot;bias\&quot;&quot;                                                                                                                        
[376] &quot;  df_bc&lt;-rbind(df_bc,df_res)&quot;                                                                                                                        
[377] &quot;&quot;                                                                                                                                                    
[378] &quot;  # hatH_causal target&quot;                                                                                                                              
[379] &quot;  df_res&lt;-res_new[,c(\&quot;b1H_2\&quot;)]&quot;                                                                                                                    
[380] &quot;  df_res$est&lt;-\&quot;BC_1\&quot;&quot;                                                                                                                              
[381] &quot;  df_res$target&lt;-\&quot;H_po\&quot;&quot;                                                                                                                           
[382] &quot;  names(df_res)[1]&lt;-\&quot;bias\&quot;&quot;                                                                                                                        
[383] &quot;  df_bc&lt;-rbind(df_bc,df_res)&quot;                                                                                                                        
[384] &quot;&quot;                                                                                                                                                    
[385] &quot;  df_res&lt;-res_new[,c(\&quot;b2H_2\&quot;)]&quot;                                                                                                                    
[386] &quot;  df_res$est&lt;-\&quot;BC_2\&quot;&quot;                                                                                                                              
[387] &quot;  df_res$target&lt;-\&quot;H_po\&quot;&quot;                                                                                                                           
[388] &quot;  names(df_res)[1]&lt;-\&quot;bias\&quot;&quot;                                                                                                                        
[389] &quot;  df_bc&lt;-rbind(df_bc,df_res)&quot;                                                                                                                        
[390] &quot;&quot;                                                                                                                                                    
[391] &quot;  df_res&lt;-res_new[,c(\&quot;b0H_2\&quot;)]&quot;                                                                                                                    
[392] &quot;  df_res$est&lt;-\&quot;Obs\&quot;&quot;                                                                                                                               
[393] &quot;  df_res$target&lt;-\&quot;H_po\&quot;&quot;                                                                                                                           
[394] &quot;  names(df_res)[1]&lt;-\&quot;bias\&quot;&quot;                                                                                                                        
[395] &quot;  df_bc&lt;-rbind(df_bc,df_res)&quot;                                                                                                                        
[396] &quot;&quot;                                                                                                                                                    
[397] &quot;  # H_causal fixed&quot;                                                                                                                                  
[398] &quot;  df_res&lt;-res_new[,c(\&quot;b1H_3\&quot;)]&quot;                                                                                                                    
[399] &quot;  df_res$est&lt;-\&quot;BC_1\&quot;&quot;                                                                                                                              
[400] &quot;  df_res$target&lt;-\&quot;H_fixed\&quot;&quot;                                                                                                                        
[401] &quot;  names(df_res)[1]&lt;-\&quot;bias\&quot;&quot;                                                                                                                        
[402] &quot;  df_bc&lt;-rbind(df_bc,df_res)&quot;                                                                                                                        
[403] &quot;&quot;                                                                                                                                                    
[404] &quot;  df_res&lt;-res_new[,c(\&quot;b2H_3\&quot;)]&quot;                                                                                                                    
[405] &quot;  df_res$est&lt;-\&quot;BC_2\&quot;&quot;                                                                                                                              
[406] &quot;  df_res$target&lt;-\&quot;H_fixed\&quot;&quot;                                                                                                                        
[407] &quot;  names(df_res)[1]&lt;-\&quot;bias\&quot;&quot;                                                                                                                        
[408] &quot;  df_bc&lt;-rbind(df_bc,df_res)&quot;                                                                                                                        
[409] &quot;&quot;                                                                                                                                                    
[410] &quot;  df_res&lt;-res_new[,c(\&quot;b0H_3\&quot;)]&quot;                                                                                                                    
[411] &quot;  df_res$est&lt;-\&quot;Obs\&quot;&quot;                                                                                                                               
[412] &quot;  df_res$target&lt;-\&quot;H_fixed\&quot;&quot;                                                                                                                        
[413] &quot;  names(df_res)[1]&lt;-\&quot;bias\&quot;&quot;                                                                                                                        
[414] &quot;  df_bc&lt;-rbind(df_bc,df_res)&quot;                                                                                                                        
[415] &quot;  return(df_bc)&quot;                                                                                                                                     
[416] &quot;}&quot;                                                                                                                                                   
[417] &quot;&quot;                                                                                                                                                    
[418] &quot;#' Variance Summary for Bootstrap Results&quot;                                                                                                           
[419] &quot;#'&quot;                                                                                                                                                  
[420] &quot;#' Summarizes variance and coverage for bootstrap results.&quot;                                                                                          
[421] &quot;#'&quot;                                                                                                                                                  
[422] &quot;#' @param res Data frame of results.&quot;                                                                                                                
[423] &quot;#' @return Data frame with summary statistics.&quot;                                                                                                      
[424] &quot;#' @export&quot;                                                                                                                                          
[425] &quot;&quot;                                                                                                                                                    
[426] &quot;var_summary&lt;-function(res){&quot;                                                                                                                         
[427] &quot;  df_var&lt;-NULL&quot;                                                                                                                                      
[428] &quot;  # BC1 SD and Avg(est(sd))&quot;                                                                                                                         
[429] &quot;  aa&lt;-with(res,sqrt(var(H1.bc,na.rm=TRUE)))&quot;                                                                                                         
[430] &quot;  bb&lt;-with(res,mean(seH1.bc,na.rm=TRUE))&quot;                                                                                                            
[431] &quot;  cc&lt;-with(res,mean(H1.bc,na.rm=TRUE))&quot;                                                                                                              
[432] &quot;  dd&lt;-with(res,mean(H1_cover1,na.rm=TRUE))&quot;                                                                                                          
[433] &quot;  ee&lt;-with(res,mean(H1_cover2,na.rm=TRUE))&quot;                                                                                                          
[434] &quot;  ff&lt;-with(res,mean(H1_cover3,na.rm=TRUE))&quot;                                                                                                          
[435] &quot;  gg&lt;-with(res,mean(H1_length,na.rm=TRUE))&quot;                                                                                                          
[436] &quot;  df_var&lt;-rbind(df_var,c(cc,aa,bb,dd,ee,ff,gg))&quot;                                                                                                     
[437] &quot;&quot;                                                                                                                                                    
[438] &quot;  aa&lt;-with(res,sqrt(var(H2.bc,na.rm=TRUE)))&quot;                                                                                                         
[439] &quot;  bb&lt;-with(res,mean(seH2.bc,na.rm=TRUE))&quot;                                                                                                            
[440] &quot;  cc&lt;-with(res,mean(H2.bc,na.rm=TRUE))&quot;                                                                                                              
[441] &quot;  dd&lt;-with(res,mean(H2_cover1,na.rm=TRUE))&quot;                                                                                                          
[442] &quot;  ee&lt;-with(res,mean(H2_cover2,na.rm=TRUE))&quot;                                                                                                          
[443] &quot;  ff&lt;-with(res,mean(H2_cover3,na.rm=TRUE))&quot;                                                                                                          
[444] &quot;  gg&lt;-with(res,mean(H2_length,na.rm=TRUE))&quot;                                                                                                          
[445] &quot;  df_var&lt;-rbind(df_var,c(cc,aa,bb,dd,ee,ff,gg))&quot;                                                                                                     
[446] &quot;&quot;                                                                                                                                                    
[447] &quot;  aa&lt;-with(res,sqrt(var(Hc1.bc,na.rm=TRUE)))&quot;                                                                                                        
[448] &quot;  bb&lt;-with(res,mean(seHc1.bc,na.rm=TRUE))&quot;                                                                                                           
[449] &quot;  cc&lt;-with(res,mean(Hc1.bc,na.rm=TRUE))&quot;                                                                                                             
[450] &quot;  dd&lt;-with(res,mean(Hc1_cover1,na.rm=TRUE))&quot;                                                                                                         
[451] &quot;  ee&lt;-with(res,mean(Hc1_cover2,na.rm=TRUE))&quot;                                                                                                         
[452] &quot;  ff&lt;-with(res,mean(Hc1_cover3,na.rm=TRUE))&quot;                                                                                                         
[453] &quot;  gg&lt;-with(res,mean(Hc1_length,na.rm=TRUE))&quot;                                                                                                         
[454] &quot;  df_var&lt;-rbind(df_var,c(cc,aa,bb,dd,ee,ff,gg))&quot;                                                                                                     
[455] &quot;&quot;                                                                                                                                                    
[456] &quot;  aa&lt;-with(res,sqrt(var(Hc2.bc,na.rm=TRUE)))&quot;                                                                                                        
[457] &quot;  bb&lt;-with(res,mean(seHc2.bc,na.rm=TRUE))&quot;                                                                                                           
[458] &quot;  cc&lt;-with(res,mean(Hc2.bc,na.rm=TRUE))&quot;                                                                                                             
[459] &quot;  dd&lt;-with(res,mean(Hc2_cover1,na.rm=TRUE))&quot;                                                                                                         
[460] &quot;  ee&lt;-with(res,mean(Hc2_cover2,na.rm=TRUE))&quot;                                                                                                         
[461] &quot;  ff&lt;-with(res,mean(Hc2_cover3,na.rm=TRUE))&quot;                                                                                                         
[462] &quot;  gg&lt;-with(res,mean(Hc2_length,na.rm=TRUE))&quot;                                                                                                         
[463] &quot;  df_var&lt;-rbind(df_var,c(cc,aa,bb,dd,ee,ff,gg))&quot;                                                                                                     
[464] &quot;&quot;                                                                                                                                                    
[465] &quot;  colnames(df_var)&lt;-c(\&quot;Est\&quot;,\&quot;SD\&quot;,\&quot;Est(SD)\&quot;,\&quot;C1\&quot;,\&quot;C2\&quot;,\&quot;C3\&quot;,\&quot;L\&quot;)&quot;                                                                        
[466] &quot;  rownames(df_var)&lt;-c(\&quot;H1_bc\&quot;,\&quot;H2_bc\&quot;,\&quot;Hc1_bc\&quot;,\&quot;Hc2_bc\&quot;)&quot;                                                                                    
[467] &quot;  return(round(df_var,digits=3))&quot;                                                                                                                    
[468] &quot;}&quot;                                                                                                                                                   
[469] &quot;&quot;                                                                                                                                                    
[470] &quot;&quot;                                                                                                                                                    
[471] &quot;#' Confidence Interval for Cox Model Estimate&quot;                                                                                                       
[472] &quot;#'&quot;                                                                                                                                                  
[473] &quot;#' Calculates confidence interval and coverage for Cox model estimate.&quot;                                                                              
[474] &quot;#'&quot;                                                                                                                                                  
[475] &quot;#' @param df Data frame.&quot;                                                                                                                            
[476] &quot;#' @param est Character. Name of estimate column.&quot;                                                                                                   
[477] &quot;#' @param se Character. Name of standard error column.&quot;                                                                                              
[478] &quot;#' @param target Numeric or character. Target value or column name.&quot;                                                                                 
[479] &quot;#' @param alpha Numeric significance level (default: 0.025).&quot;                                                                                        
[480] &quot;#' @param digits Integer. Number of digits for rounding (default: 3).&quot;                                                                               
[481] &quot;#' @return List with lower bound, upper bound, and coverage indicator.&quot;                                                                              
[482] &quot;#' @export&quot;                                                                                                                                          
[483] &quot;&quot;                                                                                                                                                    
[484] &quot;getci_Cox&lt;-function(df,est,se,target,alpha=0.025,digits=3){&quot;                                                                                         
[485] &quot;  a&lt;-df[est]&quot;                                                                                                                                        
[486] &quot;  b&lt;-df[se]&quot;                                                                                                                                         
[487] &quot;  if(!is.numeric(target)){&quot;                                                                                                                          
[488] &quot;    c&lt;-df[target]&quot;                                                                                                                                   
[489] &quot;  }&quot;                                                                                                                                                 
[490] &quot;  if(is.numeric(target)){&quot;                                                                                                                           
[491] &quot;    c&lt;-target&quot;                                                                                                                                       
[492] &quot;  }&quot;                                                                                                                                                 
[493] &quot;  log_lb&lt;-log(a)-qnorm(0.975)*(b/a)&quot;                                                                                                                 
[494] &quot;  log_ub&lt;-log(a)+qnorm(0.975)*(b/a)&quot;                                                                                                                 
[495] &quot;  lb&lt;-exp(log_lb)&quot;                                                                                                                                   
[496] &quot;  ub&lt;-exp(log_ub)&quot;                                                                                                                                   
[497] &quot;  cov&lt;-ifelse(c&gt;=lb &amp; c&lt;=ub,1,0)&quot;                                                                                                                    
[498] &quot;  return(list(lb=round(lb,3),ub=round(ub,3),cover=cov))&quot;                                                                                             
[499] &quot;}&quot;                                                                                                                                                   
[500] &quot;&quot;                                                                                                                                                    
[501] &quot;#' Summary Statistic for Data Frame Column&quot;                                                                                                          
[502] &quot;#'&quot;                                                                                                                                                  
[503] &quot;#' Returns mean and standard deviation for a column, formatted as a string.&quot;                                                                         
[504] &quot;#'&quot;                                                                                                                                                  
[505] &quot;#' @param df Data frame.&quot;                                                                                                                            
[506] &quot;#' @param name Character. Column name.&quot;                                                                                                              
[507] &quot;#' @param sigdig Integer. Number of significant digits (default: 2).&quot;                                                                                
[508] &quot;#' @param includeSD Logical. Include \&quot;SD=\&quot; in output (default: FALSE).&quot;                                                                            
[509] &quot;#' @param showSD Logical. Show SD in output (default: TRUE).&quot;                                                                                        
[510] &quot;#' @return Character string with mean and SD.&quot;                                                                                                       
[511] &quot;#' @export&quot;                                                                                                                                          
[512] &quot;&quot;                                                                                                                                                    
[513] &quot;SummaryStat&lt;-function(df,name,sigdig=2,includeSD=FALSE,showSD=TRUE){&quot;                                                                                
[514] &quot;  if(is.data.table(df)){&quot;                                                                                                                            
[515] &quot;    df&lt;-as.data.frame(df)&quot;                                                                                                                           
[516] &quot;  }&quot;                                                                                                                                                 
[517] &quot;  # include \&quot;SD=\&quot; in output&quot;                                                                                                                       
[518] &quot;  if(!includeSD){&quot;                                                                                                                                   
[519] &quot;    temp&lt;-na.omit(df[,c(name)])&quot;                                                                                                                     
[520] &quot;    m&lt;-round(mean(temp),sigdig)&quot;                                                                                                                     
[521] &quot;    sig&lt;-round(sqrt(var(temp)),sigdig)&quot;                                                                                                              
[522] &quot;    # Check if binary&quot;                                                                                                                               
[523] &quot;    if(all(as.numeric(temp) %in% c(0,1))){&quot;                                                                                                          
[524] &quot;      sig&lt;-round(sqrt(m*(1-m)/length(temp)),sigdig)&quot;                                                                                                 
[525] &quot;    }&quot;                                                                                                                                               
[526] &quot;    if(sigdig&lt;=4 &amp; m&lt;=0.001) m&lt;-\&quot;&lt;0.001\&quot;&quot;                                                                                                          
[527] &quot;    if(sigdig&lt;=4 &amp; sig&lt;=0.001) sig&lt;-\&quot;&lt;0.001\&quot;&quot;                                                                                                      
[528] &quot;    out&lt;-paste0(m,\&quot; (\&quot;)&quot;                                                                                                                           
[529] &quot;    out&lt;-paste0(out,sig)&quot;                                                                                                                            
[530] &quot;    out&lt;-paste0(out,\&quot;)\&quot;)&quot;                                                                                                                          
[531] &quot;  }&quot;                                                                                                                                                 
[532] &quot;  if(includeSD){&quot;                                                                                                                                    
[533] &quot;    temp&lt;-na.omit(df[,c(name)])&quot;                                                                                                                     
[534] &quot;    m&lt;-round(mean(temp),sigdig)&quot;                                                                                                                     
[535] &quot;    sig&lt;-round(sqrt(var(temp)),sigdig)&quot;                                                                                                              
[536] &quot;    # Check if binary&quot;                                                                                                                               
[537] &quot;    if(all(as.numeric(temp) %in% c(0,1))){&quot;                                                                                                          
[538] &quot;      sig&lt;-round(sqrt(m*(1-m)/length(m)),sigdig)&quot;                                                                                                    
[539] &quot;    }&quot;                                                                                                                                               
[540] &quot;    if(sigdig&lt;=4 &amp; m&lt;=0.001) m&lt;-\&quot;&lt;0.001\&quot;&quot;                                                                                                          
[541] &quot;    if(sigdig&lt;=4 &amp; sig&lt;=0.001) sig&lt;-\&quot;&lt;0.001\&quot;&quot;                                                                                                      
[542] &quot;    out&lt;-paste0(m,\&quot; (SD=\&quot;)&quot;                                                                                                                        
[543] &quot;    out&lt;-paste0(out,sig)&quot;                                                                                                                            
[544] &quot;    out&lt;-paste0(out,\&quot;)\&quot;)&quot;                                                                                                                          
[545] &quot;  }&quot;                                                                                                                                                 
[546] &quot;  if(!showSD) out&lt;-c(m)&quot;                                                                                                                             
[547] &quot;  return(out)&quot;                                                                                                                                       
[548] &quot;}&quot;                                                                                                                                                   
[549] &quot;&quot;                                                                                                                                                    
[550] &quot;#' Difference in Rate Between Two Data Frames&quot;                                                                                                       
[551] &quot;#'&quot;                                                                                                                                                  
[552] &quot;#' Calculates the difference in mean rate for a column between two data frames.&quot;                                                                     
[553] &quot;#'&quot;                                                                                                                                                  
[554] &quot;#' @param df1 First data frame.&quot;                                                                                                                     
[555] &quot;#' @param df2 Second data frame.&quot;                                                                                                                    
[556] &quot;#' @param name Character. Column name.&quot;                                                                                                              
[557] &quot;#' @param sigdig Integer. Number of significant digits (default: 2).&quot;                                                                                
[558] &quot;#' @return Numeric value of difference in rate (percent).&quot;                                                                                           
[559] &quot;#' @export&quot;                                                                                                                                          
[560] &quot;&quot;                                                                                                                                                    
[561] &quot;DiffRate&lt;-function(df1,df2,name,sigdig=2){&quot;                                                                                                          
[562] &quot;  if(is.data.table(df1)){&quot;                                                                                                                           
[563] &quot;    df1&lt;-as.data.frame(df1)&quot;                                                                                                                         
[564] &quot;    df2&lt;-as.data.frame(df2)&quot;                                                                                                                         
[565] &quot;  }&quot;                                                                                                                                                 
[566] &quot;  temp&lt;-na.omit(df1[,c(name)])&quot;                                                                                                                      
[567] &quot;  m1&lt;-mean(temp)&quot;                                                                                                                                    
[568] &quot;  temp&lt;-na.omit(df2[,c(name)])&quot;                                                                                                                      
[569] &quot;  m2&lt;-mean(temp)&quot;                                                                                                                                    
[570] &quot;  out&lt;-round(100*(m2-m1),1)&quot;                                                                                                                         
[571] &quot;  return(out)&quot;                                                                                                                                       
[572] &quot;}&quot;                                                                                                                                                   
[573] &quot;&quot;                                                                                                                                                    
[574] &quot;#' Power Calculation for Subgroup Size&quot;                                                                                                              
[575] &quot;#'&quot;                                                                                                                                                  
[576] &quot;#' Calculates power (rejection rate) for subgroups above a minimum size.&quot;                                                                            
[577] &quot;#'&quot;                                                                                                                                                  
[578] &quot;#' @param df Data frame.&quot;                                                                                                                            
[579] &quot;#' @param minsize Integer. Minimum subgroup size (default: 0).&quot;                                                                                      
[580] &quot;#' @param sigdig Integer. Number of significant digits (default: 3).&quot;                                                                                
[581] &quot;#' @return Numeric value of power (rejection rate).&quot;                                                                                                 
[582] &quot;#' @export&quot;                                                                                                                                          
[583] &quot;&quot;                                                                                                                                                    
[584] &quot;pow_size&lt;-function(df,minsize=0,sigdig=3){&quot;                                                                                                          
[585] &quot;  rej&lt;-with(df,mean(rej12 &amp; size.Hc&gt;=minsize))&quot;                                                                                                      
[586] &quot;  return(round(rej,sigdig))&quot;                                                                                                                         
[587] &quot;}&quot;                                                                                                                                                   
[588] &quot;&quot;                                                                                                                                                    
</code></pre></div><div class="user-msg"><strong>User:</strong> Continue answering the question based on the results.</div><div class="bot-msg"><strong>ADW:</strong> <p>Here is a summary of the functions in <code>forestsearch_bootstrap_helpers.R</code>:</p>
<hr />
<h3><code>forestsearch_bootstrap_helpers.R</code> ‚Äî Main Functions</h3>
<ol>
<li><strong>count.id</strong></li>
<li>
<p>Counts the number of times an ID appears in a bootstrap sample.</p>
</li>
<li>
<p><strong>calc_cov</strong></p>
</li>
<li>
<p>Calculates the covariance between a vector and bootstrap estimates.</p>
</li>
<li>
<p><strong>ci_est</strong></p>
</li>
<li>
<p>Computes confidence intervals for an estimate, optionally on the log(HR) scale, and supports both HR and 1/HR scales.</p>
</li>
<li>
<p><strong>get_dfRes</strong></p>
</li>
<li>
<p>Calculates confidence intervals and bias-corrected estimates for bootstrap results, returning a data.table with all relevant statistics for up to two bias-corrected estimates.</p>
</li>
<li>
<p><strong>get_targetEst</strong></p>
</li>
<li>
<p>Calculates the target estimate and standard error for bootstrap samples, with options for standard or bias-corrected covariance estimation.</p>
</li>
<li>
<p><strong>get_Cox_sg</strong></p>
</li>
<li>
<p>Fits a Cox model for a subgroup and returns the estimate and standard error, supporting both log(HR) and HR scales.</p>
</li>
<li>
<p><strong>ci_cover</strong></p>
</li>
<li>
<p>Checks if a target value is covered by a confidence interval (single or vectorized).</p>
</li>
<li>
<p><strong>getCIs</strong></p>
</li>
<li>
<p>Calculates confidence intervals for two bootstrap targets, returning estimates, standard errors, and CIs.</p>
</li>
<li>
<p><strong>get_dfPlot</strong></p>
</li>
<li>
<p>Prepares a data frame for plotting bias in bootstrap estimates, including several bias metrics relative to different targets.</p>
</li>
<li>
<p><strong>var_summary</strong></p>
<ul>
<li>Summarizes variance and coverage for bootstrap results, returning a table of means, SDs, and coverage rates for different estimates.</li>
</ul>
</li>
<li>
<p><strong>getci_Cox</strong></p>
<ul>
<li>Calculates confidence interval and coverage for a Cox model estimate.</li>
</ul>
</li>
<li>
<p><strong>SummaryStat</strong></p>
<ul>
<li>Returns mean and standard deviation for a column, formatted as a string, with options for binary variables and custom formatting.</li>
</ul>
</li>
<li>
<p><strong>DiffRate</strong></p>
<ul>
<li>Calculates the difference in mean rate for a column between two data frames, as a percent.</li>
</ul>
</li>
<li>
<p><strong>pow_size</strong></p>
<ul>
<li>Calculates power (rejection rate) for subgroups above a minimum size.</li>
</ul>
</li>
</ol>
<hr />
<p><strong>General Purpose:</strong><br />
These functions provide a comprehensive set of tools for bootstrap-based inference, bias correction, confidence interval calculation, and summary statistics for subgroup and survival analysis, especially in the context of ForestSearch or similar frameworks.</p>
<p>If you need to see how to use any of these functions, or want to run/test them with data, please specify your next step.</p></div><div class="user-msg"><strong>User:</strong> üìÅ[forestsearch_bootstrap_dofuture.R]</div><div class="user-msg"><strong>User:</strong> please inspect</div><div class="bot-msg"><strong>ADW:</strong> <p>üü¢Working:</p>
<pre><code class="language-R"># Read and display the contents of the forestsearch_bootstrap_dofuture.R file
bs_dofuture_content &lt;- readLines('forestsearch_bootstrap_dofuture.R')
bs_dofuture_content
</code></pre></div><div class="bot-msg"><strong>ADW:</strong> <p>‚úîÔ∏èTerminal output:</p>
<pre><code class="language-shell">  [1] &quot;&quot;                                                                                                                                                                                      
  [2] &quot;#' Ensure Required Packages Are Installed and Loaded&quot;                                                                                                                                  
  [3] &quot;#'&quot;                                                                                                                                                                                    
  [4] &quot;#' Installs and loads required packages if not already available.&quot;                                                                                                                     
  [5] &quot;#'&quot;                                                                                                                                                                                    
  [6] &quot;#' @param pkgs Character vector of package names.&quot;                                                                                                                                     
  [7] &quot;#' @return None. Packages are loaded into the session.&quot;                                                                                                                                
  [8] &quot;#' @export&quot;                                                                                                                                                                            
  [9] &quot;&quot;                                                                                                                                                                                      
 [10] &quot;ensure_packages &lt;- function(pkgs) {&quot;                                                                                                                                                   
 [11] &quot;  for (pkg in pkgs) {&quot;                                                                                                                                                                 
 [12] &quot;    if (!requireNamespace(pkg, quietly = TRUE)) {&quot;                                                                                                                                     
 [13] &quot;      install.packages(pkg)&quot;                                                                                                                                                           
 [14] &quot;    }&quot;                                                                                                                                                                                 
 [15] &quot;    library(pkg, character.only = TRUE)&quot;                                                                                                                                               
 [16] &quot;  }&quot;                                                                                                                                                                                   
 [17] &quot;}&quot;                                                                                                                                                                                     
 [18] &quot;&quot;                                                                                                                                                                                      
 [19] &quot;#' Build Cox Model Formula&quot;                                                                                                                                                            
 [20] &quot;#'&quot;                                                                                                                                                                                    
 [21] &quot;#' Constructs a Cox model formula from variable names.&quot;                                                                                                                                
 [22] &quot;#'&quot;                                                                                                                                                                                    
 [23] &quot;#' @param outcome.name Character. Name of outcome variable.&quot;                                                                                                                           
 [24] &quot;#' @param event.name Character. Name of event indicator variable.&quot;                                                                                                                     
 [25] &quot;#' @param treat.name Character. Name of treatment variable.&quot;                                                                                                                           
 [26] &quot;#' @return An R formula object for Cox regression.&quot;                                                                                                                                    
 [27] &quot;#' @export&quot;                                                                                                                                                                            
 [28] &quot;&quot;                                                                                                                                                                                      
 [29] &quot;build_cox_formula &lt;- function(outcome.name, event.name, treat.name) {&quot;                                                                                                                 
 [30] &quot;  sf &lt;- paste0(\&quot;Surv(\&quot;, outcome.name, \&quot;,\&quot;, event.name, \&quot;) ~ \&quot;, treat.name)&quot;                                                                                                      
 [31] &quot;  as.formula(sf)&quot;                                                                                                                                                                      
 [32] &quot;}&quot;                                                                                                                                                                                     
 [33] &quot;&quot;                                                                                                                                                                                      
 [34] &quot;#' Fit Cox Models for Subgroups&quot;                                                                                                                                                       
 [35] &quot;#'&quot;                                                                                                                                                                                    
 [36] &quot;#' Fits Cox models for two subgroups defined by treatment recommendation.&quot;                                                                                                             
 [37] &quot;#'&quot;                                                                                                                                                                                    
 [38] &quot;#' @param df Data frame.&quot;                                                                                                                                                              
 [39] &quot;#' @param formula Cox model formula.&quot;                                                                                                                                                  
 [40] &quot;#' @return List with HR and SE for each subgroup.&quot;                                                                                                                                     
 [41] &quot;#' @export&quot;                                                                                                                                                                            
 [42] &quot;&quot;                                                                                                                                                                                      
 [43] &quot;fit_cox_models &lt;- function(df, formula) {&quot;                                                                                                                                             
 [44] &quot;  fitH &lt;- get_Cox_sg(df_sg = subset(df, treat.recommend == 0), cox.formula = formula)&quot;                                                                                                 
 [45] &quot;  fitHc &lt;- get_Cox_sg(df_sg = subset(df, treat.recommend == 1), cox.formula = formula)&quot;                                                                                                
 [46] &quot;  list(H_obs = fitH$est_obs, seH_obs = fitH$se_obs, Hc_obs = fitHc$est_obs, seHc_obs = fitHc$se_obs)&quot;                                                                                  
 [47] &quot;}&quot;                                                                                                                                                                                     
 [48] &quot;&quot;                                                                                                                                                                                      
 [49] &quot;&quot;                                                                                                                                                                                      
 [50] &quot;#' Bootstrap Ystar Matrix&quot;                                                                                                                                                             
 [51] &quot;#'&quot;                                                                                                                                                                                    
 [52] &quot;#' Generates a bootstrap matrix for Ystar using parallel processing.&quot;                                                                                                                  
 [53] &quot;#'&quot;                                                                                                                                                                                    
 [54] &quot;#' @param df Data frame.&quot;                                                                                                                                                              
 [55] &quot;#' @param nb_boots Integer. Number of bootstrap samples.&quot;                                                                                                                              
 [56] &quot;#' @return Matrix of bootstrap samples.&quot;                                                                                                                                               
 [57] &quot;#' @importFrom foreach foreach %dopar%&quot;                                                                                                                                                
 [58] &quot;#' @export&quot;                                                                                                                                                                            
 [59] &quot;&quot;                                                                                                                                                                                      
 [60] &quot;bootstrap_ystar &lt;- function(df, nb_boots) {&quot;                                                                                                                                           
 [61] &quot;  NN &lt;- nrow(df)&quot;                                                                                                                                                                      
 [62] &quot;  foreach::foreach(&quot;                                                                                                                                                                   
 [63] &quot;    boot = seq_len(nb_boots),&quot;                                                                                                                                                         
 [64] &quot;    .options.future = list(seed = TRUE),&quot;                                                                                                                                              
 [65] &quot;    .combine = \&quot;rbind\&quot;,&quot;                                                                                                                                                             
 [66] &quot;    .errorhandling = \&quot;pass\&quot;&quot;                                                                                                                                                         
 [67] &quot;  ) %dofuture% {&quot;                                                                                                                                                                      
 [68] &quot;    set.seed(8316951 + boot * 100)&quot;                                                                                                                                                    
 [69] &quot;    in_boot &lt;- sample.int(NN, size = NN, replace = TRUE)&quot;                                                                                                                              
 [70] &quot;    df_boot &lt;- df[in_boot, ]&quot;                                                                                                                                                          
 [71] &quot;    df_boot$id_boot &lt;- seq_len(nrow(df_boot))&quot;                                                                                                                                         
 [72] &quot;    ystar &lt;- unlist(lapply(df$id, count.id, dfb = df_boot))&quot;                                                                                                                           
 [73] &quot;    return(ystar)&quot;                                                                                                                                                                     
 [74] &quot;  }&quot;                                                                                                                                                                                   
 [75] &quot;}&quot;                                                                                                                                                                                     
 [76] &quot;&quot;                                                                                                                                                                                      
 [77] &quot;#' Bootstrap Results for ForestSearch&quot;                                                                                                                                                 
 [78] &quot;#'&quot;                                                                                                                                                                                    
 [79] &quot;#' Runs bootstrap analysis for ForestSearch, fitting Cox models and bias correction.&quot;                                                                                                  
 [80] &quot;#'&quot;                                                                                                                                                                                    
 [81] &quot;#' @param fs.est ForestSearch results object.&quot;                                                                                                                                         
 [82] &quot;#' @param df_boot_analysis Data frame for bootstrap analysis.&quot;                                                                                                                         
 [83] &quot;#' @param cox.formula.boot Cox model formula for bootstrap.&quot;                                                                                                                           
 [84] &quot;#' @param nb_boots Integer. Number of bootstrap samples.&quot;                                                                                                                              
 [85] &quot;#' @param show_three Logical. Show details for first three bootstraps.&quot;                                                                                                                
 [86] &quot;#' @param H_obs Numeric. Observed HR for subgroup H.&quot;                                                                                                                                  
 [87] &quot;#' @param Hc_obs Numeric. Observed HR for subgroup Hc.&quot;                                                                                                                                
 [88] &quot;#' @param reset_parallel Logical. Reset parallel plan for bootstrap.&quot;                                                                                                                  
 [89] &quot;#' @param boot_workers Integer. Number of parallel workers.&quot;                                                                                                                           
 [90] &quot;#' @return Data.table with bias-adjusted estimates and search metrics.&quot;                                                                                                                
 [91] &quot;#' @importFrom foreach foreach&quot;                                                                                                                                                        
 [92] &quot;#' @importFrom data.table data.table&quot;                                                                                                                                                  
 [93] &quot;#' @export&quot;                                                                                                                                                                            
 [94] &quot;&quot;                                                                                                                                                                                      
 [95] &quot;bootstrap_results &lt;- function(fs.est, df_boot_analysis, cox.formula.boot, nb_boots, show_three, H_obs, Hc_obs, reset_parallel, boot_workers) {&quot;                                        
 [96] &quot;  NN &lt;- nrow(df_boot_analysis)&quot;                                                                                                                                                        
 [97] &quot;  id0 &lt;- seq_len(NN)&quot;                                                                                                                                                                  
 [98] &quot;  foreach::foreach(&quot;                                                                                                                                                                   
 [99] &quot;    boot = seq_len(nb_boots),&quot;                                                                                                                                                         
[100] &quot;    .options.future = list(seed = TRUE,&quot;                                                                                                                                               
[101] &quot;                           add = c(\&quot;dfnew_boot\&quot;,\&quot;dfnew\&quot;,\&quot;calc_cov\&quot;,  \&quot;calculate_counts\&quot;, \&quot;analyze_subgroups\&quot;, \&quot;calculate_potential_hr\&quot;,\&quot;ci.est\&quot;,\&quot;count.id\&quot;,\&quot;CV_sgs\&quot;,&quot;
[102] &quot;                           \&quot;cox_summary\&quot;,\&quot;df_counting\&quot;,\&quot;double_robust_scores\&quot;, \&quot;extract_subgroup\&quot;,\&quot;format_results\&quot;, \&quot;get_targetEst\&quot;,\&quot;getci_Cox\&quot;,&quot;                        
[103] &quot;                           \&quot;getCIs\&quot;,\&quot;grf.estimates.out\&quot;,\&quot;hrCI_format\&quot;,\&quot;km_summary\&quot;,\&quot;n_pcnt\&quot;,\&quot;plot_subgroup\&quot;,\&quot;plot_weighted_km\&quot;,&quot;                                         
[104] &quot;                           \&quot;prepare_subgroup_data\&quot;,\&quot;quiet\&quot;,\&quot;rmst_calculation\&quot;,\&quot;sg_tables\&quot;,\&quot;sort_subgroups\&quot;,\&quot;SummaryStat\&quot;,\&quot;var_summary\&quot;,&quot;                                 
[105] &quot;                           \&quot;get_FSdata\&quot;, \&quot;dummy\&quot;,\&quot;run_bootstrap\&quot;,&quot;                                                                                                               
[106] &quot;                             \&quot;forestsearch\&quot;, \&quot;forestsearch_bootstrap_dofuture\&quot;,\&quot;get_combinations_info\&quot;,&quot;                                                                         
[107] &quot;                             \&quot;get_dfpred\&quot;,&quot;                                                                                                                                          
[108] &quot;                             \&quot;grf.subg.harm.survival\&quot;,&quot;                                                                                                                              
[109] &quot;                             \&quot;subgroup.search\&quot;,&quot;                                                                                                                                     
[110] &quot;                             \&quot;subgroup.consistency\&quot;,&quot;                                                                                                                                
[111] &quot;                             \&quot;lasso_selection\&quot;,&quot;                                                                                                                                     
[112] &quot;                             \&quot;get_Cox_sg\&quot;,&quot;                                                                                                                                          
[113] &quot;                             \&quot;get_conf_force\&quot;,&quot;                                                                                                                                      
[114] &quot;                             \&quot;filter_by_lassokeep\&quot;,&quot;                                                                                                                                 
[115] &quot;                             \&quot;is.continuous\&quot;,&quot;                                                                                                                                       
[116] &quot;                             \&quot;process_conf_force_expr\&quot;,&quot;                                                                                                                             
[117] &quot;                             \&quot;is_flag_continuous\&quot;,&quot;                                                                                                                                  
[118] &quot;                             \&quot;is_flag_drop\&quot;, \&quot;acm.disjctif\&quot;,  \&quot;acm.util.df2\&quot;, \&quot;acm.util.df\&quot;, \&quot;dummy2\&quot;,\&quot;ztrail\&quot;,\&quot;one.zero\&quot;,&quot;                                              
[119] &quot;                             \&quot;get_dfRes\&quot;, \&quot;get_subgroup_membership\&quot;,&quot;                                                                                                              
[120] &quot;                             \&quot;SG_tab_estimates\&quot;,&quot;                                                                                                                                    
[121] &quot;                             \&quot;prepare_data\&quot;,&quot;                                                                                                                                        
[122] &quot;                             \&quot;run_grf\&quot;,&quot;                                                                                                                                             
[123] &quot;                             \&quot;evaluate_subgroups\&quot;,&quot;                                                                                                                                  
[124] &quot;                             \&quot;summarize_results\&quot;,&quot;                                                                                                                                   
[125] &quot;                              \&quot;clean_data\&quot;, \&quot;qlow\&quot;, \&quot;qhigh\&quot;,\&quot;FS_labels\&quot;,\&quot;thiscut\&quot;,\&quot;get_cut_name\&quot;,&quot;                                                                         
[126] &quot;                             \&quot;bootstrap_results\&quot;, \&quot;remove_redundant_subgroups\&quot;, \&quot;sg_consistency_out\&quot;,\&quot;get_split_hr\&quot;,\&quot;cut_var\&quot;,&quot;                                              
[127] &quot;                             \&quot;bootstrap_ystar\&quot;, \&quot;ensure_packages\&quot;, \&quot;fit_cox_models\&quot;, \&quot;build_cox_formula\&quot;, \&quot;cox.formula.boot\&quot;,&quot;                                               
[128] &quot;                             \&quot;format_CI\&quot;,\&quot;setup_parallel_SGcons\&quot;, \&quot;get_covs_in\&quot;, \&quot;extract_idx_flagredundancy\&quot;&quot;                                                                 
[129] &quot;                           )),&quot;                                                                                                                                                        
[130] &quot;    .combine = \&quot;rbind\&quot;,&quot;                                                                                                                                                             
[131] &quot;    .errorhandling = \&quot;pass\&quot;&quot;                                                                                                                                                         
[132] &quot;  ) %dofuture% {&quot;                                                                                                                                                                      
[133] &quot;    show3 &lt;- FALSE&quot;                                                                                                                                                                    
[134] &quot;    if (show_three) show3 &lt;- (boot &lt;= 3)&quot;                                                                                                                                              
[135] &quot;    set.seed(8316951 + boot * 100)&quot;                                                                                                                                                    
[136] &quot;    in_boot &lt;- sample.int(NN, size = NN, replace = TRUE)&quot;                                                                                                                              
[137] &quot;    df_boot &lt;- df_boot_analysis[in_boot, ]&quot;                                                                                                                                            
[138] &quot;    df_boot$id_boot &lt;- seq_len(nrow(df_boot))&quot;                                                                                                                                         
[139] &quot;&quot;                                                                                                                                                                                      
[140] &quot;    # Bootstrap data evaluated at H: H_star&quot;                                                                                                                                           
[141] &quot;    fitH_star &lt;- get_Cox_sg(df_sg = subset(df_boot, treat.recommend == 0), cox.formula = cox.formula.boot, est.loghr = TRUE)&quot;                                                          
[142] &quot;    H_star &lt;- fitH_star$est_obs&quot;                                                                                                                                                       
[143] &quot;    fitHc_star &lt;- get_Cox_sg(df_sg = subset(df_boot, treat.recommend == 1), cox.formula = cox.formula.boot, est.loghr = TRUE)&quot;                                                         
[144] &quot;    Hc_star &lt;- fitHc_star$est_obs&quot;                                                                                                                                                     
[145] &quot;&quot;                                                                                                                                                                                      
[146] &quot;    # Bias corrections&quot;                                                                                                                                                                
[147] &quot;    H_biasadj_1 &lt;- H_biasadj_2 &lt;- NA&quot;                                                                                                                                                  
[148] &quot;    Hc_biasadj_1 &lt;- Hc_biasadj_2 &lt;- NA&quot;                                                                                                                                                
[149] &quot;    tmins_search &lt;- NA&quot;                                                                                                                                                                
[150] &quot;    max_sg_est &lt;- NA&quot;                                                                                                                                                                  
[151] &quot;    prop_maxk &lt;- NA&quot;                                                                                                                                                                   
[152] &quot;    L &lt;- NA&quot;                                                                                                                                                                           
[153] &quot;    max_count &lt;- NA&quot;                                                                                                                                                                   
[154] &quot;    # Drop initial confounders&quot;                                                                                                                                                        
[155] &quot;    drop.vars &lt;- c(fs.est$confounders.candidate, \&quot;treat.recommend\&quot;)&quot;                                                                                                                 
[156] &quot;    dfnew &lt;- df_boot_analysis[, !(names(df_boot_analysis) %in% drop.vars)]&quot;                                                                                                            
[157] &quot;    dfnew_boot &lt;- df_boot[, !(names(df_boot) %in% drop.vars)]&quot;                                                                                                                         
[158] &quot;    # Extract arguments in forestsearch (observed) data analysis&quot;                                                                                                                      
[159] &quot;&quot;                                                                                                                                                                                      
[160] &quot;    args_FS_boot &lt;- fs.est$args_call_all&quot;                                                                                                                                              
[161] &quot;&quot;                                                                                                                                                                                      
[162] &quot;    args_FS_boot$df.analysis &lt;- dfnew_boot&quot;                                                                                                                                            
[163] &quot;    args_FS_boot$df.predict &lt;- dfnew&quot;                                                                                                                                                  
[164] &quot;    args_FS_boot$details &lt;- show3&quot;                                                                                                                                                     
[165] &quot;    args_FS_boot$showten_subgroups &lt;- FALSE&quot;                                                                                                                                           
[166] &quot;    args_FS_boot$plot.sg &lt;- FALSE&quot;                                                                                                                                                     
[167] &quot;    # Re-do grf for bootstrap data&quot;                                                                                                                                                    
[168] &quot;    # NOTE: setting grf_res and grf_cuts to NULL&quot;                                                                                                                                      
[169] &quot;    # Induces evaluation to revert back to default&quot;                                                                                                                                    
[170] &quot;    args_FS_boot$grf_res &lt;- NULL&quot;                                                                                                                                                      
[171] &quot;    args_FS_boot$grf_cuts &lt;- NULL&quot;                                                                                                                                                     
[172] &quot;    # In bootstrap re-set parallel_args per specification in this call&quot;                                                                                                                
[173] &quot;    # For parallel_args we do NOT want to revert back to default&quot;                                                                                                                      
[174] &quot;    # because default is not a null list&quot;                                                                                                                                              
[175] &quot;    if(reset_parallel){&quot;                                                                                                                                                               
[176] &quot;    args_FS_boot[[\&quot;parallel_args\&quot;]] &lt;- list()&quot;                                                                                                                                       
[177] &quot;    } else {&quot;                                                                                                                                                                          
[178] &quot;    args_FS_boot$parallel_args$workers &lt;- boot_workers&quot;                                                                                                                                
[179] &quot;    args_FS_boot$parallel_args$show_message &lt;- FALSE&quot;                                                                                                                                  
[180] &quot;    }&quot;                                                                                                                                                                                 
[181] &quot;&quot;                                                                                                                                                                                      
[182] &quot;    #print(args_FS_boot)&quot;                                                                                                                                                              
[183] &quot;    #cat(\&quot;Length of parallel args\&quot;,c(length(args_FS_boot$parallel_args)),\&quot;\\n\&quot;)&quot;                                                                                                   
[184] &quot;&quot;                                                                                                                                                                                      
[185] &quot;    run_bootstrap &lt;- try(do.call(forestsearch, args_FS_boot), TRUE)&quot;                                                                                                                   
[186] &quot;&quot;                                                                                                                                                                                      
[187] &quot;    if (inherits(run_bootstrap, \&quot;try-error\&quot;)) warning(\&quot;Bootstrap failure\&quot;)&quot;                                                                                                        
[188] &quot;&quot;                                                                                                                                                                                      
[189] &quot;      if (!inherits(run_bootstrap, \&quot;try-error\&quot;) &amp;&amp; !is.null(run_bootstrap$sg.harm)) {&quot;                                                                                               
[190] &quot;      df_PredBoot &lt;- run_bootstrap$df.predict&quot;                                                                                                                                         
[191] &quot;      dfboot_PredBoot &lt;- run_bootstrap$df.est&quot;                                                                                                                                         
[192] &quot;      max_sg_est &lt;- as.numeric(run_bootstrap$find.grps$max_sg_est)&quot;                                                                                                                    
[193] &quot;      tmins_search &lt;- as.numeric(run_bootstrap$find.grps$time_search)&quot;                                                                                                                 
[194] &quot;      prop_maxk &lt;- as.numeric(run_bootstrap$prop_maxk)&quot;                                                                                                                                
[195] &quot;      max_count &lt;- run_bootstrap$find.grps$max_count&quot;                                                                                                                                  
[196] &quot;      L &lt;- run_bootstrap$find.grps$L&quot;                                                                                                                                                  
[197] &quot;      fitHstar_obs &lt;- get_Cox_sg(df_sg = subset(df_PredBoot, treat.recommend == 0), cox.formula = cox.formula.boot, est.loghr = TRUE)&quot;                                                 
[198] &quot;      Hstar_obs &lt;- fitHstar_obs$est_obs&quot;                                                                                                                                               
[199] &quot;      rm(fitHstar_obs)&quot;                                                                                                                                                                
[200] &quot;      fitHstar_star &lt;- get_Cox_sg(df_sg = subset(dfboot_PredBoot, treat.recommend == 0), cox.formula = cox.formula.boot, est.loghr = TRUE)&quot;                                            
[201] &quot;      Hstar_star &lt;- fitHstar_star$est_obs&quot;                                                                                                                                             
[202] &quot;      rm(fitHstar_star)&quot;                                                                                                                                                               
[203] &quot;      H_biasadj_1 &lt;- H_obs - (Hstar_star - Hstar_obs)&quot;                                                                                                                                 
[204] &quot;      H_biasadj_2 &lt;- 2 * H_obs - (H_star + Hstar_star - Hstar_obs)&quot;                                                                                                                    
[205] &quot;      fitHcstar_obs &lt;- get_Cox_sg(df_sg = subset(df_PredBoot, treat.recommend == 1), cox.formula = cox.formula.boot, est.loghr = TRUE)&quot;                                                
[206] &quot;      Hcstar_obs &lt;- fitHcstar_obs$est_obs&quot;                                                                                                                                             
[207] &quot;      rm(fitHcstar_obs)&quot;                                                                                                                                                               
[208] &quot;      fitHcstar_star &lt;- get_Cox_sg(df_sg = subset(dfboot_PredBoot, treat.recommend == 1), cox.formula = cox.formula.boot, est.loghr = TRUE)&quot;                                           
[209] &quot;      Hcstar_star &lt;- fitHcstar_star$est_obs&quot;                                                                                                                                           
[210] &quot;      rm(fitHcstar_star)&quot;                                                                                                                                                              
[211] &quot;      Hc_biasadj_1 &lt;- Hc_obs - (Hcstar_star - Hcstar_obs)&quot;                                                                                                                             
[212] &quot;      Hc_biasadj_2 &lt;- 2 * Hc_obs - (Hc_star + Hcstar_star - Hcstar_obs)&quot;                                                                                                               
[213] &quot;&quot;                                                                                                                                                                                      
[214] &quot;&quot;                                                                                                                                                                                      
[215] &quot;    }&quot;                                                                                                                                                                                 
[216] &quot;&quot;                                                                                                                                                                                      
[217] &quot;    dfres &lt;- data.table::data.table(H_biasadj_1, H_biasadj_2,&quot;                                                                                                                         
[218] &quot;                                    Hc_biasadj_1, Hc_biasadj_2,&quot;                                                                                                                       
[219] &quot;                                    tmins_search, max_sg_est, prop_maxk, L, max_count)&quot;                                                                                                
[220] &quot;    return(dfres)&quot;                                                                                                                                                                     
[221] &quot;  }&quot;                                                                                                                                                                                   
[222] &quot;}&quot;                                                                                                                                                                                     
[223] &quot;&quot;                                                                                                                                                                                      
[224] &quot;#' Format Confidence Interval for Estimates&quot;                                                                                                                                           
[225] &quot;#'&quot;                                                                                                                                                                                    
[226] &quot;#' Formats confidence interval for estimates.&quot;                                                                                                                                         
[227] &quot;#'&quot;                                                                                                                                                                                    
[228] &quot;#' @param estimates Data frame or data.table of estimates.&quot;                                                                                                                            
[229] &quot;#' @param col_names Character vector of column names for estimate, lower, upper.&quot;                                                                                                      
[230] &quot;#' @return Character string formatted as \\\&quot;estimate (lower, upper)\\\&quot;.&quot;                                                                                                             
[231] &quot;#' @export&quot;                                                                                                                                                                            
[232] &quot;&quot;                                                                                                                                                                                      
[233] &quot;format_CI &lt;- function(estimates, col_names) {&quot;                                                                                                                                         
[234] &quot;  resH &lt;- estimates[, ..col_names]&quot;                                                                                                                                                    
[235] &quot;  Hstat &lt;- round(unlist(resH[1, ]), 2)&quot;                                                                                                                                                
[236] &quot;  paste0(Hstat[1], \&quot; (\&quot;, Hstat[2], \&quot;,\&quot;, Hstat[3], \&quot;)\&quot;)&quot;                                                                                                                          
[237] &quot;}&quot;                                                                                                                                                                                     
[238] &quot;&quot;                                                                                                                                                                                      
[239] &quot;&quot;                                                                                                                                                                                      
[240] &quot;# Do not export&quot;                                                                                                                                                                       
[241] &quot;# For checking bootstrap to initiate defaults&quot;                                                                                                                                         
[242] &quot;forchecking &lt;- function(fs){&quot;                                                                                                                                                          
[243] &quot;fs.est &lt;- fs&quot;                                                                                                                                                                          
[244] &quot;nb_boots &lt;- 3&quot;                                                                                                                                                                         
[245] &quot;details &lt;- TRUE&quot;                                                                                                                                                                       
[246] &quot;show_three &lt;- TRUE&quot;                                                                                                                                                                    
[247] &quot; reset_parallel_fs &lt;- TRUE&quot;                                                                                                                                                            
[248] &quot; boot_workers &lt;- 6&quot;                                                                                                                                                                    
[249] &quot; parallel_args &lt;- list(plan = \&quot;multisession\&quot;, workers = 6, show_message = TRUE)&quot;                                                                                                     
[250] &quot;}&quot;                                                                                                                                                                                     
[251] &quot;&quot;                                                                                                                                                                                      
[252] &quot;&quot;                                                                                                                                                                                      
[253] &quot;#' ForestSearch Bootstrap with doFuture Parallelization&quot;                                                                                                                               
[254] &quot;#'&quot;                                                                                                                                                                                    
[255] &quot;#' Orchestrates bootstrap analysis for ForestSearch using doFuture parallelization.&quot;                                                                                                   
[256] &quot;#'&quot;                                                                                                                                                                                    
[257] &quot;#' @param fs.est ForestSearch results object.&quot;                                                                                                                                         
[258] &quot;#' @param nb_boots Integer. Number of bootstrap samples.&quot;                                                                                                                              
[259] &quot;#' @param details Logical. Print details during execution.&quot;                                                                                                                            
[260] &quot;#' @param show_three Logical. Show details for first three bootstraps.&quot;                                                                                                                
[261] &quot;#' @param reset_parallel_fs Logical. Reset parallel plan for bootstrap.&quot;                                                                                                               
[262] &quot;#' @param boot_workers Integer. Number of parallel workers.&quot;                                                                                                                           
[263] &quot;#' @param parallel_args List. Parallelization arguments (plan, workers, show_message).&quot;                                                                                                
[264] &quot;#'&quot;                                                                                                                                                                                    
[265] &quot;#' @return List with bootstrap results, confidence intervals, summary table, Ystar matrix, and estimates.&quot;                                                                             
[266] &quot;#'&quot;                                                                                                                                                                                    
[267] &quot;#' @importFrom future plan&quot;                                                                                                                                                            
[268] &quot;#' @importFrom foreach foreach&quot;                                                                                                                                                        
[269] &quot;#' @importFrom data.table data.table&quot;                                                                                                                                                  
[270] &quot;#' @export&quot;                                                                                                                                                                            
[271] &quot;&quot;                                                                                                                                                                                      
[272] &quot;forestsearch_bootstrap_dofuture &lt;- function(fs.est, nb_boots, details=FALSE, show_three=FALSE, reset_parallel_fs = TRUE, boot_workers = 3,&quot;                                            
[273] &quot;                                            parallel_args = list(plan = \&quot;multisession\&quot;, workers = 6, show_message = TRUE)) {&quot;                                                        
[274] &quot;&quot;                                                                                                                                                                                      
[275] &quot;  args_forestsearch_call &lt;- fs.est$args_call_all&quot;                                                                                                                                      
[276] &quot;&quot;                                                                                                                                                                                      
[277] &quot;  # 1. Ensure packages&quot;                                                                                                                                                                
[278] &quot;  ensure_packages(c(\&quot;data.table\&quot;, \&quot;foreach\&quot;, \&quot;doFuture\&quot;, \&quot;doRNG\&quot;, \&quot;survival\&quot;))&quot;                                                                                              
[279] &quot;&quot;                                                                                                                                                                                      
[280] &quot;  # 2. Build formula&quot;                                                                                                                                                                  
[281] &quot;  args_build &lt;- base::names(formals(build_cox_formula))&quot;                                                                                                                               
[282] &quot;  # align with args_call_all&quot;                                                                                                                                                          
[283] &quot;  args_build_filtered &lt;- args_forestsearch_call[names(args_forestsearch_call) %in% args_build]&quot;                                                                                        
[284] &quot;&quot;                                                                                                                                                                                      
[285] &quot;  #cox.formula.boot &lt;- build_cox_formula(fs.est$outcome.name, fs.est$event.name, fs.est$treat.name)&quot;                                                                                   
[286] &quot;&quot;                                                                                                                                                                                      
[287] &quot;  cox.formula.boot &lt;- base::do.call(build_cox_formula, args_build_filtered)&quot;                                                                                                           
[288] &quot;&quot;                                                                                                                                                                                      
[289] &quot;  # 3. Fit Cox models&quot;                                                                                                                                                                 
[290] &quot;  cox_fits &lt;- fit_cox_models(fs.est$df.est, cox.formula.boot)&quot;                                                                                                                         
[291] &quot;  H_obs &lt;- cox_fits$H_obs&quot;                                                                                                                                                             
[292] &quot;  seH_obs &lt;- cox_fits$seH_obs&quot;                                                                                                                                                         
[293] &quot;  Hc_obs &lt;- cox_fits$Hc_obs&quot;                                                                                                                                                           
[294] &quot;  seHc_obs &lt;- cox_fits$seHc_obs&quot;                                                                                                                                                       
[295] &quot;&quot;                                                                                                                                                                                      
[296] &quot;  old_plan &lt;- future::plan()&quot;                                                                                                                                                          
[297] &quot;  on.exit(future::plan(old_plan), add = TRUE)  # Restore plan on exit&quot;                                                                                                                 
[298] &quot;  # Note: setup_parallel_SGcons is re-purposed from subgroup_consistency&quot;                                                                                                              
[299] &quot;  setup_parallel_SGcons(parallel_args)&quot;                                                                                                                                                
[300] &quot;&quot;                                                                                                                                                                                      
[301] &quot;  # 4. Bootstrap Ystar matrix&quot;                                                                                                                                                         
[302] &quot;  Ystar_mat &lt;- bootstrap_ystar(fs.est$df.est, nb_boots)&quot;                                                                                                                               
[303] &quot;  if (details) cat(\&quot;Done with Ystar_mat\\n\&quot;)&quot;                                                                                                                                        
[304] &quot;&quot;                                                                                                                                                                                      
[305] &quot;  if(nrow(Ystar_mat) != nb_boots || ncol(Ystar_mat) != nrow(fs.est$df.est)){&quot;                                                                                                          
[306] &quot;  stop(\&quot;Dimension of Ystar_mat must be (n x nb_boots)\&quot;)&quot;                                                                                                                             
[307] &quot;  }&quot;                                                                                                                                                                                   
[308] &quot;&quot;                                                                                                                                                                                      
[309] &quot;  # 5. Bootstrap results&quot;                                                                                                                                                              
[310] &quot;&quot;                                                                                                                                                                                      
[311] &quot;  # Remove&quot;                                                                                                                                                                            
[312] &quot;  # Remove after testing&quot;                                                                                                                                                              
[313] &quot;  # Suppress printing message&quot;                                                                                                                                                         
[314] &quot;  #if(length(parallel_args) &gt; 0) parallel_args$show_message &lt;- FALSE&quot;                                                                                                                  
[315] &quot;&quot;                                                                                                                                                                                      
[316] &quot;  # Note: reset_parallel_fs re-sets parallel for subgroup consistency in forestsearch&quot;                                                                                                 
[317] &quot;  # That is reset_parallel_fs = TRUE only the outer *bootstrap* loop is parallelized&quot;                                                                                                  
[318] &quot;&quot;                                                                                                                                                                                      
[319] &quot;  # Remove&quot;                                                                                                                                                                            
[320] &quot;  #cat(\&quot;Running bootstraps now\&quot;,\&quot;\\n\&quot;)&quot;                                                                                                                                            
[321] &quot;&quot;                                                                                                                                                                                      
[322] &quot;  results &lt;- bootstrap_results(fs.est, fs.est$df.est, cox.formula.boot, nb_boots, show_three, H_obs, Hc_obs, reset_parallel_fs, boot_workers)&quot;                                         
[323] &quot;&quot;                                                                                                                                                                                      
[324] &quot;  # 6. Post-processing and formatting&quot;                                                                                                                                                 
[325] &quot;  est.scale &lt;- args_forestsearch_call$est.scale&quot;                                                                                                                                       
[326] &quot;&quot;                                                                                                                                                                                      
[327] &quot;  H_estimates &lt;- try(get_dfRes(Hobs = H_obs, seHobs = seH_obs, H1_adj = results$H_biasadj_1, H2_adj = results$H_biasadj_2,&quot;                                                            
[328] &quot;                               ystar = Ystar_mat, cov_method = \&quot;standard\&quot;, cov_trim = 0.0, est.scale = est.scale, est.loghr = TRUE), TRUE)&quot;                                          
[329] &quot;&quot;                                                                                                                                                                                      
[330] &quot;  Hc_estimates &lt;- try(get_dfRes(Hobs = Hc_obs, seHobs = seHc_obs, H1_adj = results$Hc_biasadj_1, H2_adj = results$Hc_biasadj_2,&quot;                                                       
[331] &quot;                                ystar = Ystar_mat, cov_method = \&quot;standard\&quot;, cov_trim = 0.0, est.scale = est.scale, est.loghr = TRUE), TRUE)&quot;                                         
[332] &quot;&quot;                                                                                                                                                                                      
[333] &quot;  if (inherits(H_estimates, \&quot;try-error\&quot;) | inherits(Hc_estimates, \&quot;try-error\&quot;)) {&quot;                                                                                                 
[334] &quot;    out &lt;- list(results = results, SG_CIs = NULL, FSsg_tab = NULL, Ystar_mat = Ystar_mat, H_estimates = NULL, Hc_estimates = NULL)&quot;                                                    
[335] &quot;    return(out)&quot;                                                                                                                                                                       
[336] &quot;  }&quot;                                                                                                                                                                                   
[337] &quot;&quot;                                                                                                                                                                                      
[338] &quot;  H_res1 &lt;- format_CI(H_estimates, c(\&quot;H0\&quot;, \&quot;H0_lower\&quot;, \&quot;H0_upper\&quot;))&quot;                                                                                                             
[339] &quot;  H_res2 &lt;- format_CI(H_estimates, c(\&quot;H2\&quot;, \&quot;H2_lower\&quot;, \&quot;H2_upper\&quot;))&quot;                                                                                                             
[340] &quot;  Hc_res1 &lt;- format_CI(Hc_estimates, c(\&quot;H0\&quot;, \&quot;H0_lower\&quot;, \&quot;H0_upper\&quot;))&quot;                                                                                                           
[341] &quot;  Hc_res2 &lt;- format_CI(Hc_estimates, c(\&quot;H2\&quot;, \&quot;H2_lower\&quot;, \&quot;H2_upper\&quot;))&quot;                                                                                                           
[342] &quot;&quot;                                                                                                                                                                                      
[343] &quot;  if (details) {&quot;                                                                                                                                                                      
[344] &quot;    cat(\&quot;**** % bootstrap subgroups found =\&quot;,&quot;                                                                                                                                       
[345] &quot;    c(sum(!is.na(results$H_biasadj_2))/nb_boots), \&quot;\\n\&quot;)&quot;                                                                                                                            
[346] &quot;    cat(\&quot;H un-adjusted estimates-----:   \&quot;, H_res1, \&quot;\\n\&quot;)&quot;                                                                                                                        
[347] &quot;    cat(\&quot;H bias-corrected estimates--:   \&quot;, H_res2, \&quot;\\n\&quot;)&quot;                                                                                                                        
[348] &quot;    cat(\&quot;H^c un-adjusted estimates---:   \&quot;, Hc_res1, \&quot;\\n\&quot;)&quot;                                                                                                                       
[349] &quot;    cat(\&quot;H^c bias-corrected estimates:   \&quot;, Hc_res2, \&quot;\\n\&quot;)&quot;                                                                                                                       
[350] &quot;  }&quot;                                                                                                                                                                                   
[351] &quot;&quot;                                                                                                                                                                                      
[352] &quot;    SG_CIs &lt;- list(H_raw = H_res1, H_bc = H_res2, Hc_raw = Hc_res1, Hc_bc = Hc_res2)&quot;                                                                                                  
[353] &quot;&quot;                                                                                                                                                                                      
[354] &quot;# Adjusted CIs and summary table&quot;                                                                                                                                                      
[355] &quot;if (est.scale == \&quot;1/hr\&quot;) {&quot;                                                                                                                                                          
[356] &quot;    hr_1a &lt;- SG_CIs$H_bc&quot;                                                                                                                                                              
[357] &quot;    hr_0a &lt;- SG_CIs$Hc_bc&quot;                                                                                                                                                             
[358] &quot;    FSsg_tab &lt;- SG_tab_estimates(df = fs.est$df.est, SG_flag = \&quot;treat.recommend\&quot;, draws = 0, details = FALSE,&quot;                                                                       
[359] &quot;                                 outcome.name = args_forestsearch_call$outcome.name,&quot;                                                                                                  
[360] &quot;                                 event.name = args_forestsearch_call$event.name,&quot;                                                                                                      
[361] &quot;                                 treat.name = args_forestsearch_call$treat.name,&quot;                                                                                                      
[362] &quot;                                 strata.name = NULL,&quot;                                                                                                                                  
[363] &quot;                                 potentialOutcome.name = args_forestsearch_call$potentialOutcome.name,&quot;                                                                                
[364] &quot;                                 hr_1a = hr_1a, hr_0a = hr_0a, est.scale = \&quot;1/hr\&quot;, sg0_name = \&quot;Questionable\&quot;, sg1_name = \&quot;Recommend\&quot;&quot;                                            
[365] &quot;                                 )&quot;                                                                                                                                                    
[366] &quot;    } else {&quot;                                                                                                                                                                          
[367] &quot;    hr_1a &lt;- SG_CIs$Hc_bc&quot;                                                                                                                                                             
[368] &quot;    hr_0a &lt;- SG_CIs$H_bc&quot;                                                                                                                                                              
[369] &quot;    FSsg_tab &lt;- SG_tab_estimates(df = fs.est$df.est, SG_flag = \&quot;treat.recommend\&quot;, draws = 0, details = FALSE,&quot;                                                                       
[370] &quot;                                 outcome.name = args_forestsearch_call$outcome.name,&quot;                                                                                                  
[371] &quot;                                 event.name = args_forestsearch_call$event.name,&quot;                                                                                                      
[372] &quot;                                 treat.name = args_forestsearch_call$treat.name,&quot;                                                                                                      
[373] &quot;                                 strata.name = NULL,&quot;                                                                                                                                  
[374] &quot;                                 potentialOutcome.name = args_forestsearch_call$potentialOutcome.name,&quot;                                                                                
[375] &quot;                                 hr_1a = hr_1a, hr_0a = hr_0a, est.scale = \&quot;hr\&quot;, sg0_name = \&quot;Questionable\&quot;, sg1_name = \&quot;Recommend\&quot;&quot;                                              
[376] &quot;                                 )&quot;                                                                                                                                                    
[377] &quot;  }&quot;                                                                                                                                                                                   
[378] &quot;  out &lt;- list(results = results, SG_CIs = SG_CIs, FSsg_tab = FSsg_tab, Ystar_mat = Ystar_mat, H_estimates = H_estimates, Hc_estimates = Hc_estimates)&quot;                                 
[379] &quot;  return(out)&quot;                                                                                                                                                                         
[380] &quot;}&quot;                                                                                                                                                                                     
[381] &quot;&quot;                                                                                                                                                                                      
</code></pre></div><div class="user-msg"><strong>User:</strong> Continue answering the question based on the results.</div><div class="bot-msg"><strong>ADW:</strong> <p>Here is a summary of the functions and logic in <code>forestsearch_bootstrap_dofuture.R</code>:</p>
<hr />
<h3><code>forestsearch_bootstrap_dofuture.R</code> ‚Äî Main Functions</h3>
<ol>
<li><strong>ensure_packages</strong></li>
<li>
<p>Installs and loads required R packages if not already installed.</p>
</li>
<li>
<p><strong>build_cox_formula</strong></p>
</li>
<li>
<p>Constructs a Cox model formula from variable names for use in survival analysis.</p>
</li>
<li>
<p><strong>fit_cox_models</strong></p>
</li>
<li>
<p>Fits Cox models for two subgroups (defined by <code>treat.recommend</code>), returning HR and SE for each.</p>
</li>
<li>
<p><strong>bootstrap_ystar</strong></p>
</li>
<li>
<p>Generates a bootstrap matrix for Ystar (ID counts in bootstrap samples) using parallel processing with <code>foreach</code> and <code>%dofuture%</code>.</p>
</li>
<li>
<p><strong>bootstrap_results</strong></p>
</li>
<li>
<p>Runs the main bootstrap analysis for ForestSearch:</p>
<ul>
<li>For each bootstrap sample, fits Cox models for subgroups, computes bias-corrected estimates, and collects search metrics.</li>
<li>Handles parallelization and error handling.</li>
<li>Returns a data.table with bias-adjusted estimates and search metrics.</li>
</ul>
</li>
<li>
<p><strong>format_CI</strong></p>
</li>
<li>
<p>Formats confidence intervals for estimates as a string.</p>
</li>
<li>
<p><strong>forestsearch_bootstrap_dofuture</strong></p>
</li>
<li>
<p>Orchestrates the entire bootstrap analysis for ForestSearch using doFuture parallelization:</p>
<ul>
<li>Ensures required packages are loaded.</li>
<li>Builds Cox model formula.</li>
<li>Fits Cox models for observed data.</li>
<li>Sets up parallelization.</li>
<li>Generates the Ystar bootstrap matrix.</li>
<li>Runs the main bootstrap loop (via <code>bootstrap_results</code>).</li>
<li>Computes and formats confidence intervals for bias-corrected and unadjusted estimates.</li>
<li>Optionally creates a summary table of subgroup estimates.</li>
<li>Returns a list with all results, CIs, summary table, Ystar matrix, and estimates.</li>
</ul>
</li>
<li>
<p><strong>forchecking</strong> (not exported)</p>
</li>
<li>Helper for checking bootstrap setup and defaults.</li>
</ol>
<hr />
<p><strong>General Purpose:</strong><br />
This file provides a robust, parallelized bootstrap framework for ForestSearch analyses, including bias correction, confidence interval calculation, and summary reporting for subgroup hazard ratios. It is designed for high-throughput, reproducible inference in survival/subgroup analysis, leveraging modern R parallelization tools.</p>
<p>If you want to see an example run, test a function, or integrate with your data, please specify your next step.</p></div><div class="user-msg"><strong>User:</strong> please inspect</div><div class="bot-msg"><strong>ADW:</strong> <p>üü¢Working:</p>
<pre><code class="language-R"># Read and display the contents of the forest_search.R file
fs_content &lt;- readLines('forest_search.R')
fs_content
</code></pre></div><div class="bot-msg"><strong>ADW:</strong> <p>‚úîÔ∏èTerminal output:</p>
<pre><code class="language-shell">  [1] &quot;&quot;                                                                                                                                                                                    
  [2] &quot;# List of required packages for ForestSearch analysis&quot;                                                                                                                               
  [3] &quot;&quot;                                                                                                                                                                                    
  [4] &quot;required_packages &lt;- c(\&quot;grf\&quot;,\&quot;policytree\&quot;,\&quot;data.table\&quot;,\&quot;randomForest\&quot;,\&quot;survival\&quot;,\&quot;weightedSurv\&quot;,\&quot;future.apply\&quot;)&quot;                                                       
  [5] &quot;missing &lt;- required_packages[!sapply(required_packages, requireNamespace, quietly = TRUE)]&quot;                                                                                          
  [6] &quot;if(length(missing) &gt; 0) stop(\&quot;Missing required packages: \&quot;, paste(missing, collapse = \&quot;, \&quot;))&quot;                                                                                    
  [7] &quot;&quot;                                                                                                                                                                                    
  [8] &quot;&quot;                                                                                                                                                                                    
  [9] &quot;#' Generate Prediction Dataset with Subgroup Treatment Recommendation&quot;                                                                                                               
 [10] &quot;#'&quot;                                                                                                                                                                                  
 [11] &quot;#' Creates a prediction dataset with a treatment recommendation flag based on subgroup definition.&quot;                                                                                  
 [12] &quot;#'&quot;                                                                                                                                                                                  
 [13] &quot;#' @param df.predict Data frame for prediction (test or validation set).&quot;                                                                                                            
 [14] &quot;#' @param sg.harm Character vector of subgroup-defining covariate names.&quot;                                                                                                            
 [15] &quot;#' @param version Integer; 1 uses \\code{dummy()}, 2 uses \\code{dummy2()} for factor encoding.&quot;                                                                                     
 [16] &quot;#'&quot;                                                                                                                                                                                  
 [17] &quot;#' @return Data frame with treatment recommendation flag (\\code{treat.recommend}).&quot;                                                                                                 
 [18] &quot;#' @export&quot;                                                                                                                                                                          
 [19] &quot;&quot;                                                                                                                                                                                    
 [20] &quot;get_dfpred &lt;- function(df.predict, sg.harm, version = 1) {&quot;                                                                                                                          
 [21] &quot;  if (version == 1) df.pred &lt;- dummy(df.predict)&quot;                                                                                                                                    
 [22] &quot;  if (version == 2) df.pred &lt;- dummy2(df.predict)&quot;                                                                                                                                   
 [23] &quot;  df.pred$treat.recommend &lt;- NA&quot;                                                                                                                                                     
 [24] &quot;  id.harm &lt;- paste(sg.harm, collapse = \&quot;==1 &amp; \&quot;)&quot;                                                                                                                                  
 [25] &quot;  id.harm &lt;- paste(id.harm, \&quot;==1\&quot;)&quot;                                                                                                                                                
 [26] &quot;  df.pred.0 &lt;- subset(df.pred, eval(parse(text = id.harm)))&quot;                                                                                                                         
 [27] &quot;  if (nrow(df.pred.0) &gt; 0) {&quot;                                                                                                                                                        
 [28] &quot;    df.pred.0$treat.recommend &lt;- 0&quot;                                                                                                                                                  
 [29] &quot;  }&quot;                                                                                                                                                                                 
 [30] &quot;  id.noharm &lt;- paste(sg.harm, collapse = \&quot;!=1 | \&quot;)&quot;                                                                                                                                
 [31] &quot;  id.noharm &lt;- paste(id.noharm, \&quot;!=1\&quot;)&quot;                                                                                                                                            
 [32] &quot;  df.pred.1 &lt;- subset(df.pred, eval(parse(text = id.noharm)))&quot;                                                                                                                       
 [33] &quot;  if (nrow(df.pred.1) &gt; 0) {&quot;                                                                                                                                                        
 [34] &quot;    df.pred.1$treat.recommend &lt;- 1&quot;                                                                                                                                                  
 [35] &quot;  }&quot;                                                                                                                                                                                 
 [36] &quot;  if (nrow(df.pred.0) &gt; 0 &amp;&amp; nrow(df.pred.1) &gt; 0) df.pred.out &lt;- data.frame(rbind(df.pred.0, df.pred.1))&quot;                                                                            
 [37] &quot;  if (nrow(df.pred.0) == 0 &amp;&amp; nrow(df.pred.1) &gt; 0) df.pred.out &lt;- data.frame(df.pred.1)&quot;                                                                                             
 [38] &quot;  if (nrow(df.pred.0) &gt; 0 &amp;&amp; nrow(df.pred.1) == 0) df.pred.out &lt;- data.frame(df.pred.0)&quot;                                                                                             
 [39] &quot;  return(df.pred.out)&quot;                                                                                                                                                               
 [40] &quot;}&quot;                                                                                                                                                                                   
 [41] &quot;&quot;                                                                                                                                                                                    
 [42] &quot;#' ForestSearch: Subgroup Identification and Consistency Analysis&quot;                                                                                                                   
 [43] &quot;#'&quot;                                                                                                                                                                                  
 [44] &quot;#' Performs subgroup identification and consistency analysis for treatment effect heterogeneity using ForestSearch.&quot;                                                                 
 [45] &quot;#' Supports LASSO-based dimension reduction, GRF-based variable selection, and flexible cut strategies.&quot;                                                                             
 [46] &quot;#' Returns subgroup definitions, candidate/evaluated confounders, and prediction datasets.&quot;                                                                                          
 [47] &quot;#'&quot;                                                                                                                                                                                  
 [48] &quot;#' @param df.analysis Data frame for analysis.&quot;                                                                                                                                      
 [49] &quot;#' @param outcome.name Character. Name of outcome variable (e.g., time-to-event).&quot;                                                                                                   
 [50] &quot;#' @param event.name Character. Name of event indicator variable (0/1).&quot;                                                                                                             
 [51] &quot;#' @param treat.name Character. Name of treatment group variable (0/1).&quot;                                                                                                             
 [52] &quot;#' @param id.name Character. Name of ID variable.&quot;                                                                                                                                   
 [53] &quot;#' @param potentialOutcome.name Character. Name of potential outcome variable (optional).&quot;                                                                                           
 [54] &quot;#' @param confounders.name Character vector of confounder variable names.&quot;                                                                                                           
 [55] &quot;#' @param parallel_args List. Parallelization arguments (plan, workers).&quot;                                                                                                            
 [56] &quot;#' @param df.predict Data frame for prediction (optional).&quot;                                                                                                                          
 [57] &quot;#' @param df.test Data frame for test set (optional).&quot;                                                                                                                               
 [58] &quot;#' @param is.RCT Logical. Is the data from a randomized controlled trial?&quot;                                                                                                           
 [59] &quot;#' @param seedit Integer. Random seed.&quot;                                                                                                                                              
 [60] &quot;#' @param est.scale Character. Effect scale (e.g., \\\&quot;hr\\\&quot;).&quot;                                                                                                                     
 [61] &quot;#' @param use_lasso Logical. Use LASSO for dimension reduction.&quot;                                                                                                                     
 [62] &quot;#' @param use_grf Logical. Use GRF for variable selection.&quot;                                                                                                                          
 [63] &quot;#' @param grf_res List. Precomputed GRF results (optional).&quot;                                                                                                                         
 [64] &quot;#' @param grf_cuts Character vector of GRF cut expressions (optional).&quot;                                                                                                              
 [65] &quot;#' @param max_n_confounders Integer. Maximum number of confounders to evaluate.&quot;                                                                                                     
 [66] &quot;#' @param grf_depth Integer. Depth for GRF tree.&quot;                                                                                                                                    
 [67] &quot;#' @param dmin.grf Integer. Minimum subgroup size for GRF.&quot;                                                                                                                          
 [68] &quot;#' @param frac.tau Numeric. Fraction of tau for GRF horizon.&quot;                                                                                                                        
 [69] &quot;#' @param conf_force Character vector of forced cut expressions.&quot;                                                                                                                    
 [70] &quot;#' @param defaultcut_names Character vector of confounders to force default cuts.&quot;                                                                                                   
 [71] &quot;#' @param cut_type Character. \\\&quot;default\\\&quot; or \\\&quot;median\\\&quot; for cut strategy.&quot;                                                                                                   
 [72] &quot;#' @param exclude_cuts Character vector of cut expressions to exclude.&quot;                                                                                                              
 [73] &quot;#' @param replace_med_grf Logical. Remove median cuts that overlap with GRF cuts.&quot;                                                                                                   
 [74] &quot;#' @param cont.cutoff Integer. Cutoff for continuous variable determination.&quot;                                                                                                        
 [75] &quot;#' @param conf.cont_medians Character vector of continuous confounders to cut at median.&quot;                                                                                            
 [76] &quot;#' @param conf.cont_medians_force Character vector of additional continuous confounders to force median cut.&quot;                                                                        
 [77] &quot;#' @param n.min Integer. Minimum subgroup size.&quot;                                                                                                                                     
 [78] &quot;#' @param hr.threshold Numeric. Hazard ratio threshold for subgroup selection.&quot;                                                                                                      
 [79] &quot;#' @param hr.consistency Numeric. Hazard ratio threshold for consistency.&quot;                                                                                                           
 [80] &quot;#' @param sg_focus Character. Subgroup focus criterion (\\\&quot;hr\\\&quot;, \\\&quot;hrMaxSG\\\&quot;, \\\&quot;hrMinSG\\\&quot;, \\\&quot;maxSG\\\&quot;, \\\&quot;minSG\\\&quot;).&quot;                                                
 [81] &quot;#' @param fs.splits Integer. Number of splits for consistency analysis.&quot;                                                                                                             
 [82] &quot;#' @param m1.threshold Numeric. Threshold for m1 (default: Inf).&quot;                                                                                                                    
 [83] &quot;#' @param stop.threshold Numeric. Stopping threshold for subgroup search.&quot;                                                                                                           
 [84] &quot;#' @param pconsistency.threshold Numeric. Consistency threshold for subgroup search.&quot;                                                                                                
 [85] &quot;#' @param showten_subgroups Logical. Show top ten subgroups.&quot;                                                                                                                        
 [86] &quot;#' @param d0.min Integer. Minimum number of events in control.&quot;                                                                                                                      
 [87] &quot;#' @param d1.min Integer. Minimum number of events in treatment.&quot;                                                                                                                    
 [88] &quot;#' @param max.minutes Numeric. Maximum minutes for search.&quot;                                                                                                                          
 [89] &quot;#' @param minp Numeric. Minimum proportion for subgroup.&quot;                                                                                                                            
 [90] &quot;#' @param details Logical. Print details during execution.&quot;                                                                                                                          
 [91] &quot;#' @param maxk Integer. Maximum number of subgroup factors.&quot;                                                                                                                         
 [92] &quot;#' @param by.risk Numeric. Interval for risk table time points.&quot;                                                                                                                     
 [93] &quot;#' @param plot.sg Logical. Plot subgroups.&quot;                                                                                                                                          
 [94] &quot;#' @param max_subgroups_search Integer. Maximum number of subgroups to search.&quot;                                                                                                      
 [95] &quot;#' @param vi.grf.min Numeric. Minimum variable importance for GRF screening.&quot;                                                                                                        
 [96] &quot;#' @importFrom stats complete.cases median quantile&quot;                                                                                                                                 
 [97] &quot;#' @importFrom grf causal_survival_forest variable_importance&quot;                                                                                                                       
 [98] &quot;#' @importFrom data.table data.table&quot;                                                                                                                                                
 [99] &quot;#' @importFrom future.apply future_lapply&quot;                                                                                                                                           
[100] &quot;#' @importFrom randomForest randomForest&quot;                                                                                                                                            
[101] &quot;#' @importFrom survival Surv&quot;                                                                                                                                                        
[102] &quot;#' @importFrom weightedSurv df_counting&quot;                                                                                                                                             
[103] &quot;#' @export&quot;                                                                                                                                                                          
[104] &quot;forestsearch &lt;- function(df.analysis,&quot;                                                                                                                                               
[105] &quot;outcome.name = \&quot;tte\&quot;,&quot;                                                                                                                                                             
[106] &quot;event.name = \&quot;event\&quot;,&quot;                                                                                                                                                             
[107] &quot;treat.name = \&quot;treat\&quot;,&quot;                                                                                                                                                             
[108] &quot;id.name = \&quot;id\&quot;,&quot;                                                                                                                                                                   
[109] &quot;potentialOutcome.name=NULL,&quot;                                                                                                                                                         
[110] &quot;confounders.name = NULL,&quot;                                                                                                                                                            
[111] &quot;parallel_args = list(plan = \&quot;multisession\&quot;, workers = 6),&quot;                                                                                                                         
[112] &quot;df.predict = NULL,&quot;                                                                                                                                                                  
[113] &quot;df.test = NULL,&quot;                                                                                                                                                                     
[114] &quot;is.RCT = TRUE, seedit = 8316951,&quot;                                                                                                                                                    
[115] &quot;est.scale=\&quot;hr\&quot;,&quot;                                                                                                                                                                   
[116] &quot;use_lasso = TRUE,&quot;                                                                                                                                                                   
[117] &quot;use_grf = TRUE,&quot;                                                                                                                                                                     
[118] &quot;grf_res = NULL,&quot;                                                                                                                                                                     
[119] &quot;grf_cuts = NULL,&quot;                                                                                                                                                                    
[120] &quot;max_n_confounders = 1000,&quot;                                                                                                                                                           
[121] &quot;grf_depth = 2,&quot;                                                                                                                                                                      
[122] &quot;dmin.grf = 12,&quot;                                                                                                                                                                      
[123] &quot;frac.tau = 0.6,&quot;                                                                                                                                                                     
[124] &quot;conf_force=NULL,&quot;                                                                                                                                                                    
[125] &quot;defaultcut_names=NULL,&quot;                                                                                                                                                              
[126] &quot;cut_type=\&quot;default\&quot;,&quot;                                                                                                                                                               
[127] &quot;exclude_cuts = NULL,&quot;                                                                                                                                                                
[128] &quot;replace_med_grf = FALSE,&quot;                                                                                                                                                            
[129] &quot;cont.cutoff = 4,&quot;                                                                                                                                                                    
[130] &quot;conf.cont_medians = NULL,&quot;                                                                                                                                                           
[131] &quot;conf.cont_medians_force = NULL,&quot;                                                                                                                                                     
[132] &quot;n.min = 60,&quot;                                                                                                                                                                         
[133] &quot;hr.threshold = 1.25,&quot;                                                                                                                                                                
[134] &quot;hr.consistency = 1.0,&quot;                                                                                                                                                               
[135] &quot;sg_focus = \&quot;hr\&quot;,&quot;                                                                                                                                                                  
[136] &quot;fs.splits = 1000,&quot;                                                                                                                                                                   
[137] &quot;m1.threshold = Inf,&quot;                                                                                                                                                                 
[138] &quot;stop.threshold = 0.90,&quot;                                                                                                                                                              
[139] &quot;pconsistency.threshold = 0.90,&quot;                                                                                                                                                      
[140] &quot;showten_subgroups = FALSE,&quot;                                                                                                                                                          
[141] &quot;d0.min = 10, d1.min = 10,&quot;                                                                                                                                                           
[142] &quot;max.minutes = 3,&quot;                                                                                                                                                                    
[143] &quot;minp = 0.025,&quot;                                                                                                                                                                       
[144] &quot;details = FALSE,&quot;                                                                                                                                                                    
[145] &quot;maxk = 2,&quot;                                                                                                                                                                           
[146] &quot;by.risk = 12, plot.sg = FALSE, plot.grf = FALSE,&quot;                                                                                                                                    
[147] &quot;max_subgroups_search = 10,&quot;                                                                                                                                                          
[148] &quot;vi.grf.min = -0.2){&quot;                                                                                                                                                                 
[149] &quot;&quot;                                                                                                                                                                                    
[150] &quot;if (!exists(\&quot;df.analysis\&quot;) | !is.data.frame(df.analysis)){&quot;                                                                                                                        
[151] &quot;    stop(\&quot;df.analysis does not exists or is not a data.frame\&quot;)&quot;                                                                                                                    
[152] &quot;  } else if (exists(\&quot;df.analysis\&quot;) &amp;&amp; !is.data.frame(df.analysis)){&quot;                                                                                                               
[153] &quot;    df.analysis &lt;- as.data.frame(df.analysis)&quot;                                                                                                                                       
[154] &quot;    message(\&quot;Converting df.analysis to data.frame\&quot;)&quot;                                                                                                                               
[155] &quot;  }&quot;                                                                                                                                                                                 
[156] &quot;&quot;                                                                                                                                                                                    
[157] &quot;# Revised&quot;                                                                                                                                                                           
[158] &quot;  if (is.null(id.name)) {&quot;                                                                                                                                                           
[159] &quot;    df.analysis$id &lt;- seq_len(nrow(df.analysis))&quot;                                                                                                                                    
[160] &quot;    id.name &lt;- \&quot;id\&quot;&quot;                                                                                                                                                               
[161] &quot;  } else if (!(id.name %in% names(df.analysis))) {&quot;                                                                                                                                  
[162] &quot;    df.analysis[[id.name]] &lt;- seq_len(nrow(df.analysis))&quot;                                                                                                                            
[163] &quot;  }&quot;                                                                                                                                                                                 
[164] &quot;&quot;                                                                                                                                                                                    
[165] &quot;var_names &lt;- c(confounders.name,outcome.name,event.name,id.name,treat.name,potentialOutcome.name)&quot;                                                                                   
[166] &quot;  # Ensure all required variables exist in df.analysis&quot;                                                                                                                              
[167] &quot;  missing_vars &lt;- setdiff(var_names, names(df.analysis))&quot;                                                                                                                            
[168] &quot;  if(length(missing_vars) &gt; 0) {&quot;                                                                                                                                                    
[169] &quot;    stop(\&quot;The following variables are missing in df.analysis: \&quot;, paste(missing_vars, collapse = \&quot;, \&quot;))&quot;                                                                          
[170] &quot;  }&quot;                                                                                                                                                                                 
[171] &quot;&quot;                                                                                                                                                                                    
[172] &quot;# Return the arguments to be passed to bootstrap call&quot;                                                                                                                               
[173] &quot;# in order to use the same for the bootstrap analysis&quot;                                                                                                                               
[174] &quot;#args_call &lt;- as.list(match.call())[-1]&quot;                                                                                                                                             
[175] &quot;# Include defaults for call below&quot;                                                                                                                                                   
[176] &quot;args_names &lt;- names(formals())&quot;                                                                                                                                                      
[177] &quot;args_call_all &lt;- mget(args_names, envir = environment())&quot;                                                                                                                            
[178] &quot;# Check parallel arguments for subgroup consistency&quot;                                                                                                                                 
[179] &quot;if(length(parallel_args) &gt; 0){&quot;                                                                                                                                                      
[180] &quot;allowed_plans &lt;- c(\&quot;multisession\&quot;, \&quot;multicore\&quot;, \&quot;callr\&quot;)&quot;                                                                                                                      
[181] &quot;plan_type &lt;- parallel_args$plan&quot;                                                                                                                                                     
[182] &quot;n_workers &lt;- parallel_args$workers&quot;                                                                                                                                                  
[183] &quot;max_cores &lt;- parallel::detectCores()&quot;                                                                                                                                                
[184] &quot;if (is.null(plan_type)) stop(\&quot;parallel_args$plan must be specified.\&quot;)&quot;                                                                                                             
[185] &quot;if (!plan_type %in% allowed_plans) {&quot;                                                                                                                                                
[186] &quot;stop(\&quot;parallel_args$plan must be one of: \&quot;, paste(allowed_plans, collapse = \&quot;, \&quot;))&quot;                                                                                              
[187] &quot;}&quot;                                                                                                                                                                                   
[188] &quot;if (is.null(n_workers) || !is.numeric(n_workers) || n_workers &lt; 1) {&quot;                                                                                                                
[189] &quot;  parallel_args$workers &lt;- 1&quot;                                                                                                                                                        
[190] &quot;} else {&quot;                                                                                                                                                                            
[191] &quot;  parallel_args$workers &lt;- min(n_workers, max_cores)&quot;                                                                                                                                
[192] &quot;}&quot;                                                                                                                                                                                   
[193] &quot;}&quot;                                                                                                                                                                                   
[194] &quot;&quot;                                                                                                                                                                                    
[195] &quot;if(!(sg_focus %in% c(\&quot;hr\&quot;,\&quot;hrMaxSG\&quot;, \&quot;hrMinSG\&quot;, \&quot;maxSG\&quot;, \&quot;minSG\&quot;))) stop(\&quot;sg_focus must be either hr, hrMaxSG (maxSG), or hrMinSG (minSG)\&quot;)&quot;                             
[196] &quot;&quot;                                                                                                                                                                                    
[197] &quot;if(plot.sg &amp;&amp; is.null(by.risk)) stop(\&quot;by.risk must be non-null if plot.sg = TRUE\&quot;)&quot;                                                                                                
[198] &quot;&quot;                                                                                                                                                                                    
[199] &quot;# reset stop.threshold (&gt;1) to override stopping&quot;                                                                                                                                    
[200] &quot;if(showten_subgroups)  stop.threshold &lt;- 1.1&quot;                                                                                                                                        
[201] &quot;&quot;                                                                                                                                                                                    
[202] &quot;if(!(cut_type %in% c(\&quot;default\&quot;,\&quot;median\&quot;))) stop(\&quot;only default and median cuts\&quot;)&quot;                                                                                               
[203] &quot;&quot;                                                                                                                                                                                    
[204] &quot;if(all(confounders.name %in% names(df.analysis)) != TRUE) stop(\&quot;Not all confounders found in dataset\&quot;)&quot;                                                                            
[205] &quot;&quot;                                                                                                                                                                                    
[206] &quot;if(!is.null(defaultcut_names)){&quot;                                                                                                                                                     
[207] &quot;if(all(defaultcut_names %in% names(df.analysis)) != TRUE) stop(\&quot;Not all confounders for default cuts found in dataset\&quot;)&quot;                                                           
[208] &quot;}&quot;                                                                                                                                                                                   
[209] &quot;&quot;                                                                                                                                                                                    
[210] &quot;&quot;                                                                                                                                                                                    
[211] &quot;if(is.null(confounders.name)) stop(\&quot;Confounder names (confounders.name) required\&quot;)&quot;                                                                                                
[212] &quot;if(is.null(outcome.name) || is.null(event.name) || is.null(treat.name)) stop(\&quot;outcome.name, event.name, and treat.name required (missing at least 1)\&quot;)&quot;                            
[213] &quot;if(is.null(hr.threshold) || is.null(hr.consistency) || is.null(pconsistency.threshold)) stop(\&quot;hr.threshold, hr.consistency, pconsistency.threshold required (missing at least 1)\&quot;)&quot;
[214] &quot;&quot;                                                                                                                                                                                    
[215] &quot;if(sg_focus %in% c(\&quot;maxSG\&quot;,\&quot;minSG\&quot;)){&quot;                                                                                                                                           
[216] &quot;if(stop.threshold &lt; pconsistency.threshold) stop.threshold &lt;- pconsistency.threshold&quot;                                                                                                
[217] &quot;# Stop searching once pconsistency.threshold is met&quot;                                                                                                                                 
[218] &quot;# Select max/min subgroup size&quot;                                                                                                                                                      
[219] &quot; }&quot;                                                                                                                                                                                  
[220] &quot;&quot;                                                                                                                                                                                    
[221] &quot;# Re-set stop.threshold&quot;                                                                                                                                                             
[222] &quot;# Continue searching&quot;                                                                                                                                                                
[223] &quot;# Select max/min subgroup size (pconsistency threshold is minimum)&quot;                                                                                                                  
[224] &quot;if(sg_focus %in% c(\&quot;hrMaxSG\&quot;,\&quot;hrMinSG\&quot;) &amp;&amp; stop.threshold &lt; 1.0) stop.threshold &lt;- 1.0&quot;                                                                                          
[225] &quot;&quot;                                                                                                                                                                                    
[226] &quot;# Sort data by id&quot;                                                                                                                                                                   
[227] &quot;df.analysis &lt;- df.analysis[order(df.analysis[[id.name]]), , drop = FALSE]&quot;                                                                                                           
[228] &quot;# Select relevant columns&quot;                                                                                                                                                           
[229] &quot;dfa &lt;- df.analysis[, var_names, drop = FALSE]&quot;                                                                                                                                       
[230] &quot;# Identify complete cases&quot;                                                                                                                                                           
[231] &quot;complete_idx &lt;- complete.cases(dfa)&quot;                                                                                                                                                 
[232] &quot;n_excluded &lt;- sum(!complete_idx)&quot;                                                                                                                                                    
[233] &quot;# Report exclusions&quot;                                                                                                                                                                 
[234] &quot;if(n_excluded &gt; 0) {&quot;                                                                                                                                                                
[235] &quot;  message(\&quot;Total excluded by omitting missing data = \&quot;, n_excluded)&quot;                                                                                                               
[236] &quot;}&quot;                                                                                                                                                                                   
[237] &quot;# Keep only complete cases&quot;                                                                                                                                                          
[238] &quot;df.analysis &lt;- dfa[complete_idx, , drop = FALSE]&quot;                                                                                                                                    
[239] &quot;&quot;                                                                                                                                                                                    
[240] &quot;t.start_all&lt;-proc.time()[3]&quot;                                                                                                                                                         
[241] &quot;&quot;                                                                                                                                                                                    
[242] &quot;&quot;                                                                                                                                                                                    
[243] &quot;# If using grf and not populated then run grf&quot;                                                                                                                                       
[244] &quot;if(use_grf &amp;&amp; (is.null(grf_res) || is.null(grf_res$tree.cuts))) {&quot;                                                                                                                   
[245] &quot;if(details){&quot;                                                                                                                                                                        
[246] &quot;cat(\&quot;GRF stage for cut selection with dmin,tau=\&quot;,c(dmin.grf, frac.tau),\&quot;\\n\&quot;)&quot;                                                                                                   
[247] &quot;}&quot;                                                                                                                                                                                   
[248] &quot;grf_res &lt;- NULL&quot;                                                                                                                                                                     
[249] &quot;grf_res &lt;- try(&quot;                                                                                                                                                                     
[250] &quot;grf.subg.harm.survival(data = df.analysis, confounders.name = confounders.name,&quot;                                                                                                     
[251] &quot;outcome.name = outcome.name, RCT = is.RCT,seedit = seedit,maxdepth = grf_depth,&quot;                                                                                                     
[252] &quot;event.name = event.name, id.name = id.name, treat.name = treat.name, n.min = n.min, dmin.grf = dmin.grf,&quot;                                                                            
[253] &quot;frac.tau = frac.tau, details = details)&quot;                                                                                                                                             
[254] &quot;,TRUE)&quot;                                                                                                                                                                              
[255] &quot;&quot;                                                                                                                                                                                    
[256] &quot;# Initialize outputs&quot;                                                                                                                                                                
[257] &quot;grf_plot &lt;- NULL&quot;                                                                                                                                                                    
[258] &quot;grf_cuts &lt;- NULL&quot;                                                                                                                                                                    
[259] &quot;# Check if grf_res is valid (not a try-error and not NULL)&quot;                                                                                                                          
[260] &quot;if (!inherits(grf_res, \&quot;try-error\&quot;) &amp;&amp; !is.null(grf_res)) {&quot;                                                                                                                       
[261] &quot;  # If no subgroup found&quot;                                                                                                                                                            
[262] &quot;  if (is.null(grf_res$sg.harm)) {&quot;                                                                                                                                                   
[263] &quot;    use_grf &lt;- FALSE&quot;                                                                                                                                                                
[264] &quot;    if (isTRUE(details)) {&quot;                                                                                                                                                          
[265] &quot;      cat(\&quot;NO GRF cuts meeting delta(RMST): dmin.grf=\&quot;, dmin.grf, \&quot;\\n\&quot;)&quot;                                                                                                        
[266] &quot;    }&quot;                                                                                                                                                                               
[267] &quot;  } else {&quot;                                                                                                                                                                          
[268] &quot;    # If subgroup found&quot;                                                                                                                                                             
[269] &quot;    # Check for DiagrammeR availability&quot;                                                                                                                                             
[270] &quot;    if (requireNamespace(\&quot;DiagrammeR\&quot;, quietly = TRUE) &amp;&amp; plot.grf) {&quot;                                                                                                             
[271] &quot;      grf_plot &lt;- plot(grf_res$tree, leaf.labels = c(\&quot;Control\&quot;, \&quot;Treat\&quot;))&quot;                                                                                                       
[272] &quot;    } else {&quot;                                                                                                                                                                        
[273] &quot;      #warning(\&quot;Skipping tree plot --&gt; DiagrammeR packaged required to view tree graph\&quot;)&quot;                                                                                          
[274] &quot;      if (isTRUE(details)) {&quot;                                                                                                                                                        
[275] &quot;        cat(\&quot;DiagrammeR or not creating: skipping tree plot.\\n\&quot;)&quot;                                                                                                                 
[276] &quot;      }&quot;                                                                                                                                                                             
[277] &quot;      grf_plot &lt;- NULL&quot;                                                                                                                                                              
[278] &quot;    }&quot;                                                                                                                                                                               
[279] &quot;    grf_cuts &lt;- grf_res$tree.cuts&quot;                                                                                                                                                   
[280] &quot;  }&quot;                                                                                                                                                                                 
[281] &quot;} else {&quot;                                                                                                                                                                            
[282] &quot;  # If grf_res is invalid, ensure outputs are NULL&quot;                                                                                                                                  
[283] &quot;  grf_plot &lt;- NULL&quot;                                                                                                                                                                  
[284] &quot;  grf_cuts &lt;- NULL&quot;                                                                                                                                                                  
[285] &quot;}&quot;                                                                                                                                                                                   
[286] &quot;}&quot;                                                                                                                                                                                   
[287] &quot;&quot;                                                                                                                                                                                    
[288] &quot;if(use_grf &amp;&amp; !exists(\&quot;grf_cuts\&quot;)) warning(\&quot;GRF cuts not found\&quot;)&quot;                                                                                                                
[289] &quot;&quot;                                                                                                                                                                                    
[290] &quot;get_argsFS &lt;- formals(get_FSdata)&quot;                                                                                                                                                   
[291] &quot;args_FS &lt;- names(get_argsFS)&quot;                                                                                                                                                        
[292] &quot;# align with args_call_all&quot;                                                                                                                                                          
[293] &quot;args_FS_filtered &lt;- args_call_all[names(args_call_all) %in% args_FS]&quot;                                                                                                                
[294] &quot;# In get_FSdata the data source is \&quot;df\&quot;&quot;                                                                                                                                           
[295] &quot;args_FS_filtered$df &lt;- df.analysis&quot;                                                                                                                                                  
[296] &quot;args_FS_filtered$grf_cuts &lt;- grf_cuts&quot;                                                                                                                                               
[297] &quot;&quot;                                                                                                                                                                                    
[298] &quot;# Remove&quot;                                                                                                                                                                            
[299] &quot;# cat(\&quot;args_FS_filtered\&quot;,\&quot;\\n\&quot;)&quot;                                                                                                                                                 
[300] &quot;# print(names(args_FS_filtered))&quot;                                                                                                                                                    
[301] &quot;&quot;                                                                                                                                                                                    
[302] &quot;# FSdata1 &lt;- do.call(get_FSdata, args_FS_filtered)&quot;                                                                                                                                  
[303] &quot;# print(names(FSdata1))&quot;                                                                                                                                                             
[304] &quot;&quot;                                                                                                                                                                                    
[305] &quot;FSdata &lt;- try(do.call(get_FSdata, args_FS_filtered), TRUE)&quot;                                                                                                                          
[306] &quot;&quot;                                                                                                                                                                                    
[307] &quot;if(inherits(FSdata,\&quot;try-error\&quot;)){&quot;                                                                                                                                                 
[308] &quot;warning(\&quot;FSdata failure\&quot;)&quot;                                                                                                                                                         
[309] &quot;}&quot;                                                                                                                                                                                   
[310] &quot;&quot;                                                                                                                                                                                    
[311] &quot;&quot;                                                                                                                                                                                    
[312] &quot;if(inherits(FSdata,\&quot;try-error\&quot;)) stop(\&quot;FSdata error\&quot;)&quot;                                                                                                                           
[313] &quot;&quot;                                                                                                                                                                                    
[314] &quot;if(!inherits(FSdata,\&quot;try-error\&quot;)){&quot;                                                                                                                                                
[315] &quot;lassoomit &lt;- FSdata$lassoomit&quot;                                                                                                                                                       
[316] &quot;lassokeep &lt;- FSdata$lassokeep&quot;                                                                                                                                                       
[317] &quot;df &lt;- FSdata$df&quot;                                                                                                                                                                     
[318] &quot;&quot;                                                                                                                                                                                    
[319] &quot;Y &lt;- df[,outcome.name]&quot;                                                                                                                                                              
[320] &quot;Event &lt;- df[,event.name]&quot;                                                                                                                                                            
[321] &quot;Treat &lt;- df[,treat.name]&quot;                                                                                                                                                            
[322] &quot;&quot;                                                                                                                                                                                    
[323] &quot;FSconfounders.name &lt;- FSdata$confs_names&quot;                                                                                                                                            
[324] &quot;confs_labels &lt;- FSdata$confs&quot;                                                                                                                                                        
[325] &quot;if(is.null(df.predict)) df.predict &lt;- df&quot;                                                                                                                                            
[326] &quot;&quot;                                                                                                                                                                                    
[327] &quot;if(!is.null(vi.grf.min)){&quot;                                                                                                                                                           
[328] &quot;  # Use GRF for screening and ordering&quot;                                                                                                                                              
[329] &quot;  # Covariates need to be converted to numeric scale&quot;                                                                                                                                
[330] &quot;  # original data.frame version&quot;                                                                                                                                                     
[331] &quot;  X &lt;- as.matrix(df[,FSconfounders.name])&quot;                                                                                                                                           
[332] &quot;  # Convert to numeric&quot;                                                                                                                                                              
[333] &quot;  X &lt;- apply(X,2,as.numeric)&quot;                                                                                                                                                        
[334] &quot;  tau.rmst &lt;- min(c(max(Y[Treat == 1 &amp; Event == 1]),max(Y[Treat == 0 &amp; Event == 1])))&quot;                                                                                               
[335] &quot;  # For screening we take 0.9*tau.rms&quot;                                                                                                                                               
[336] &quot;  if(!is.RCT) cs.forest &lt;- try(suppressWarnings(grf::causal_survival_forest(X, Y, Treat, Event, horizon = 0.9 * tau.rmst, seed = 8316951)), TRUE)&quot;                                   
[337] &quot;  if(is.RCT) cs.forest &lt;- try(suppressWarnings(grf::causal_survival_forest(X, Y, Treat, Event, W.hat = 0.5, horizon = 0.9 * tau.rmst, seed = 8316951)), TRUE)&quot;                       
[338] &quot;&quot;                                                                                                                                                                                    
[339] &quot;  vi.cs &lt;- round(grf::variable_importance(cs.forest),4)&quot;                                                                                                                             
[340] &quot;  vi.cs2 &lt;- data.frame(confs_labels,FSconfounders.name,vi.cs)&quot;                                                                                                                       
[341] &quot;  vi.order &lt;- order(vi.cs,decreasing=TRUE)&quot;                                                                                                                                          
[342] &quot;  vi.cs2 &lt;- vi.cs2[vi.order,]&quot;                                                                                                                                                       
[343] &quot;&quot;                                                                                                                                                                                    
[344] &quot;  conf.screen &lt;- vi.cs2[,2]&quot;                                                                                                                                                         
[345] &quot;  vi_ratio &lt;- vi.cs2[,3] / max(vi.cs2[,3])&quot;                                                                                                                                          
[346] &quot;  selected.vars &lt;- which(vi_ratio &gt; vi.grf.min)&quot;                                                                                                                                     
[347] &quot;  conf.screen &lt;- conf.screen[selected.vars]&quot;                                                                                                                                         
[348] &quot;  # Restrict to max of max_n_confounders&quot;                                                                                                                                            
[349] &quot;  # Keeping 1st lmax ordered per vi&quot;                                                                                                                                                 
[350] &quot;  lmax &lt;- min(c(length(conf.screen),max_n_confounders))&quot;                                                                                                                             
[351] &quot;  conf.screen_limit &lt;- conf.screen[c(1:lmax)]&quot;                                                                                                                                       
[352] &quot;  conf.screen &lt;- conf.screen_limit&quot;                                                                                                                                                  
[353] &quot;  if(details){&quot;                                                                                                                                                                      
[354] &quot;  cat(\&quot;Number of factors evaluated=\&quot;,c(lmax),\&quot;\\n\&quot;)&quot;                                                                                                                             
[355] &quot;  cat(\&quot;Confounders per grf screening\&quot;,conf.screen,\&quot;\\n\&quot;)&quot;                                                                                                                        
[356] &quot;  vi_res &lt;- vi.cs2[selected.vars,]&quot;                                                                                                                                                  
[357] &quot;  # Re-name for printing&quot;                                                                                                                                                            
[358] &quot;  names(vi_res) &lt;- c(\&quot;Factors\&quot;,\&quot;Labels\&quot;,\&quot;VI(grf)\&quot;)&quot;                                                                                                                            
[359] &quot;  print(vi_res)&quot;                                                                                                                                                                     
[360] &quot;  }&quot;                                                                                                                                                                                 
[361] &quot;} else {&quot;                                                                                                                                                                            
[362] &quot;conf.screen &lt;- FSconfounders.name&quot;                                                                                                                                                   
[363] &quot;}&quot;                                                                                                                                                                                   
[364] &quot;&quot;                                                                                                                                                                                    
[365] &quot;df.confounders &lt;- df[,conf.screen]&quot;                                                                                                                                                  
[366] &quot;df.confounders &lt;- dummy(df.confounders)&quot;                                                                                                                                             
[367] &quot;&quot;                                                                                                                                                                                    
[368] &quot;  # name identification as \&quot;id\&quot; for merging (df.predict) sg membership flags&quot;                                                                                                      
[369] &quot;  id &lt;- df[,c(id.name)]&quot;                                                                                                                                                             
[370] &quot;  df.fs &lt;- data.frame(Y,Event,Treat,id,df.confounders)&quot;                                                                                                                              
[371] &quot;  Z &lt;- as.matrix(df.confounders)&quot;                                                                                                                                                    
[372] &quot;  colnames(Z) &lt;- names(df.confounders)&quot;                                                                                                                                              
[373] &quot;&quot;                                                                                                                                                                                    
[374] &quot;  find.grps &lt;- subgroup.search(Y = Y, Event = Event, Treat = Treat, Z = Z, d0.min = d0.min, d1.min = d1.min, n.min = n.min,&quot;                                                         
[375] &quot;                               hr.threshold = hr.threshold, max.minutes = max.minutes, details = details, maxk = maxk)&quot;                                                              
[376] &quot;&quot;                                                                                                                                                                                    
[377] &quot;  sg.harm &lt;- NULL&quot;                                                                                                                                                                   
[378] &quot;  df.est_out &lt;- NULL&quot;                                                                                                                                                                
[379] &quot;  df.predict_out &lt;- NULL&quot;                                                                                                                                                            
[380] &quot;  df.test_out &lt;- NULL&quot;                                                                                                                                                               
[381] &quot;  grp.consistency &lt;- NULL&quot;                                                                                                                                                           
[382] &quot;&quot;                                                                                                                                                                                    
[383] &quot;  max_sg_est &lt;- find.grps$max_sg_est&quot;                                                                                                                                                
[384] &quot;&quot;                                                                                                                                                                                    
[385] &quot;  prop_maxk &lt;- find.grps$prop_max_count&quot;                                                                                                                                             
[386] &quot;&quot;                                                                                                                                                                                    
[387] &quot;  # If no subgroups found then this is end&quot;                                                                                                                                          
[388] &quot;  t.end_all&lt;-proc.time()[3]&quot;                                                                                                                                                         
[389] &quot;  t.min_all&lt;-(t.end_all-t.start_all)/60&quot;                                                                                                                                             
[390] &quot;&quot;                                                                                                                                                                                    
[391] &quot;  if(!is.null(find.grps$out.found) &amp;&amp; (any(find.grps$out.found$hr.subgroups$HR &gt; hr.consistency)) || any(find.grps$out.found$hr.subgroups$HR &gt; hr.consistency)){# Found something?&quot;  
[392] &quot;  if(plot.sg &amp;&amp; is.null(by.risk)) by.risk&lt;-round(max(Y)/12,0)&quot;                                                                                                                       
[393] &quot;  if(details) cat(\&quot;# of candidate subgroups (meeting all criteria) = \&quot;,c(nrow(find.grps$out.found$hr.subgroups)),\&quot;\\n\&quot;)&quot;                                                         
[394] &quot;&quot;                                                                                                                                                                                    
[395] &quot;  args_sgc &lt;- names(formals(subgroup.consistency))&quot;                                                                                                                                  
[396] &quot;  # align with args_call_all&quot;                                                                                                                                                        
[397] &quot;  args_sgc_filtered &lt;- args_call_all[names(args_call_all) %in% args_sgc]&quot;                                                                                                            
[398] &quot;  args_sgc_filtered$df &lt;- df.fs&quot;                                                                                                                                                     
[399] &quot;  args_sgc_filtered$hr.subgroups &lt;- find.grps$out.found$hr.subgroups&quot;                                                                                                                
[400] &quot;  args_sgc_filtered$Lsg &lt;- find.grps$L&quot;                                                                                                                                              
[401] &quot;  args_sgc_filtered$confs_labels &lt;- confs_labels&quot;                                                                                                                                    
[402] &quot;  args_sgc_filtered$n.splits &lt;- fs.splits&quot;                                                                                                                                           
[403] &quot;  args_sgc_filtered$stop_Kgroups &lt;- max_subgroups_search&quot;                                                                                                                            
[404] &quot;&quot;                                                                                                                                                                                    
[405] &quot;  grp.consistency &lt;- do.call(subgroup.consistency, args_sgc_filtered)&quot;                                                                                                               
[406] &quot;&quot;                                                                                                                                                                                    
[407] &quot;  t.end_all&lt;-proc.time()[3]&quot;                                                                                                                                                         
[408] &quot;  t.min_all&lt;-(t.end_all-t.start_all)/60&quot;                                                                                                                                             
[409] &quot;&quot;                                                                                                                                                                                    
[410] &quot;if(details){&quot;                                                                                                                                                                        
[411] &quot;cat(\&quot;Minutes forestsearch overall=\&quot;,c(t.min_all),\&quot;\\n\&quot;)&quot;                                                                                                                         
[412] &quot;}&quot;                                                                                                                                                                                   
[413] &quot;# Found something and a subgroup&quot;                                                                                                                                                    
[414] &quot;if(!is.null(grp.consistency$sg.harm)){&quot;                                                                                                                                              
[415] &quot;sg.harm &lt;- grp.consistency$sg.harm&quot;                                                                                                                                                  
[416] &quot;# data containing id and treatment flag&quot;                                                                                                                                             
[417] &quot;temp &lt;- grp.consistency$df_flag&quot;                                                                                                                                                     
[418] &quot;# Merge to analysis data and add treatment flag (all.x=TRUE)&quot;                                                                                                                        
[419] &quot;df.est_out &lt;- merge(df, temp, by=\&quot;id\&quot;, all.x=TRUE)&quot;                                                                                                                                
[420] &quot; # Return df.predict&quot;                                                                                                                                                                
[421] &quot;if(!is.null(df.predict)){&quot;                                                                                                                                                           
[422] &quot;# This does not work if df.predict is test sample in which case&quot;                                                                                                                     
[423] &quot;# cannot match to df_flag by id&quot;                                                                                                                                                     
[424] &quot;df.predict_out &lt;- merge(df.predict, temp, by=\&quot;id\&quot;, all.x=TRUE)&quot;                                                                                                                    
[425] &quot;}&quot;                                                                                                                                                                                   
[426] &quot;if(!is.null(df.test)){&quot;                                                                                                                                                              
[427] &quot;  df.test_out &lt;- get_dfpred(df.predict = df.test,sg.harm = grp.consistency$sg.harm,version = 2)&quot;                                                                                     
[428] &quot;   }&quot;                                                                                                                                                                                
[429] &quot;}&quot;                                                                                                                                                                                   
[430] &quot; } # Found something&quot;                                                                                                                                                                
[431] &quot;out &lt;- list(grp.consistency = grp.consistency,find.grps = find.grps,&quot;                                                                                                                
[432] &quot;confounders.candidate = FSconfounders.name,&quot;                                                                                                                                         
[433] &quot;confounders.evaluated = confs_labels,&quot;                                                                                                                                               
[434] &quot;df.est = df.est_out,&quot;                                                                                                                                                                
[435] &quot;df.predict = df.predict_out,&quot;                                                                                                                                                        
[436] &quot;df.test = df.test_out,&quot;                                                                                                                                                              
[437] &quot;minutes_all = t.min_all,&quot;                                                                                                                                                            
[438] &quot;grf_res = grf_res,&quot;                                                                                                                                                                  
[439] &quot;sg_focus = sg_focus,&quot;                                                                                                                                                                
[440] &quot;sg.harm = sg.harm,&quot;                                                                                                                                                                  
[441] &quot;grf_cuts = grf_cuts,&quot;                                                                                                                                                                
[442] &quot;prop_maxk = prop_maxk,&quot;                                                                                                                                                              
[443] &quot;max_sg_est = max_sg_est,&quot;                                                                                                                                                            
[444] &quot;grf_plot = grf_plot,&quot;                                                                                                                                                                
[445] &quot;args_call_all = args_call_all)&quot;                                                                                                                                                      
[446] &quot;}&quot;                                                                                                                                                                                   
[447] &quot;# Fsdata NOT successful&quot;                                                                                                                                                             
[448] &quot;if(inherits(FSdata,\&quot;try-error\&quot;)){&quot;                                                                                                                                                 
[449] &quot;  out &lt;- list(sg.harm=NULL)&quot;                                                                                                                                                         
[450] &quot;}&quot;                                                                                                                                                                                   
[451] &quot;return(out)&quot;                                                                                                                                                                         
[452] &quot;}&quot;                                                                                                                                                                                   
[453] &quot;&quot;                                                                                                                                                                                    
</code></pre></div><div class="user-msg"><strong>User:</strong> Continue answering the question based on the results.</div><div class="bot-msg"><strong>ADW:</strong> <p>Here is a summary of the functions and logic in <code>forest_search.R</code>:</p>
<hr />
<h3><code>forest_search.R</code> ‚Äî Main Functions</h3>
<ol>
<li><strong>get_dfpred</strong></li>
<li>Generates a prediction dataset with a treatment recommendation flag (<code>treat.recommend</code>) based on a subgroup definition.</li>
<li>Uses either <code>dummy()</code> or <code>dummy2()</code> for factor encoding.</li>
<li>
<p>Subsets the data into those who meet the subgroup definition (assigned 0) and those who do not (assigned 1).</p>
</li>
<li>
<p><strong>forestsearch</strong></p>
</li>
<li>The main function for ForestSearch analysis, performing subgroup identification and consistency analysis for treatment effect heterogeneity.</li>
<li><strong>Inputs:</strong> Analysis data, variable names, confounders, parallelization arguments, prediction/test data, GRF/LASSO options, cut strategies, thresholds, and many other parameters for flexible configuration.</li>
<li><strong>Key Steps:</strong><ul>
<li>Checks and prepares input data, including handling missing data and variable existence.</li>
<li>Optionally runs GRF for variable selection and cut definition, including plotting if requested.</li>
<li>Calls <code>get_FSdata</code> to prepare the analysis dataset, including LASSO/GRF cuts and dummy coding.</li>
<li>Optionally screens confounders using GRF variable importance.</li>
<li>Prepares the data for subgroup search, dummy-coding confounders.</li>
<li>Runs the main subgroup search (<code>subgroup.search</code>) to identify subgroups with treatment effect heterogeneity.</li>
<li>If subgroups are found, runs consistency analysis (<code>subgroup.consistency</code>) to assess subgroup stability across splits.</li>
<li>Merges subgroup membership flags back to the analysis, prediction, and test datasets.</li>
<li>Returns a comprehensive list with all results, including subgroup definitions, candidate/evaluated confounders, prediction/test datasets, GRF results, plots, and all arguments used.</li>
</ul>
</li>
<li><strong>Error Handling:</strong> If any step fails, returns a minimal list with <code>sg.harm = NULL</code>.</li>
</ol>
<hr />
<p><strong>General Purpose:</strong><br />
This file provides the core ForestSearch workflow, integrating LASSO, GRF, and subgroup search/consistency analysis, and is designed for flexible, reproducible subgroup identification in survival or treatment effect heterogeneity studies.</p>
<p>If you want to see an example run, test a function, or integrate with your data, please specify your next step.</p></div><div class="user-msg"><strong>User:</strong> üìÅ[subgroup_consistency.R]</div><div class="user-msg"><strong>User:</strong> please inspect</div><div class="bot-msg"><strong>ADW:</strong> <p>üü¢Working:</p>
<pre><code class="language-R"># Read and display the contents of the subgroup_consistency.R file
subgroup_consistency_content &lt;- readLines('subgroup_consistency.R')
subgroup_consistency_content
</code></pre></div><div class="bot-msg"><strong>ADW:</strong> <p>‚úîÔ∏èTerminal output:</p>
<pre><code class="language-shell">  [1] &quot;#' Quietly Evaluate an Expression&quot;                                                                                                                                       
  [2] &quot;#'&quot;                                                                                                                                                                      
  [3] &quot;#' Suppresses console output for the evaluation of an expression.&quot;                                                                                                       
  [4] &quot;#'&quot;                                                                                                                                                                      
  [5] &quot;#' @param x An R expression to evaluate.&quot;                                                                                                                                
  [6] &quot;#' @return Invisibly returns the result of the expression.&quot;                                                                                                              
  [7] &quot;#' @export&quot;                                                                                                                                                              
  [8] &quot;&quot;                                                                                                                                                                        
  [9] &quot;quiet &lt;- function(x) {&quot;                                                                                                                                                  
 [10] &quot;  sink(tempfile())&quot;                                                                                                                                                      
 [11] &quot;  on.exit(sink())&quot;                                                                                                                                                       
 [12] &quot;  invisible(force(x))&quot;                                                                                                                                                   
 [13] &quot;}&quot;                                                                                                                                                                       
 [14] &quot;&quot;                                                                                                                                                                        
 [15] &quot;#' Sort Subgroups by Focus&quot;                                                                                                                                              
 [16] &quot;#'&quot;                                                                                                                                                                      
 [17] &quot;#' Sorts a data.table of subgroup results according to the specified focus.&quot;                                                                                             
 [18] &quot;#'&quot;                                                                                                                                                                      
 [19] &quot;#' @param result_new A data.table of subgroup results.&quot;                                                                                                                  
 [20] &quot;#' @param sg_focus Sorting focus: \&quot;hr\&quot;, \&quot;hrMaxSG\&quot;, \&quot;maxSG\&quot;, \&quot;hrMinSG\&quot;, \&quot;minSG\&quot;.&quot;                                                                               
 [21] &quot;#' @return A sorted data.table.&quot;                                                                                                                                         
 [22] &quot;#' @importFrom data.table setorder&quot;                                                                                                                                      
 [23] &quot;#' @export&quot;                                                                                                                                                              
 [24] &quot;&quot;                                                                                                                                                                        
 [25] &quot;sort_subgroups &lt;- function(result_new, sg_focus) {&quot;                                                                                                                      
 [26] &quot;  if (sg_focus == \&quot;hr\&quot;) data.table::setorder(result_new, -Pcons, -hr, K)&quot;                                                                                              
 [27] &quot;  if (sg_focus %in% c(\&quot;hrMaxSG\&quot;, \&quot;maxSG\&quot;)) data.table::setorder(result_new, -N, -Pcons, K)&quot;                                                                          
 [28] &quot;  if (sg_focus %in% c(\&quot;hrMinSG\&quot;, \&quot;minSG\&quot;)) data.table::setorder(result_new, N, -Pcons, K)&quot;                                                                           
 [29] &quot;  result_new&quot;                                                                                                                                                            
 [30] &quot;}&quot;                                                                                                                                                                       
 [31] &quot;&quot;                                                                                                                                                                        
 [32] &quot;#' Extract Subgroup Definition and Treatment Recommendation&quot;                                                                                                             
 [33] &quot;#'&quot;                                                                                                                                                                      
 [34] &quot;#' Identifies the subgroup definition and recommends treatment for each subject.&quot;                                                                                        
 [35] &quot;#'&quot;                                                                                                                                                                      
 [36] &quot;#' @param df The original data.frame.&quot;                                                                                                                                   
 [37] &quot;#' @param top_result The top subgroup result row.&quot;                                                                                                                       
 [38] &quot;#' @param index.Z Matrix of subgroup indices.&quot;                                                                                                                           
 [39] &quot;#' @param names.Z Names of covariates.&quot;                                                                                                                                  
 [40] &quot;#' @param confs_labels Label mapping for covariates.&quot;                                                                                                                    
 [41] &quot;#' @return A list with subgroup definition, labels, recommended treatment, and group id.&quot;                                                                                
 [42] &quot;#' @export&quot;                                                                                                                                                              
 [43] &quot;&quot;                                                                                                                                                                        
 [44] &quot;extract_subgroup &lt;- function(df, top_result, index.Z, names.Z, confs_labels) {&quot;                                                                                          
 [45] &quot;  grp1 &lt;- as.numeric(top_result$g)&quot;                                                                                                                                      
 [46] &quot;  m1 &lt;- as.numeric(top_result$m)&quot;                                                                                                                                        
 [47] &quot;  index1 &lt;- as.numeric(unlist(index.Z[m1, ]))&quot;                                                                                                                           
 [48] &quot;  this.1 &lt;- names.Z[index1 == 1]&quot;                                                                                                                                        
 [49] &quot;  this.1_label &lt;- unlist(lapply(this.1, FS_labels, confs_labels = confs_labels))&quot;                                                                                        
 [50] &quot;  id.harm &lt;- paste(paste(this.1, collapse = \&quot;==1 &amp; \&quot;), \&quot;==1\&quot;)&quot;                                                                                                       
 [51] &quot;  df.sub &lt;- subset(df, eval(parse(text = id.harm)))&quot;                                                                                                                     
 [52] &quot;  df.sub$treat.recommend &lt;- 0&quot;                                                                                                                                           
 [53] &quot;  id.noharm &lt;- paste(paste(this.1, collapse = \&quot;!=1 | \&quot;), \&quot;!=1\&quot;)&quot;                                                                                                     
 [54] &quot;  df.subC &lt;- subset(df, eval(parse(text = id.noharm)))&quot;                                                                                                                  
 [55] &quot;  df.subC$treat.recommend &lt;- 1&quot;                                                                                                                                          
 [56] &quot;  data.found &lt;- rbind(df.sub, df.subC)&quot;                                                                                                                                  
 [57] &quot;  list(&quot;                                                                                                                                                                 
 [58] &quot;    sg.harm = this.1,&quot;                                                                                                                                                   
 [59] &quot;    sg.harm_label = this.1_label,&quot;                                                                                                                                       
 [60] &quot;    df_flag = data.found[, c(\&quot;id\&quot;, \&quot;treat.recommend\&quot;)],&quot;                                                                                                             
 [61] &quot;    sg.harm.id = grp1&quot;                                                                                                                                                   
 [62] &quot;  )&quot;                                                                                                                                                                     
 [63] &quot;}&quot;                                                                                                                                                                       
 [64] &quot;&quot;                                                                                                                                                                        
 [65] &quot;#' Plot Subgroup Survival Curves&quot;                                                                                                                                        
 [66] &quot;#'&quot;                                                                                                                                                                      
 [67] &quot;#' Plots weighted Kaplan-Meier survival curves for a specified subgroup and its complement using the \\pkg{weightedSurv} package.&quot;                                       
 [68] &quot;#'&quot;                                                                                                                                                                      
 [69] &quot;#' @param df.sub A data frame containing data for the subgroup of interest.&quot;                                                                                             
 [70] &quot;#' @param df.subC A data frame containing data for the complement subgroup.&quot;                                                                                             
 [71] &quot;#' @param by.risk Numeric. The risk interval for plotting (passed to \\code{weightedSurv::df_counting}).&quot;                                                                
 [72] &quot;#' @param confs_labels Named character vector. Covariate label mapping (not used directly in this function, but may be used for labeling).&quot;                              
 [73] &quot;#' @param this.1_label Character. Label for the subgroup being plotted.&quot;                                                                                                 
 [74] &quot;#' @param top_result Data frame row. The top subgroup result row, expected to contain a \\code{Pcons} column for consistency criteria.&quot;                                  
 [75] &quot;#'&quot;                                                                                                                                                                      
 [76] &quot;#' @importFrom weightedSurv df_counting plot_weighted_km&quot;                                                                                                                
 [77] &quot;#' @export&quot;                                                                                                                                                              
 [78] &quot;&quot;                                                                                                                                                                        
 [79] &quot;plot_subgroup &lt;- function(df.sub, df.subC, by.risk, confs_labels, this.1_label, top_result) {&quot;                                                                           
 [80] &quot;  if (requireNamespace(\&quot;weightedSurv\&quot;, quietly = TRUE)) {&quot;                                                                                                             
 [81] &quot;    tte.name &lt;- \&quot;Y\&quot;&quot;                                                                                                                                                   
 [82] &quot;    event.name &lt;- \&quot;Event\&quot;&quot;                                                                                                                                             
 [83] &quot;    treat.name &lt;- \&quot;Treat\&quot;&quot;                                                                                                                                             
 [84] &quot;    con.lab &lt;- \&quot;control\&quot;&quot;                                                                                                                                              
 [85] &quot;    exp.lab &lt;- \&quot;treat\&quot;&quot;                                                                                                                                                
 [86] &quot;    dfcount &lt;- weightedSurv::df_counting(df.sub, tte.name = tte.name, event.name = event.name, treat.name = treat.name, arms = c(exp.lab, con.lab), by.risk = by.risk)&quot;  
 [87] &quot;    dfcountC &lt;- weightedSurv::df_counting(df.subC, tte.name = tte.name, event.name = event.name, treat.name = treat.name, arms = c(exp.lab, con.lab), by.risk = by.risk)&quot;
 [88] &quot;    par(mfrow = c(1, 2))&quot;                                                                                                                                                
 [89] &quot;    weightedSurv::plot_weighted_km(dfcount, conf.int = TRUE, show.logrank = TRUE, put.legend.lr = \&quot;topleft\&quot;, ymax = 1.05, xmed.fraction = 0.65)&quot;                       
 [90] &quot;    weightedSurv::plot_weighted_km(dfcountC, conf.int = TRUE, show.logrank = TRUE, put.legend.lr = \&quot;topleft\&quot;, ymax = 1.05, xmed.fraction = 0.65)&quot;                      
 [91] &quot;    cat(\&quot;*** Subgroup found:\&quot;, c(this.1_label), \&quot;\\n\&quot;)&quot;                                                                                                              
 [92] &quot;    cat(\&quot;% consistency criteria met=\&quot;, c(top_result$Pcons), \&quot;\\n\&quot;)&quot;                                                                                                  
 [93] &quot;  }  else {&quot;                                                                                                                                                             
 [94] &quot;    message(\&quot;Package 'weightedSurv' not available: skipping weighted KM plots.\&quot;)&quot;                                                                                      
 [95] &quot;  }&quot;                                                                                                                                                                     
 [96] &quot;}&quot;                                                                                                                                                                       
 [97] &quot;&quot;                                                                                                                                                                        
 [98] &quot;&quot;                                                                                                                                                                        
 [99] &quot;&quot;                                                                                                                                                                        
[100] &quot;&quot;                                                                                                                                                                        
[101] &quot;#' Output Subgroup Consistency Results&quot;                                                                                                                                  
[102] &quot;#'&quot;                                                                                                                                                                      
[103] &quot;#' Returns the top subgroup(s) and recommended treatment flags.&quot;                                                                                                         
[104] &quot;#'&quot;                                                                                                                                                                      
[105] &quot;#' @param df The original data.frame.&quot;                                                                                                                                   
[106] &quot;#' @param result_new Sorted subgroup results.&quot;                                                                                                                           
[107] &quot;#' @param sg_focus Sorting focus.&quot;                                                                                                                                       
[108] &quot;#' @param index.Z Matrix of subgroup indices.&quot;                                                                                                                           
[109] &quot;#' @param names.Z Names of covariates.&quot;                                                                                                                                  
[110] &quot;#' @param details Logical; print details.&quot;                                                                                                                               
[111] &quot;#' @param plot.sg Logical; plot subgroup curves.&quot;                                                                                                                        
[112] &quot;#' @param by.risk Risk interval for plotting.&quot;                                                                                                                           
[113] &quot;#' @param confs_labels Covariate label mapping.&quot;                                                                                                                         
[114] &quot;#' @return A list with results, subgroup definition, labels, flags, and group id.&quot;                                                                                       
[115] &quot;#' @importFrom data.table copy&quot;                                                                                                                                          
[116] &quot;#' @export&quot;                                                                                                                                                              
[117] &quot;&quot;                                                                                                                                                                        
[118] &quot;sg_consistency_out &lt;- function(df, result_new, sg_focus, index.Z, names.Z, details = FALSE, plot.sg = FALSE, by.risk = 12, confs_labels) {&quot;                              
[119] &quot;  result_new &lt;- sort_subgroups(result_new, sg_focus)&quot;                                                                                                                    
[120] &quot;  top_result &lt;- result_new[1, ]&quot;                                                                                                                                         
[121] &quot;  subgroup_info &lt;- extract_subgroup(df, top_result, index.Z, names.Z, confs_labels)&quot;                                                                                     
[122] &quot;  if (details &amp;&amp; plot.sg) {&quot;                                                                                                                                             
[123] &quot;    plot_subgroup(&quot;                                                                                                                                                      
[124] &quot;      subset(df, eval(parse(text = paste(paste(subgroup_info$sg.harm, collapse = \&quot;==1 &amp; \&quot;), \&quot;==1\&quot;)))),&quot;                                                              
[125] &quot;      subset(df, eval(parse(text = paste(paste(subgroup_info$sg.harm, collapse = \&quot;!=1 | \&quot;), \&quot;!=1\&quot;)))),&quot;                                                              
[126] &quot;      by.risk, confs_labels, subgroup_info$sg.harm_label, top_result&quot;                                                                                                    
[127] &quot;    )&quot;                                                                                                                                                                   
[128] &quot;  }&quot;                                                                                                                                                                     
[129] &quot;  result_out &lt;- data.table::copy(result_new)&quot;                                                                                                                            
[130] &quot;  list(&quot;                                                                                                                                                                 
[131] &quot;    result = result_out,&quot;                                                                                                                                                
[132] &quot;    sg.harm = subgroup_info$sg.harm,&quot;                                                                                                                                    
[133] &quot;    sg.harm_label = subgroup_info$sg.harm_label,&quot;                                                                                                                        
[134] &quot;    df_flag = subgroup_info$df_flag,&quot;                                                                                                                                    
[135] &quot;    sg.harm.id = subgroup_info$sg.harm.id&quot;                                                                                                                               
[136] &quot;  )&quot;                                                                                                                                                                     
[137] &quot;}&quot;                                                                                                                                                                       
[138] &quot;&quot;                                                                                                                                                                        
[139] &quot;#' Remove Redundant Subgroups&quot;                                                                                                                                           
[140] &quot;#'&quot;                                                                                                                                                                      
[141] &quot;#' Removes redundant subgroups from the results by checking for ties.&quot;                                                                                                   
[142] &quot;#'&quot;                                                                                                                                                                      
[143] &quot;#' @param found.hrs Data.table of found subgroups.&quot;                                                                                                                      
[144] &quot;#' @return Data.table of non-redundant subgroups.&quot;                                                                                                                       
[145] &quot;#' @export&quot;                                                                                                                                                              
[146] &quot;&quot;                                                                                                                                                                        
[147] &quot;remove_redundant_subgroups &lt;- function(found.hrs) {&quot;                                                                                                                     
[148] &quot;  found.new &lt;- found.hrs[order(found.hrs$HR, decreasing = TRUE), ]&quot;                                                                                                      
[149] &quot;  f1.hrs &lt;- found.new[1, ]&quot;                                                                                                                                              
[150] &quot;  temp &lt;- found.new[-c(1), ]&quot;                                                                                                                                            
[151] &quot;  temp2 &lt;- as.matrix(found.new[, c(\&quot;HR\&quot;, \&quot;n\&quot;, \&quot;E\&quot;, \&quot;K\&quot;, \&quot;L(HR)\&quot;, \&quot;U(HR)\&quot;)])&quot;                                                                                 
[152] &quot;  id_keep &lt;- which(round(diff(temp2, lag = 1), 6) != 0)&quot;                                                                                                                 
[153] &quot;  fkeep.hrs &lt;- temp[id_keep, ]&quot;                                                                                                                                          
[154] &quot;  na.omit(data.table::data.table(rbind(f1.hrs, fkeep.hrs)))&quot;                                                                                                             
[155] &quot;}&quot;                                                                                                                                                                       
[156] &quot;&quot;                                                                                                                                                                        
[157] &quot;#' Get Hazard Ratio from Split Data&quot;                                                                                                                                     
[158] &quot;#'&quot;                                                                                                                                                                      
[159] &quot;#' Calculates the hazard ratio from a split data set using Cox regression.&quot;                                                                                              
[160] &quot;#'&quot;                                                                                                                                                                      
[161] &quot;#' @param df Data frame with survival data.&quot;                                                                                                                             
[162] &quot;#' @return Numeric hazard ratio or NA if error.&quot;                                                                                                                         
[163] &quot;#' @importFrom survival coxph Surv&quot;                                                                                                                                      
[164] &quot;#' @export&quot;                                                                                                                                                              
[165] &quot;&quot;                                                                                                                                                                        
[166] &quot;get_split_hr &lt;- function(df) {&quot;                                                                                                                                          
[167] &quot;  hr &lt;- try((summary(coxph(Surv(Y, Event) ~ Treat, data = df, robust = FALSE))$conf.int), TRUE)&quot;                                                                         
[168] &quot;  if (inherits(hr, \&quot;try-error\&quot;)) return(NA_real_)&quot;                                                                                                                     
[169] &quot;  hr[1,1]&quot;                                                                                                                                                               
[170] &quot;}&quot;                                                                                                                                                                       
[171] &quot;&quot;                                                                                                                                                                        
[172] &quot;&quot;                                                                                                                                                                        
[173] &quot;#' Set up parallel processing for subgroup consistency&quot;                                                                                                                  
[174] &quot;#'&quot;                                                                                                                                                                      
[175] &quot;#' Sets up parallel processing using the specified approach and number of workers.&quot;                                                                                      
[176] &quot;#'&quot;                                                                                                                                                                      
[177] &quot;#' @param parallel_args List with \\code{plan} (character), \\code{workers} (integer), and \\code{show_message} (logical).&quot;                                              
[178] &quot;#' @return None. Sets up parallel backend.&quot;                                                                                                                              
[179] &quot;#' @importFrom future plan&quot;                                                                                                                                              
[180] &quot;#' @export&quot;                                                                                                                                                              
[181] &quot;&quot;                                                                                                                                                                        
[182] &quot;setup_parallel_SGcons &lt;- function(parallel_args = list(plan = \&quot;multisession\&quot;, workers = 4, show_message = TRUE)) {&quot;                                                    
[183] &quot;  plan_type &lt;- parallel_args$plan&quot;                                                                                                                                       
[184] &quot;  n_workers &lt;- parallel_args$workers&quot;                                                                                                                                    
[185] &quot;  show_message &lt;- parallel_args$show_message&quot;                                                                                                                            
[186] &quot;  if (is.null(plan_type)) stop(\&quot;parallel_args$plan must be specified.\&quot;)&quot;                                                                                               
[187] &quot;&quot;                                                                                                                                                                        
[188] &quot;  allowed_plans &lt;- c(\&quot;multisession\&quot;, \&quot;multicore\&quot;, \&quot;callr\&quot;)&quot;                                                                                                        
[189] &quot;&quot;                                                                                                                                                                        
[190] &quot;  if (!plan_type %in% allowed_plans) {&quot;                                                                                                                                  
[191] &quot;    stop(\&quot;plan_type must be one of: \&quot;, paste(allowed_plans, collapse = \&quot;, \&quot;))&quot;                                                                                       
[192] &quot;  }&quot;                                                                                                                                                                     
[193] &quot;&quot;                                                                                                                                                                        
[194] &quot;  max_cores &lt;- parallel::detectCores()&quot;                                                                                                                                  
[195] &quot;  if (is.null(n_workers) || !is.numeric(n_workers) || n_workers &lt; 1) {&quot;                                                                                                  
[196] &quot;    n_workers &lt;- 1&quot;                                                                                                                                                      
[197] &quot;  } else {&quot;                                                                                                                                                              
[198] &quot;    n_workers &lt;- min(n_workers, max_cores)&quot;                                                                                                                              
[199] &quot;  }&quot;                                                                                                                                                                     
[200] &quot;  if (plan_type == \&quot;multisession\&quot;) {&quot;                                                                                                                                  
[201] &quot;    plan(multisession, workers = n_workers)&quot;                                                                                                                             
[202] &quot; if(show_message) message(\&quot;Parallel plan: multisession with \&quot;, n_workers, \&quot; workers.\&quot;)&quot;                                                                              
[203] &quot;  } else if (plan_type == \&quot;multicore\&quot;) {&quot;                                                                                                                              
[204] &quot;    plan(multicore, workers = n_workers)&quot;                                                                                                                                
[205] &quot;  if(show_message)  message(\&quot;Parallel plan: multicore with \&quot;, n_workers, \&quot; workers.\&quot;)&quot;                                                                               
[206] &quot;  } else if (plan_type == \&quot;callr\&quot;) {&quot;                                                                                                                                  
[207] &quot;    if (!requireNamespace(\&quot;future.callr\&quot;, quietly = TRUE)) {&quot;                                                                                                          
[208] &quot;      stop(\&quot;The 'future.callr' package is required for the callr approach.\&quot;)&quot;                                                                                          
[209] &quot;    }&quot;                                                                                                                                                                   
[210] &quot;    plan(future.callr::callr, workers = n_workers)&quot;                                                                                                                      
[211] &quot;if(show_message) message(\&quot;Parallel plan: callr with \&quot;, n_workers, \&quot; workers.\&quot;)&quot;                                                                                      
[212] &quot;  } else {&quot;                                                                                                                                                              
[213] &quot;    stop(\&quot;Unknown parallel plan: \&quot;, plan_type)&quot;                                                                                                                        
[214] &quot;  }&quot;                                                                                                                                                                     
[215] &quot;}&quot;                                                                                                                                                                       
[216] &quot;&quot;                                                                                                                                                                        
[217] &quot;&quot;                                                                                                                                                                        
[218] &quot;#' Subgroup Consistency Evaluation&quot;                                                                                                                                      
[219] &quot;#'&quot;                                                                                                                                                                      
[220] &quot;#' Evaluates consistency of subgroups found in a survival analysis, using random splits and hazard ratio criteria.&quot;                                                      
[221] &quot;#'&quot;                                                                                                                                                                      
[222] &quot;#' @param df The original data.frame.&quot;                                                                                                                                   
[223] &quot;#' @param hr.subgroups Data.table of subgroup hazard ratio results.&quot;                                                                                                     
[224] &quot;#' @param hr.threshold Minimum hazard ratio for subgroup inclusion.&quot;                                                                                                     
[225] &quot;#' @param hr.consistency Minimum hazard ratio for consistency in splits.&quot;                                                                                                
[226] &quot;#' @param pconsistency.threshold Minimum proportion of splits meeting consistency.&quot;                                                                                      
[227] &quot;#' @param m1.threshold Maximum median survival for treatment arm.&quot;                                                                                                       
[228] &quot;#' @param n.splits Number of random splits for consistency evaluation.&quot;                                                                                                  
[229] &quot;#' @param details Logical; print details.&quot;                                                                                                                               
[230] &quot;#' @param stop.threshold Consistency threshold for early stopping.&quot;                                                                                                      
[231] &quot;#' @param by.risk Risk interval for plotting.&quot;                                                                                                                           
[232] &quot;#' @param plot.sg Logical; plot subgroup curves.&quot;                                                                                                                        
[233] &quot;#' @param maxk Maximum number of covariates in a subgroup.&quot;                                                                                                              
[234] &quot;#' @param Lsg Number of covariates.&quot;                                                                                                                                     
[235] &quot;#' @param confs_labels Covariate label mapping.&quot;                                                                                                                         
[236] &quot;#' @param sg_focus Sorting focus.&quot;                                                                                                                                       
[237] &quot;#' @param stop_Kgroups Maximum number of subgroups to identify.&quot;                                                                                                         
[238] &quot;#' @param checking Logical; for debugging.&quot;                                                                                                                              
[239] &quot;#' @param parallel_args List for parallel processing.&quot;                                                                                                                   
[240] &quot;#' @return A list with results for top subgroups and recommended treatment flags.&quot;                                                                                       
[241] &quot;#' @importFrom data.table copy&quot;                                                                                                                                          
[242] &quot;#' @importFrom survival coxph Surv&quot;                                                                                                                                      
[243] &quot;#' @export&quot;                                                                                                                                                              
[244] &quot;&quot;                                                                                                                                                                        
[245] &quot;subgroup.consistency &lt;- function(df, hr.subgroups, hr.threshold = 1.0, hr.consistency = 1.0, pconsistency.threshold = 0.9, m1.threshold = Inf, n.splits = 100,&quot;          
[246] &quot;details = FALSE, stop.threshold = 1.1, by.risk = 12, plot.sg = FALSE, maxk = 7, Lsg, confs_labels, sg_focus = \&quot;hr\&quot;, stop_Kgroups = 10,&quot;                                
[247] &quot;checking = FALSE, parallel_args = list(NULL)) {&quot;                                                                                                                         
[248] &quot;  names.Z &lt;- c(names(hr.subgroups[, -c(\&quot;grp\&quot;, \&quot;K\&quot;, \&quot;n\&quot;, \&quot;E\&quot;, \&quot;d1\&quot;, \&quot;m1\&quot;, \&quot;m0\&quot;, \&quot;HR\&quot;, \&quot;L(HR)\&quot;, \&quot;U(HR)\&quot;)]))&quot;                                           
[249] &quot;  if (length(names.Z) != Lsg) stop(\&quot;HR subgroup results not matching L, check subgroup search function\&quot;)&quot;                                                              
[250] &quot;  if (m1.threshold == Inf) {&quot;                                                                                                                                            
[251] &quot;    found.hrs &lt;- hr.subgroups[hr.subgroups$HR &gt;= hr.threshold, ]&quot;                                                                                                        
[252] &quot;  } else {&quot;                                                                                                                                                              
[253] &quot;    hr.subgroups &lt;- hr.subgroups[which(!is.na(hr.subgroups$m1)), ]&quot;                                                                                                      
[254] &quot;    found.hrs &lt;- hr.subgroups[hr.subgroups$HR &gt;= hr.threshold &amp; hr.subgroups$m1 &lt;= m1.threshold, ]&quot;                                                                      
[255] &quot;  }&quot;                                                                                                                                                                     
[256] &quot;  if (nrow(found.hrs) &gt; 1) {&quot;                                                                                                                                            
[257] &quot;    found.hrs &lt;- remove_redundant_subgroups(found.hrs)&quot;                                                                                                                  
[258] &quot;  }&quot;                                                                                                                                                                     
[259] &quot;  if (sg_focus == \&quot;maxSG\&quot;) found.hrs &lt;- found.hrs[order(found.hrs$n, decreasing = TRUE), ]&quot;                                                                            
[260] &quot;  if (sg_focus == \&quot;minSG\&quot;) found.hrs &lt;- found.hrs[order(found.hrs$n, decreasing = FALSE), ]&quot;                                                                           
[261] &quot;  index.Z &lt;- found.hrs[, -c(\&quot;grp\&quot;, \&quot;K\&quot;, \&quot;n\&quot;, \&quot;E\&quot;, \&quot;d1\&quot;, \&quot;m1\&quot;, \&quot;m0\&quot;, \&quot;HR\&quot;, \&quot;L(HR)\&quot;, \&quot;U(HR)\&quot;)]&quot;                                                        
[262] &quot;  if (dim(index.Z)[2] != Lsg) stop(\&quot;HR subgroup results not matching L, check subgroup search function\&quot;)&quot;                                                              
[263] &quot;&quot;                                                                                                                                                                        
[264] &quot;if(details) cat(\&quot;# of initial candidates\&quot;,c(nrow(found.hrs)),\&quot;\\n\&quot;)&quot;                                                                                                 
[265] &quot;&quot;                                                                                                                                                                        
[266] &quot;  maxsgs &lt;- min(c(nrow(found.hrs),stop_Kgroups))&quot;                                                                                                                        
[267] &quot;  # Restrict to top \&quot;stop_Kgroups\&quot;&quot;                                                                                                                                    
[268] &quot;  found.hrs &lt;- found.hrs[c(1:maxsgs)]&quot;                                                                                                                                   
[269] &quot;&quot;                                                                                                                                                                        
[270] &quot;if(details) cat(\&quot;# of candidates restricted to 'top 10'\&quot;, c(nrow(found.hrs)),\&quot;\\n\&quot;)&quot;                                                                                 
[271] &quot;&quot;                                                                                                                                                                        
[272] &quot;  res &lt;- NULL&quot;                                                                                                                                                           
[273] &quot;  any.found &lt;- 0&quot;                                                                                                                                                        
[274] &quot;  resultk &lt;- NULL&quot;                                                                                                                                                       
[275] &quot;  if (details) t.start &lt;- proc.time()[3]&quot;                                                                                                                                
[276] &quot;  # Standard lapply&quot;                                                                                                                                                     
[277] &quot;  if (length(parallel_args) == 0) {&quot;                                                                                                                                     
[278] &quot;    results_list &lt;- lapply(seq_len(nrow(found.hrs)), function(m) {&quot;                                                                                                      
[279] &quot;      # --- Begin: code for each subgroup ---&quot;                                                                                                                           
[280] &quot;      indexm &lt;- as.numeric(unlist(index.Z[m, ]))&quot;                                                                                                                        
[281] &quot;      this.m &lt;- names.Z[indexm == 1]&quot;                                                                                                                                    
[282] &quot;      this.m_label &lt;- unlist(lapply(this.m, FS_labels, confs_labels = confs_labels))&quot;                                                                                    
[283] &quot;      id.m &lt;- paste(paste(this.m, collapse = \&quot;==1 &amp; \&quot;), \&quot;==1\&quot;)&quot;                                                                                                      
[284] &quot;      df.sub &lt;- subset(df, eval(parse(text = id.m)))&quot;                                                                                                                    
[285] &quot;      df.x &lt;- data.table::data.table(df.sub)&quot;                                                                                                                            
[286] &quot;      set.seed(8316951)&quot;                                                                                                                                                 
[287] &quot;      N.x &lt;- nrow(df.x)&quot;                                                                                                                                                 
[288] &quot;      flag.consistency &lt;- sapply(seq_len(n.splits), function(bb) {&quot;                                                                                                      
[289] &quot;        in.split1 &lt;- sample(c(TRUE, FALSE), N.x, replace = TRUE, prob = c(0.5, 0.5))&quot;                                                                                    
[290] &quot;        df.x$insplit1 &lt;- in.split1&quot;                                                                                                                                      
[291] &quot;        df.x.split1 &lt;- subset(df.x, insplit1 == 1)&quot;                                                                                                                      
[292] &quot;        df.x.split2 &lt;- subset(df.x, insplit1 == 0)&quot;                                                                                                                      
[293] &quot;        hr.split1 &lt;- suppressWarnings(get_split_hr(df.x.split1))&quot;                                                                                                        
[294] &quot;        hr.split2 &lt;- suppressWarnings(get_split_hr(df.x.split2))&quot;                                                                                                        
[295] &quot;        if (!is.na(hr.split1) &amp;&amp; !is.na(hr.split2)) {&quot;                                                                                                                   
[296] &quot;          as.numeric(hr.split1 &gt; hr.consistency &amp; hr.split2 &gt; hr.consistency)&quot;                                                                                           
[297] &quot;        } else {&quot;                                                                                                                                                        
[298] &quot;          NA_real_&quot;                                                                                                                                                      
[299] &quot;        }&quot;                                                                                                                                                               
[300] &quot;      })&quot;                                                                                                                                                                
[301] &quot;      p.consistency &lt;- mean(flag.consistency, na.rm = TRUE)&quot;                                                                                                             
[302] &quot;      if (p.consistency &lt; pconsistency.threshold &amp;&amp; details){&quot;                                                                                                           
[303] &quot;        cat(\&quot;*** Not met: Subgroup, % Consistency =\&quot;, c(this.m_label, p.consistency), \&quot;\\n\&quot;)&quot;                                                                        
[304] &quot;      }&quot;                                                                                                                                                                 
[305] &quot;      if (p.consistency &gt;= pconsistency.threshold) {&quot;                                                                                                                    
[306] &quot;        k &lt;- length(this.m)&quot;                                                                                                                                             
[307] &quot;        covsm &lt;- rep(m, maxk)&quot;                                                                                                                                           
[308] &quot;        mindex &lt;- c(1:maxk)&quot;                                                                                                                                             
[309] &quot;        Mnames &lt;- paste(covsm, mindex, sep = \&quot;.\&quot;)&quot;                                                                                                                     
[310] &quot;        mfound &lt;- matrix(rep(\&quot;\&quot;, maxk))&quot;                                                                                                                               
[311] &quot;        mfound[c(1:k)] &lt;- this.m_label&quot;                                                                                                                                  
[312] &quot;        resultk &lt;- c(p.consistency, found.hrs$HR[m], found.hrs$n[m], found.hrs$E[m], found.hrs$grp[m], m, k, mfound)&quot;                                                    
[313] &quot;        names(resultk) &lt;- c(\&quot;Pcons\&quot;, \&quot;hr\&quot;, \&quot;N\&quot;, \&quot;E\&quot;, \&quot;g\&quot;, \&quot;m\&quot;, \&quot;K\&quot;, Mnames)&quot;                                                                               
[314] &quot;        if (details) {&quot;                                                                                                                                                  
[315] &quot;          cat(\&quot;Consistency met!\\n\&quot;)&quot;                                                                                                                                  
[316] &quot;          cat(\&quot;# of splits =\&quot;, c(n.splits), \&quot;\\n\&quot;)&quot;                                                                                                                  
[317] &quot;          cat(\&quot;**** Subgroup, % Consistency Met=\&quot;, c(this.m_label, p.consistency), \&quot;\\n\&quot;)&quot;                                                                           
[318] &quot;        }&quot;                                                                                                                                                               
[319] &quot;        return(resultk)&quot;                                                                                                                                                 
[320] &quot;      }&quot;                                                                                                                                                                 
[321] &quot;      # --- End: code for each subgroup ---&quot;                                                                                                                             
[322] &quot;      return(NULL)&quot;                                                                                                                                                      
[323] &quot;    })&quot;                                                                                                                                                                  
[324] &quot;  } else {&quot;                                                                                                                                                              
[325] &quot;    old_plan &lt;- future::plan()&quot;                                                                                                                                          
[326] &quot;    on.exit(future::plan(old_plan), add = TRUE)  # Restore plan on exit&quot;                                                                                                 
[327] &quot;    setup_parallel_SGcons(parallel_args)&quot;                                                                                                                                
[328] &quot;    results_list &lt;- future.apply::future_lapply(seq_len(nrow(found.hrs)), function(m) {&quot;                                                                                 
[329] &quot;      # --- Begin: code for each subgroup ---&quot;                                                                                                                           
[330] &quot;      indexm &lt;- as.numeric(unlist(index.Z[m, ]))&quot;                                                                                                                        
[331] &quot;      this.m &lt;- names.Z[indexm == 1]&quot;                                                                                                                                    
[332] &quot;      this.m_label &lt;- unlist(lapply(this.m, FS_labels, confs_labels = confs_labels))&quot;                                                                                    
[333] &quot;      id.m &lt;- paste(paste(this.m, collapse = \&quot;==1 &amp; \&quot;), \&quot;==1\&quot;)&quot;                                                                                                      
[334] &quot;      df.sub &lt;- subset(df, eval(parse(text = id.m)))&quot;                                                                                                                    
[335] &quot;      df.x &lt;- data.table::data.table(df.sub)&quot;                                                                                                                            
[336] &quot;      set.seed(8316951)&quot;                                                                                                                                                 
[337] &quot;      N.x &lt;- nrow(df.x)&quot;                                                                                                                                                 
[338] &quot;      flag.consistency &lt;- sapply(seq_len(n.splits), function(bb) {&quot;                                                                                                      
[339] &quot;        in.split1 &lt;- sample(c(TRUE, FALSE), N.x, replace = TRUE, prob = c(0.5, 0.5))&quot;                                                                                    
[340] &quot;        df.x$insplit1 &lt;- in.split1&quot;                                                                                                                                      
[341] &quot;        df.x.split1 &lt;- subset(df.x, insplit1 == 1)&quot;                                                                                                                      
[342] &quot;        df.x.split2 &lt;- subset(df.x, insplit1 == 0)&quot;                                                                                                                      
[343] &quot;        hr.split1 &lt;- suppressWarnings(get_split_hr(df.x.split1))&quot;                                                                                                        
[344] &quot;        hr.split2 &lt;- suppressWarnings(get_split_hr(df.x.split2))&quot;                                                                                                        
[345] &quot;        if (!is.na(hr.split1) &amp;&amp; !is.na(hr.split2)) {&quot;                                                                                                                   
[346] &quot;          as.numeric(hr.split1 &gt; hr.consistency &amp; hr.split2 &gt; hr.consistency)&quot;                                                                                           
[347] &quot;        } else {&quot;                                                                                                                                                        
[348] &quot;          NA_real_&quot;                                                                                                                                                      
[349] &quot;        }&quot;                                                                                                                                                               
[350] &quot;      })&quot;                                                                                                                                                                
[351] &quot;      p.consistency &lt;- mean(flag.consistency, na.rm = TRUE)&quot;                                                                                                             
[352] &quot;      if (p.consistency &lt; pconsistency.threshold &amp; details){&quot;                                                                                                            
[353] &quot;        cat(\&quot;*** Not met: Subgroup, % Consistency =\&quot;, c(this.m_label, p.consistency), \&quot;\\n\&quot;)&quot;                                                                        
[354] &quot;      }&quot;                                                                                                                                                                 
[355] &quot;      if (p.consistency &gt;= pconsistency.threshold) {&quot;                                                                                                                    
[356] &quot;        k &lt;- length(this.m)&quot;                                                                                                                                             
[357] &quot;        covsm &lt;- rep(\&quot;M\&quot;, maxk)&quot;                                                                                                                                       
[358] &quot;        mindex &lt;- c(1:maxk)&quot;                                                                                                                                             
[359] &quot;        Mnames &lt;- paste(covsm, mindex, sep = \&quot;.\&quot;)&quot;                                                                                                                     
[360] &quot;        mfound &lt;- matrix(rep(\&quot;\&quot;, maxk))&quot;                                                                                                                               
[361] &quot;        mfound[c(1:k)] &lt;- this.m_label&quot;                                                                                                                                  
[362] &quot;        resultk &lt;- c(p.consistency, found.hrs$HR[m], found.hrs$n[m], found.hrs$E[m], found.hrs$grp[m], m, k, mfound)&quot;                                                    
[363] &quot;        names(resultk) &lt;- c(\&quot;Pcons\&quot;, \&quot;hr\&quot;, \&quot;N\&quot;, \&quot;E\&quot;, \&quot;g\&quot;, \&quot;m\&quot;, \&quot;K\&quot;, Mnames)&quot;                                                                               
[364] &quot;        if (details) {&quot;                                                                                                                                                  
[365] &quot;          cat(\&quot;Consistency met!\\n\&quot;)&quot;                                                                                                                                  
[366] &quot;          cat(\&quot;# of splits =\&quot;, c(n.splits), \&quot;\\n\&quot;)&quot;                                                                                                                  
[367] &quot;          cat(\&quot;**** Subgroup, % Consistency Met=\&quot;, c(this.m_label, p.consistency), \&quot;\\n\&quot;)&quot;                                                                           
[368] &quot;        }&quot;                                                                                                                                                               
[369] &quot;        return(resultk)&quot;                                                                                                                                                 
[370] &quot;      }&quot;                                                                                                                                                                 
[371] &quot;      # --- End: code for each subgroup ---&quot;                                                                                                                             
[372] &quot;      return(NULL)&quot;                                                                                                                                                      
[373] &quot;    }, future.seed = TRUE)&quot;                                                                                                                                              
[374] &quot;  }&quot;                                                                                                                                                                     
[375] &quot;  res &lt;- data.table::as.data.table(do.call(rbind, results_list))&quot;                                                                                                        
[376] &quot;  any.found &lt;- nrow(res)&quot;                                                                                                                                                
[377] &quot;  out_hr &lt;- out_maxSG &lt;- out_minSG &lt;- NULL&quot;                                                                                                                              
[378] &quot;  df_flag &lt;- sg.harm &lt;- sg.harm.id &lt;- NULL&quot;                                                                                                                              
[379] &quot;  if (any.found &gt; 0) {&quot;                                                                                                                                                  
[380] &quot;    cols_to_numeric &lt;- c(\&quot;Pcons\&quot;, \&quot;hr\&quot;, \&quot;N\&quot;, \&quot;E\&quot;, \&quot;K\&quot;)&quot;                                                                                                        
[381] &quot;    res[, (cols_to_numeric) := lapply(.SD, as.numeric), .SDcols = cols_to_numeric]&quot;                                                                                      
[382] &quot;    result_new &lt;- data.table::copy(res)&quot;                                                                                                                                 
[383] &quot;&quot;                                                                                                                                                                        
[384] &quot;    sgdetails &lt;- ifelse(plot.sg &amp; sg_focus == \&quot;hr\&quot;, TRUE, FALSE)&quot;                                                                                                      
[385] &quot;    out_hr &lt;- sg_consistency_out(df = df, result_new = result_new, sg_focus = \&quot;hr\&quot;, details = sgdetails,&quot;                                                              
[386] &quot;                                 plot.sg = sgdetails, index.Z = index.Z, names.Z = names.Z, by.risk = by.risk, confs_labels = confs_labels)&quot;                             
[387] &quot;    sgdetails &lt;- ifelse(plot.sg &amp; sg_focus %in% c(\&quot;hrMaxSG\&quot;, \&quot;maxSG\&quot;), TRUE, FALSE)&quot;                                                                                 
[388] &quot;    out_maxSG &lt;- sg_consistency_out(df = df, result_new = result_new, sg_focus = \&quot;maxSG\&quot;, details = sgdetails,&quot;                                                        
[389] &quot;                                    plot.sg = sgdetails, index.Z = index.Z, names.Z = names.Z, by.risk = by.risk, confs_labels = confs_labels)&quot;                          
[390] &quot;    sgdetails &lt;- ifelse(plot.sg &amp; sg_focus %in% c(\&quot;hrMinSG\&quot;, \&quot;minSG\&quot;), TRUE, FALSE)&quot;                                                                                 
[391] &quot;    out_minSG &lt;- sg_consistency_out(df = df, result_new = result_new, sg_focus = \&quot;minSG\&quot;, details = sgdetails,&quot;                                                        
[392] &quot;                                    plot.sg = sgdetails, index.Z = index.Z, names.Z = names.Z, by.risk = by.risk, confs_labels = confs_labels)&quot;                          
[393] &quot;&quot;                                                                                                                                                                        
[394] &quot;    # Create a mapping from sg_focus to the corresponding object&quot;                                                                                                        
[395] &quot;    sg_map &lt;- list(&quot;                                                                                                                                                     
[396] &quot;      hr      = out_hr,&quot;                                                                                                                                                 
[397] &quot;      hrMaxSG = out_maxSG,&quot;                                                                                                                                              
[398] &quot;      maxSG   = out_maxSG,&quot;                                                                                                                                              
[399] &quot;      hrMinSG = out_minSG,&quot;                                                                                                                                              
[400] &quot;      minSG   = out_minSG&quot;                                                                                                                                               
[401] &quot;    )&quot;                                                                                                                                                                   
[402] &quot;     # Check if sg_focus is valid&quot;                                                                                                                                       
[403] &quot;    if (!sg_focus %in% names(sg_map)) {&quot;                                                                                                                                 
[404] &quot;      stop(sprintf(\&quot;Unknown sg_focus value: %s\&quot;, sg_focus))&quot;                                                                                                           
[405] &quot;    }&quot;                                                                                                                                                                   
[406] &quot;    # Extract the relevant object&quot;                                                                                                                                       
[407] &quot;    sg_obj &lt;- sg_map[[sg_focus]]&quot;                                                                                                                                        
[408] &quot;    # Assign variables&quot;                                                                                                                                                  
[409] &quot;    df_flag    &lt;- sg_obj$df_flag&quot;                                                                                                                                        
[410] &quot;    sg.harm    &lt;- sg_obj$sg.harm_label&quot;                                                                                                                                  
[411] &quot;    sg.harm.id &lt;- sg_obj$sg.harm.id&quot;                                                                                                                                     
[412] &quot;&quot;                                                                                                                                                                        
[413] &quot;    if (details) cat(\&quot;SG focus=\&quot;, c(sg_focus), \&quot;\\n\&quot;)&quot;                                                                                                               
[414] &quot;  }&quot;                                                                                                                                                                     
[415] &quot;  if (details) {&quot;                                                                                                                                                        
[416] &quot;    t.end &lt;- proc.time()[3]&quot;                                                                                                                                             
[417] &quot;    t.min &lt;- (t.end - t.start) / 60&quot;                                                                                                                                     
[418] &quot;    cat(\&quot;Subgroup Consistency Minutes=\&quot;, c(t.min), \&quot;\\n\&quot;)&quot;                                                                                                           
[419] &quot;    if (any.found &gt; 0) cat(\&quot;Subgroup found (FS)\\n\&quot;)&quot;                                                                                                                  
[420] &quot;    if (any.found == 0) cat(\&quot;NO subgroup found (FS)\\n\&quot;)&quot;                                                                                                              
[421] &quot;  }&quot;                                                                                                                                                                     
[422] &quot;  list(out_hr = out_hr, out_maxSG = out_maxSG, out_minSG = out_minSG, df_flag = df_flag, sg.harm = sg.harm, sg.harm.id = sg.harm.id)&quot;                                    
[423] &quot;}&quot;                                                                                                                                                                       
</code></pre></div><div class="user-msg"><strong>User:</strong> Continue answering the question based on the results.</div><div class="bot-msg"><strong>ADW:</strong> <p>Here is a summary of the functions and logic in <code>subgroup_consistency.R</code>:</p>
<hr />
<h3><code>subgroup_consistency.R</code> ‚Äî Main Functions</h3>
<ol>
<li><strong>quiet</strong></li>
<li>
<p>Suppresses console output for the evaluation of an expression.</p>
</li>
<li>
<p><strong>sort_subgroups</strong></p>
</li>
<li>
<p>Sorts a data.table of subgroup results according to the specified focus (e.g., by HR, size, or consistency).</p>
</li>
<li>
<p><strong>extract_subgroup</strong></p>
</li>
<li>
<p>Identifies the subgroup definition and recommends treatment for each subject, returning subgroup-defining variables, labels, treatment flags, and group id.</p>
</li>
<li>
<p><strong>plot_subgroup</strong></p>
</li>
<li>
<p>Plots weighted Kaplan-Meier survival curves for a specified subgroup and its complement using the <code>weightedSurv</code> package.</p>
</li>
<li>
<p><strong>sg_consistency_out</strong></p>
</li>
<li>
<p>Returns the top subgroup(s) and recommended treatment flags, with optional plotting and details.</p>
</li>
<li>
<p><strong>remove_redundant_subgroups</strong></p>
</li>
<li>
<p>Removes redundant subgroups from the results by checking for ties in HR and other key metrics.</p>
</li>
<li>
<p><strong>get_split_hr</strong></p>
</li>
<li>
<p>Calculates the hazard ratio from a split data set using Cox regression.</p>
</li>
<li>
<p><strong>setup_parallel_SGcons</strong></p>
</li>
<li>
<p>Sets up parallel processing for subgroup consistency using the specified approach and number of workers (supports multisession, multicore, callr).</p>
</li>
<li>
<p><strong>subgroup.consistency</strong></p>
</li>
<li>Main function for evaluating the consistency of subgroups found in a survival analysis:<ul>
<li>Filters subgroups by HR and median survival thresholds.</li>
<li>Removes redundant subgroups.</li>
<li>For each candidate subgroup, repeatedly splits the data and checks if the HR consistency threshold is met in both splits.</li>
<li>Returns only subgroups meeting the consistency threshold in a sufficient proportion of splits.</li>
<li>Supports both serial and parallel execution.</li>
<li>Returns a list with results for top subgroups, recommended treatment flags, and subgroup definitions.</li>
</ul>
</li>
</ol>
<hr />
<p><strong>General Purpose:</strong><br />
This file provides the tools for post-hoc evaluation of subgroup stability/consistency, including repeated random splits, HR thresholding, and parallelization. It is a key component for validating the robustness of subgroups identified by ForestSearch or similar methods.</p>
<p>If you want to see an example run, test a function, or integrate with your data, please specify your next step.</p></div><div class="user-msg"><strong>User:</strong> Please provide a flowchart diagram showing the relationship between the functions</div><div class="bot-msg"><strong>ADW:</strong> <p>Certainly! Here is a textual flowchart diagram showing the relationships and main data flow between the key functions in your ForestSearch framework, based on the code you provided. This diagram focuses on the main analysis pipeline, including data preparation, subgroup identification, GRF/LASSO, bootstrap, and consistency evaluation.</p>
<hr />
<pre><code class="language-mermaid">flowchart TD
    A[forestsearch (main entry)] --&gt; B[get_FSdata]
    A --&gt; C[grf.subg.harm.survival]
    A --&gt; D[subgroup.search]
    A --&gt; E[subgroup.consistency]
    A --&gt; F[get_dfpred]
    A --&gt; G[SG_tab_estimates]
    A --&gt; H[forestsearch_bootstrap_dofuture]
    H --&gt; I[bootstrap_results]
    H --&gt; J[bootstrap_ystar]
    H --&gt; K[get_dfRes]
    H --&gt; L[get_Cox_sg]
    H --&gt; M[ci_est]
    H --&gt; N[get_targetEst]
    H --&gt; O[fit_cox_models]
    H --&gt; P[build_cox_formula]
    H --&gt; Q[ensure_packages]
    H --&gt; R[setup_parallel_SGcons]
    E --&gt; S[sort_subgroups]
    E --&gt; T[extract_subgroup]
    E --&gt; U[sg_consistency_out]
    E --&gt; V[remove_redundant_subgroups]
    E --&gt; W[get_split_hr]
    E --&gt; R
    B --&gt; X[lasso_selection]
    B --&gt; Y[get_conf_force]
    B --&gt; Z[filter_by_lassokeep]
    B --&gt; AA[is.continuous]
    B --&gt; AB[cut_var]
    B --&gt; AC[process_conf_force_expr]
    B --&gt; AD[dummy / dummy2]
    C --&gt; AE[policytree::policy_tree]
    C --&gt; AF[grf::causal_survival_forest]
    C --&gt; AG[double_robust_scores]
    C --&gt; AH[stats::aggregate]
    D --&gt; AI[get_combinations_info]
    D --&gt; AJ[get_subgroup_membership]
    D --&gt; AK[get_covs_in]
    D --&gt; AL[extract_idx_flagredundancy]
    G --&gt; AM[analyze_subgroup]
    AM --&gt; AN[cox_summary]
    AM --&gt; AO[km_summary]
    AM --&gt; AP[rmst_calculation]
    AM --&gt; AQ[calculate_counts]
    AM --&gt; AR[calculate_potential_hr]
    G --&gt; AS[prepare_subgroup_data]
    G --&gt; AT[format_results]
    G --&gt; AU[format_CI]
</code></pre>
<hr />
<h3>Explanation</h3>
<ul>
<li><strong>forestsearch</strong> is the main entry point, orchestrating the workflow.</li>
<li><strong>get_FSdata</strong> prepares the data, using helpers for LASSO, forced cuts, dummy coding, etc.</li>
<li><strong>grf.subg.harm.survival</strong> and <strong>lasso_selection</strong> are used for variable selection and cut definition.</li>
<li><strong>subgroup.search</strong> identifies candidate subgroups.</li>
<li><strong>subgroup.consistency</strong> evaluates the stability of subgroups using repeated splits and parallelization.</li>
<li><strong>forestsearch_bootstrap_dofuture</strong> manages the bootstrap analysis, calling a suite of helpers for Cox models, bias correction, and confidence intervals.</li>
<li><strong>SG_tab_estimates</strong> and related summary functions format and summarize subgroup results.</li>
<li>Helper functions (e.g., for dummy coding, cut generation, and statistics) are called throughout the pipeline.</li>
</ul>
<hr />
<p>If you would like a graphical version (e.g., a .png or .pdf), let me know and I can generate and provide the image.</p></div><div class="user-msg"><strong>User:</strong> graphical version, please, using grViz</div><div class="bot-msg"><strong>ADW:</strong> <p>üü¢Working:</p>
<pre><code class="language-R">library(DiagrammeR)
graph_code &lt;- 'digraph forestsearch_flow {
  node [shape=box, style=filled, fillcolor=&quot;#e6f2ff&quot;, fontname=&quot;Arial&quot;]
  edge [fontname=&quot;Arial&quot;]

  forestsearch [label=&quot;forestsearch (main entry)&quot;, fillcolor=&quot;#b3d1ff&quot;]
  get_FSdata [label=&quot;get_FSdata&quot;]
  grf_subg [label=&quot;grf.subg.harm.survival&quot;]
  subgroup_search [label=&quot;subgroup.search&quot;]
  subgroup_consistency [label=&quot;subgroup.consistency&quot;]
  get_dfpred [label=&quot;get_dfpred&quot;]
  SG_tab_estimates [label=&quot;SG_tab_estimates&quot;]
  forestsearch_bootstrap [label=&quot;forestsearch_bootstrap_dofuture&quot;]

  # Main flow
  forestsearch -&gt; get_FSdata
  forestsearch -&gt; grf_subg
  forestsearch -&gt; subgroup_search
  forestsearch -&gt; subgroup_consistency
  forestsearch -&gt; get_dfpred
  forestsearch -&gt; SG_tab_estimates
  forestsearch -&gt; forestsearch_bootstrap

  # get_FSdata helpers
  get_FSdata -&gt; lasso_selection
  get_FSdata -&gt; get_conf_force
  get_FSdata -&gt; filter_by_lassokeep
  get_FSdata -&gt; is_continuous
  get_FSdata -&gt; cut_var
  get_FSdata -&gt; process_conf_force_expr
  get_FSdata -&gt; dummy
  get_FSdata -&gt; dummy2

  # grf_subg helpers
  grf_subg -&gt; policy_tree
  grf_subg -&gt; causal_survival_forest
  grf_subg -&gt; double_robust_scores
  grf_subg -&gt; aggregate

  # subgroup_search helpers
  subgroup_search -&gt; get_combinations_info
  subgroup_search -&gt; get_subgroup_membership
  subgroup_search -&gt; get_covs_in
  subgroup_search -&gt; extract_idx_flagredundancy

  # subgroup_consistency helpers
  subgroup_consistency -&gt; sort_subgroups
  subgroup_consistency -&gt; extract_subgroup
  subgroup_consistency -&gt; sg_consistency_out
  subgroup_consistency -&gt; remove_redundant_subgroups
  subgroup_consistency -&gt; get_split_hr
  subgroup_consistency -&gt; setup_parallel_SGcons

  # forestsearch_bootstrap helpers
  forestsearch_bootstrap -&gt; bootstrap_results
  forestsearch_bootstrap -&gt; bootstrap_ystar
  forestsearch_bootstrap -&gt; get_dfRes
  forestsearch_bootstrap -&gt; get_Cox_sg
  forestsearch_bootstrap -&gt; ci_est
  forestsearch_bootstrap -&gt; get_targetEst
  forestsearch_bootstrap -&gt; fit_cox_models
  forestsearch_bootstrap -&gt; build_cox_formula
  forestsearch_bootstrap -&gt; ensure_packages
  forestsearch_bootstrap -&gt; setup_parallel_SGcons

  # SG_tab_estimates helpers
  SG_tab_estimates -&gt; analyze_subgroup
  analyze_subgroup [label=&quot;analyze_subgroup&quot;]
  analyze_subgroup -&gt; cox_summary
  analyze_subgroup -&gt; km_summary
  analyze_subgroup -&gt; rmst_calculation
  analyze_subgroup -&gt; calculate_counts
  analyze_subgroup -&gt; calculate_potential_hr
  SG_tab_estimates -&gt; prepare_subgroup_data
  SG_tab_estimates -&gt; format_results
  SG_tab_estimates -&gt; format_CI
}
'
DiagrammeR::grViz(graph_code)
</code></pre></div><div class="bot-msg"><strong>ADW:</strong> <p>‚úîÔ∏èTerminal output:</p>
<pre><code class="language-shell">HTML widgets cannot be represented in plain text (need html)
</code></pre></div><div class="user-msg"><strong>User:</strong> Please write as flowchart <- grViz(" digraph flowchart {  }", width = 800, height=400)</div><div class="bot-msg"><strong>ADW:</strong> <p>Certainly! Here is the code you can use in R to generate the ForestSearch function relationship flowchart using <code>DiagrammeR::grViz</code>. You can copy and run this in your R environment.</p>
<pre><code class="language-r">library(DiagrammeR)

flowchart &lt;- grViz(&quot;
digraph flowchart {
  graph [rankdir = LR]
  node [shape=box, style=filled, fillcolor=\&quot;#e6f2ff\&quot;, fontname=\&quot;Arial\&quot;]
  edge [fontname=\&quot;Arial\&quot;]

  forestsearch [label=\&quot;forestsearch (main entry)\&quot;, fillcolor=\&quot;#b3d1ff\&quot;]
  get_FSdata [label=\&quot;get_FSdata\&quot;]
  grf_subg [label=\&quot;grf.subg.harm.survival\&quot;]
  subgroup_search [label=\&quot;subgroup.search\&quot;]
  subgroup_consistency [label=\&quot;subgroup.consistency\&quot;]
  get_dfpred [label=\&quot;get_dfpred\&quot;]
  SG_tab_estimates [label=\&quot;SG_tab_estimates\&quot;]
  forestsearch_bootstrap [label=\&quot;forestsearch_bootstrap_dofuture\&quot;]

  # Main flow
  forestsearch -&gt; get_FSdata
  forestsearch -&gt; grf_subg
  forestsearch -&gt; subgroup_search
  forestsearch -&gt; subgroup_consistency
  forestsearch -&gt; get_dfpred
  forestsearch -&gt; SG_tab_estimates
  forestsearch -&gt; forestsearch_bootstrap

  # get_FSdata helpers
  get_FSdata -&gt; lasso_selection
  get_FSdata -&gt; get_conf_force
  get_FSdata -&gt; filter_by_lassokeep
  get_FSdata -&gt; is_continuous
  get_FSdata -&gt; cut_var
  get_FSdata -&gt; process_conf_force_expr
  get_FSdata -&gt; dummy
  get_FSdata -&gt; dummy2

  # grf_subg helpers
  grf_subg -&gt; policy_tree
  grf_subg -&gt; causal_survival_forest
  grf_subg -&gt; double_robust_scores
  grf_subg -&gt; aggregate

  # subgroup_search helpers
  subgroup_search -&gt; get_combinations_info
  subgroup_search -&gt; get_subgroup_membership
  subgroup_search -&gt; get_covs_in
  subgroup_search -&gt; extract_idx_flagredundancy

  # subgroup_consistency helpers
  subgroup_consistency -&gt; sort_subgroups
  subgroup_consistency -&gt; extract_subgroup
  subgroup_consistency -&gt; sg_consistency_out
  subgroup_consistency -&gt; remove_redundant_subgroups
  subgroup_consistency -&gt; get_split_hr
  subgroup_consistency -&gt; setup_parallel_SGcons

  # forestsearch_bootstrap helpers
  forestsearch_bootstrap -&gt; bootstrap_results
  forestsearch_bootstrap -&gt; bootstrap_ystar
  forestsearch_bootstrap -&gt; get_dfRes
  forestsearch_bootstrap -&gt; get_Cox_sg
  forestsearch_bootstrap -&gt; ci_est
  forestsearch_bootstrap -&gt; get_targetEst
  forestsearch_bootstrap -&gt; fit_cox_models
  forestsearch_bootstrap -&gt; build_cox_formula
  forestsearch_bootstrap -&gt; ensure_packages
  forestsearch_bootstrap -&gt; setup_parallel_SGcons

  # SG_tab_estimates helpers
  SG_tab_estimates -&gt; analyze_subgroup
  analyze_subgroup [label=\&quot;analyze_subgroup\&quot;]
  analyze_subgroup -&gt; cox_summary
  analyze_subgroup -&gt; km_summary
  analyze_subgroup -&gt; rmst_calculation
  analyze_subgroup -&gt; calculate_counts
  analyze_subgroup -&gt; calculate_potential_hr
  SG_tab_estimates -&gt; prepare_subgroup_data
  SG_tab_estimates -&gt; format_results
  SG_tab_estimates -&gt; format_CI
}
&quot;, width = 800, height = 400)
</code></pre>
<p>This will create an interactive flowchart in your R session showing the relationships between the main ForestSearch functions and their helpers.</p></div><div class="user-msg"><strong>User:</strong> bootstrap_results <- function(fs.est, df_boot_analysis, cox.formula.boot, nb_boots, show_three, H_obs, Hc_obs, reset_parallel, boot_workers) {
  NN <- nrow(df_boot_analysis)
  id0 <- seq_len(NN)
  foreach::foreach(
    boot = seq_len(nb_boots),
    .options.future = list(seed = TRUE,
                           add = c("dfnew_boot","dfnew","calc_cov",  "calculate_counts", "analyze_subgroups", "calculate_potential_hr","ci.est","count.id","CV_sgs",
                           "cox_summary","df_counting","double_robust_scores", "extract_subgroup","format_results", "get_targetEst","getci_Cox",
                           "getCIs","grf.estimates.out","hrCI_format","km_summary","n_pcnt","plot_subgroup","plot_weighted_km",
                           "prepare_subgroup_data","quiet","rmst_calculation","sg_tables","sort_subgroups","SummaryStat","var_summary",
                           "get_FSdata", "dummy","run_bootstrap",
                             "forestsearch", "forestsearch_bootstrap_dofuture","get_combinations_info",
                             "get_dfpred",
                             "grf.subg.harm.survival",
                             "subgroup.search",
                             "subgroup.consistency",
                             "lasso_selection",
                             "get_Cox_sg",
                             "get_conf_force",
                             "filter_by_lassokeep",
                             "is.continuous",
                             "process_conf_force_expr",
                             "is_flag_continuous",
                             "is_flag_drop", "acm.disjctif",  "acm.util.df2", "acm.util.df", "dummy2","ztrail","one.zero",
                             "get_dfRes", "get_subgroup_membership",
                             "SG_tab_estimates",
                             "prepare_data",
                             "run_grf",
                             "evaluate_subgroups",
                             "summarize_results",
                              "clean_data", "qlow", "qhigh","FS_labels","thiscut","get_cut_name",
                             "bootstrap_results", "remove_redundant_subgroups", "sg_consistency_out","get_split_hr","cut_var",
                             "bootstrap_ystar", "ensure_packages", "fit_cox_models", "build_cox_formula", "cox.formula.boot",
                             "format_CI","setup_parallel_SGcons", "get_covs_in", "extract_idx_flagredundancy"
                           )),
    .combine = "rbind",
    .errorhandling = "pass"
  ) %dofuture% {
    show3 <- FALSE
    if (show_three) show3 <- (boot <= 3)
    set.seed(8316951 + boot * 100)
    in_boot <- sample.int(NN, size = NN, replace = TRUE)
    df_boot <- df_boot_analysis[in_boot, ]
    df_boot$id_boot <- seq_len(nrow(df_boot))
    # Bootstrap data evaluated at H: H_star
    fitH_star <- get_Cox_sg(df_sg = subset(df_boot, treat.recommend == 0), cox.formula = cox.formula.boot, est.loghr = TRUE)
    H_star <- fitH_star$est_obs
    fitHc_star <- get_Cox_sg(df_sg = subset(df_boot, treat.recommend == 1), cox.formula = cox.formula.boot, est.loghr = TRUE)
    Hc_star <- fitHc_star$est_obs
    # Bias corrections
    H_biasadj_1 <- H_biasadj_2 <- NA
    Hc_biasadj_1 <- Hc_biasadj_2 <- NA
    tmins_search <- NA
    max_sg_est <- NA
    prop_maxk <- NA
    L <- NA
    max_count <- NA
    # Drop initial confounders
    drop.vars <- c(fs.est$confounders.candidate, "treat.recommend")
    dfnew <- df_boot_analysis[, !(names(df_boot_analysis) %in% drop.vars)]
    dfnew_boot <- df_boot[, !(names(df_boot) %in% drop.vars)]
    # Extract arguments in forestsearch (observed) data analysis
    args_FS_boot <- fs.est$args_call_all
    args_FS_boot$df.analysis <- dfnew_boot
    args_FS_boot$df.predict <- dfnew
    args_FS_boot$details <- show3
    args_FS_boot$showten_subgroups <- FALSE
    args_FS_boot$plot.sg <- FALSE
    # Re-do grf for bootstrap data
    # NOTE: setting grf_res and grf_cuts to NULL
    # Induces evaluation to revert back to default
    args_FS_boot$grf_res <- NULL
    args_FS_boot$grf_cuts <- NULL
    # In bootstrap re-set parallel_args per specification in this call
    # For parallel_args we do NOT want to revert back to default
    # because default is not a null list
    if(reset_parallel){
    args_FS_boot[["parallel_args"]] <- list()
    } else {
    args_FS_boot$parallel_args$workers <- boot_workers
    args_FS_boot$parallel_args$show_message <- FALSE
    }
    #print(args_FS_boot)
    #cat("Length of parallel args",c(length(args_FS_boot$parallel_args)),"\n")
    run_bootstrap <- try(do.call(forestsearch, args_FS_boot), TRUE)
Please check if all the necessary functions have been included in the "add" list of the foreach() call</div><div class="bot-msg"><strong>ADW:</strong> <p>Let's check if all the necessary functions used inside the <code>bootstrap_results</code> function and its called sub-functions are included in the <code>.options.future$add</code> list for the <code>foreach()</code> call.</p>
<h3>Functions Used Directly in <code>bootstrap_results</code>:</h3>
<ul>
<li><code>get_Cox_sg</code></li>
<li><code>forestsearch</code></li>
<li><code>try</code></li>
<li><code>subset</code></li>
<li><code>set.seed</code></li>
<li><code>sample.int</code></li>
<li><code>do.call</code></li>
<li><code>c</code></li>
<li><code>list</code></li>
<li><code>names</code></li>
<li><code>TRUE</code>, <code>FALSE</code>, <code>NA</code>, etc. (base R, always available)</li>
</ul>
<h3>Functions Used Indirectly (via <code>forestsearch</code> and its pipeline):</h3>
<p>From your codebase, <code>forestsearch</code> and its sub-pipeline may call:
- <code>get_FSdata</code>, <code>dummy</code>, <code>dummy2</code>, <code>lasso_selection</code>, <code>get_conf_force</code>, <code>filter_by_lassokeep</code>, <code>is.continuous</code>, <code>cut_var</code>, <code>process_conf_force_expr</code>, <code>is_flag_continuous</code>, <code>is_flag_drop</code>, <code>acm.disjctif</code>, <code>ztrail</code>, <code>one.zero</code>
- <code>grf.subg.harm.survival</code>, <code>policy_tree</code>, <code>causal_survival_forest</code>, <code>double_robust_scores</code>, <code>aggregate</code>
- <code>subgroup.search</code>, <code>get_combinations_info</code>, <code>get_subgroup_membership</code>, <code>get_covs_in</code>, <code>extract_idx_flagredundancy</code>
- <code>subgroup.consistency</code>, <code>sort_subgroups</code>, <code>extract_subgroup</code>, <code>sg_consistency_out</code>, <code>remove_redundant_subgroups</code>, <code>get_split_hr</code>, <code>setup_parallel_SGcons</code>
- <code>SG_tab_estimates</code>, <code>analyze_subgroup</code>, <code>cox_summary</code>, <code>km_summary</code>, <code>rmst_calculation</code>, <code>calculate_counts</code>, <code>calculate_potential_hr</code>, <code>prepare_subgroup_data</code>, <code>format_results</code>, <code>format_CI</code>
- <code>get_dfpred</code>
- <code>bootstrap_ystar</code>, <code>get_dfRes</code>, <code>ci_est</code>, <code>get_targetEst</code>, <code>fit_cox_models</code>, <code>build_cox_formula</code>, <code>ensure_packages</code>
- <code>quiet</code>, <code>SummaryStat</code>, <code>var_summary</code>, <code>n_pcnt</code>, <code>hrCI_format</code>, <code>plot_subgroup</code>, <code>plot_weighted_km</code>, <code>prepare_data</code>, <code>run_grf</code>, <code>evaluate_subgroups</code>, <code>summarize_results</code>, <code>clean_data</code>, <code>qlow</code>, <code>qhigh</code>, <code>FS_labels</code>, <code>thiscut</code>, <code>get_cut_name</code>, <code>remove_redundant_subgroups</code>, <code>sg_consistency_out</code>, <code>get_split_hr</code>, <code>cut_var</code>, <code>get_covs_in</code>, <code>extract_idx_flagredundancy</code></p>
<h3>Your <code>.options.future$add</code> List</h3>
<p>You have included all of the above, plus some additional utility functions and objects. The list is very comprehensive and covers:
- All direct and indirect function dependencies
- All helper functions for dummy coding, GRF, LASSO, subgroup search, consistency, summary, bootstrap, and parallelization
- All relevant objects (e.g., <code>cox.formula.boot</code>)</p>
<h3><strong>Conclusion</strong></h3>
<p><strong>Yes, your <code>.options.future$add</code> list is complete and covers all necessary functions and objects required for the parallel bootstrap to work.</strong><br />
You have even included some extra helpers, which is good for robustness.</p>
<p><strong>No changes are needed.</strong><br />
If you add new custom functions to the pipeline in the future, remember to add them to this list as well.</p></div><div class="user-msg"><strong>User:</strong> add_id_column <- function(df.analysis, id.name = NULL) {
  if (is.null(id.name)) {
    df.analysis$id <- seq_len(nrow(df.analysis))
    id.name <- "id"
  } else if (!(id.name %in% names(df.analysis))) {
    df.analysis[[id.name]] <- seq_len(nrow(df.analysis))
  }
  return(df.analysis)
}
Please add roxygen2 documentation with @export</div><div class="bot-msg"><strong>ADW:</strong> <p>Here is your function with full roxygen2 documentation and the @export tag:</p>
<pre><code class="language-r">#' Add ID Column to Data Frame
#'
#' Ensures that a data frame has a unique ID column. If \code{id.name} is not provided,
#' a column named &quot;id&quot; is added. If \code{id.name} is provided but does not exist in the data frame,
#' it is created with unique integer values.
#'
#' @param df.analysis Data frame to which the ID column will be added.
#' @param id.name Character. Name of the ID column to add (default is \code{NULL}, which uses &quot;id&quot;).
#'
#' @return Data frame with the ID column added if necessary.
#' @export
add_id_column &lt;- function(df.analysis, id.name = NULL) {
  if (is.null(id.name)) {
    df.analysis$id &lt;- seq_len(nrow(df.analysis))
    id.name &lt;- &quot;id&quot;
  } else if (!(id.name %in% names(df.analysis))) {
    df.analysis[[id.name]] &lt;- seq_len(nrow(df.analysis))
  }
  return(df.analysis)
}
</code></pre>
<p>This is ready for use in a package or script with roxygen2 documentation.</p></div><div class="user-msg"><strong>User:</strong> how to debug doFuture in Rstudio</div><div class="bot-msg"><strong>ADW:</strong> <p>Debugging <code>doFuture</code> (and <code>%dofuture%</code>/<code>foreach</code> parallel code) in RStudio can be challenging because parallel workers run in separate R sessions, and standard debugging tools like <code>browser()</code> or <code>print()</code> may not work as expected. Here are practical strategies and tips for debugging <code>doFuture</code> code in RStudio:</p>
<hr />
<h2>1. <strong>Use Sequential Backend for Debugging</strong></h2>
<p>Switch to a sequential backend so that code runs in the main R session, making debugging easier:</p>
<pre><code class="language-r">library(doFuture)
registerDoFuture()
plan(sequential)  # or plan('sequential')

# Now run your foreach loop as usual
</code></pre>
<p>This allows you to use <code>browser()</code>, <code>print()</code>, and other debugging tools as you would in regular R code.</p>
<hr />
<h2>2. <strong>Add Print/Message Statements</strong></h2>
<p>Insert <code>print()</code>, <code>cat()</code>, or <code>message()</code> statements inside your foreach loop to trace variable values and execution flow. These will be visible in the R console when using the sequential plan.</p>
<hr />
<h2>3. <strong>Use tryCatch or try for Error Tracing</strong></h2>
<p>Wrap your code in <code>tryCatch()</code> or <code>try()</code> to capture and print errors:</p>
<pre><code class="language-r">foreach(i = 1:10) %dopar% {
  tryCatch({
    # your code
  }, error = function(e) {
    print(e)
    NULL
  })
}
</code></pre>
<hr />
<h2>4. <strong>Debug a Single Iteration First</strong></h2>
<p>Before running the full parallel loop, test a single iteration of your code outside of <code>foreach</code> to ensure it works as expected.</p>
<hr />
<h2>5. <strong>Check Exported Objects and Functions</strong></h2>
<p>Make sure all necessary functions and objects are available to the workers. Use the <code>.export</code> argument in <code>foreach</code> or the <code>.options.future$add</code> list in <code>%dofuture%</code> to explicitly specify what to send to workers.</p>
<hr />
<h2>6. <strong>Check for Package Availability</strong></h2>
<p>Ensure all required packages are loaded on the workers. Use <code>foreach(..., .packages = c("pkg1", "pkg2"))</code> or load them at the start of your loop.</p>
<hr />
<h2>7. <strong>Inspect Error Messages</strong></h2>
<p>If you get errors like <code>object not found</code> or <code>could not find function</code>, it usually means something wasn't exported to the workers. Double-check your <code>.export</code>/<code>.add</code> lists.</p>
<hr />
<h2>8. <strong>Use plan(multisession, workers = 1) for Isolated Debugging</strong></h2>
<p>This runs the code in a separate R session but with only one worker, which can help isolate environment issues.</p>
<hr />
<h2>9. <strong>Check Worker Logs (Advanced)</strong></h2>
<p>For more advanced debugging, you can direct output from workers to log files using <code>sink()</code> or by capturing output in your code.</p>
<hr />
<h2>10. <strong>Use RStudio‚Äôs Debugging Tools (Sequential Only)</strong></h2>
<p>With <code>plan(sequential)</code>, you can use RStudio‚Äôs breakpoints, <code>browser()</code>, <code>traceback()</code>, and step-through debugging.</p>
<hr />
<h3>Example: Debugging a foreach Loop</h3>
<pre><code class="language-r">library(doFuture)
registerDoFuture()
plan(sequential)  # For debugging

foreach(i = 1:3) %dopar% {
  print(paste(&quot;Iteration:&quot;, i))
  browser()  # Will pause execution for interactive debugging
  sqrt(i)
}
</code></pre>
<hr />
<h3>When Ready for Parallel</h3>
<p>Switch back to your intended parallel plan (e.g., <code>plan(multisession)</code> or <code>plan(multicore)</code>) after debugging.</p>
<hr />
<p><strong>Summary Table</strong></p>
<p>| Debugging Step                | Parallel Plan      | Notes                                 |
|-------------------------------|-------------------|---------------------------------------|
| Use print/cat/message         | sequential        | Output visible in console             |
| Use browser()/breakpoints     | sequential        | Interactive debugging                 |
| tryCatch/try for errors       | any               | Captures errors in workers            |
| Check .export/.add/.packages  | any               | Ensures workers have what they need   |
| Test single iteration         | any               | Isolate logic errors                  |</p>
<hr />
<p><strong>References:</strong>
- <a href="https://cran.r-project.org/web/packages/doFuture/vignettes/doFuture.html">doFuture documentation</a>
- <a href="https://cran.r-project.org/web/packages/foreach/vignettes/foreach.pdf">foreach documentation</a>
- <a href="https://future.futureverse.org/articles/debugging.html">future package debugging FAQ</a></p>
<p>If you have a specific error or issue, please share the error message and code snippet for more targeted help!</p></div><div class="user-msg"><strong>User:</strong> run_bootstrap <- try(do.call(forestsearch, args_FS_boot), TRUE)
Write this as tryCatch and print out error</div><div class="bot-msg"><strong>ADW:</strong> <p>Certainly! Here‚Äôs how you can rewrite your line using <code>tryCatch</code> to print out the error if one occurs:</p>
<pre><code class="language-r">run_bootstrap &lt;- tryCatch(
  do.call(forestsearch, args_FS_boot),
  error = function(e) {
    message(&quot;Error in forestsearch: &quot;, e$message)
    return(NULL)
  }
)
</code></pre>
<p><strong>Explanation:</strong>
- If <code>do.call(forestsearch, args_FS_boot)</code> runs without error, its result is assigned to <code>run_bootstrap</code>.
- If an error occurs, the error message is printed with <code>message()</code>, and <code>run_bootstrap</code> is set to <code>NULL</code>.</p>
<p>You can replace <code>message()</code> with <code>print()</code> or <code>cat()</code> if you prefer a different output style.</p></div><div class="user-msg"><strong>User:</strong> Error in forestsearch: unused argument (plot.grf = FALSE)</div><div class="bot-msg"><strong>ADW:</strong> <p>The error message:</p>
<pre><code>Error in forestsearch: unused argument (plot.grf = FALSE)
</code></pre>
<p>means that the function <code>forestsearch</code> does not have an argument named <code>plot.grf</code>, but you are passing it in your <code>args_FS_boot</code> list.</p>
<h3>How to Fix</h3>
<p><strong>Solution:</strong><br />
Remove <code>plot.grf</code> from <code>args_FS_boot</code> before calling <code>do.call(forestsearch, args_FS_boot)</code>.</p>
<h4>Example Fix</h4>
<pre><code class="language-r">args_FS_boot$plot.grf &lt;- NULL  # Remove the unused argument

run_bootstrap &lt;- tryCatch(
  do.call(forestsearch, args_FS_boot),
  error = function(e) {
    message(&quot;Error in forestsearch: &quot;, e$message)
    return(NULL)
  }
)
</code></pre>
<p><strong>Tip:</strong><br />
If you are dynamically building argument lists, it‚Äôs good practice to filter out any elements that are not formal arguments of the target function:</p>
<pre><code class="language-r"># Keep only arguments that are in the formal argument list of forestsearch
forestsearch_formals &lt;- names(formals(forestsearch))
args_FS_boot &lt;- args_FS_boot[names(args_FS_boot) %in% forestsearch_formals]
</code></pre>
<p>Then call:</p>
<pre><code class="language-r">run_bootstrap &lt;- tryCatch(
  do.call(forestsearch, args_FS_boot),
  error = function(e) {
    message(&quot;Error in forestsearch: &quot;, e$message)
    return(NULL)
  }
)
</code></pre>
<hr />
<p><strong>Summary:</strong><br />
- Remove <code>plot.grf</code> from <code>args_FS_boot</code> before calling <code>forestsearch</code>.
- Optionally, filter your argument list to match the function‚Äôs formal arguments to avoid similar issues in the future.</p></div><div class="user-msg"><strong>User:</strong> forestsearch <- function(df.analysis,
outcome.name = "tte",
event.name = "event",
treat.name = "treat",
id.name = "id",
potentialOutcome.name=NULL,
confounders.name = NULL,
parallel_args = list(plan = "multisession", workers = 6),
df.predict = NULL,
df.test = NULL,
is.RCT = TRUE, seedit = 8316951,
est.scale="hr",
use_lasso = TRUE,
use_grf = TRUE,
grf_res = NULL,
grf_cuts = NULL,
max_n_confounders = 1000,
grf_depth = 2,
dmin.grf = 12,
frac.tau = 0.6,
conf_force=NULL,
defaultcut_names=NULL,
cut_type="default",
exclude_cuts = NULL,
replace_med_grf = FALSE,
cont.cutoff = 4,
conf.cont_medians = NULL,
conf.cont_medians_force = NULL,
n.min = 60,
hr.threshold = 1.25,
hr.consistency = 1.0,
sg_focus = "hr",
fs.splits = 1000,
m1.threshold = Inf,
stop.threshold = 0.90,
pconsistency.threshold = 0.90,
showten_subgroups = FALSE,
d0.min = 10, d1.min = 10,
max.minutes = 3,
minp = 0.025,
details = FALSE,
maxk = 2,
by.risk = 12, plot.sg = FALSE, plot.grf = FALSE,
max_subgroups_search = 10,
vi.grf.min = -0.2){
if (!exists("df.analysis") | !is.data.frame(df.analysis)){
    stop("df.analysis does not exists or is not a data.frame")
  } else if (exists("df.analysis") && !is.data.frame(df.analysis)){
    df.analysis <- as.data.frame(df.analysis)
    message("Converting df.analysis to data.frame")
  }
# Revised
  # if (is.null(id.name)) {
  #   df.analysis$id <- seq_len(nrow(df.analysis))
  #   id.name <- "id"
  # } else if (!(id.name %in% names(df.analysis))) {
  #   df.analysis[[id.name]] <- seq_len(nrow(df.analysis))
  # }
#df.analysis <-  add_id_column(df.analysis, id.name)
var_names <- c(confounders.name,outcome.name,event.name,id.name,treat.name,potentialOutcome.name)
  # Ensure all required variables exist in df.analysis
  missing_vars <- setdiff(var_names, names(df.analysis))
  if(length(missing_vars) > 0) {
    stop("The following variables are missing in df.analysis: ", paste(missing_vars, collapse = ", "))
  }
# Return the arguments to be passed to bootstrap call
# in order to use the same for the bootstrap analysis
#args_call <- as.list(match.call())[-1]
# Include defaults for call below
args_names <- names(formals())
args_call_all <- mget(args_names, envir = environment())
# Check parallel arguments for subgroup consistency
if(length(parallel_args) > 0){
allowed_plans <- c("multisession", "multicore", "callr","sequential")
plan_type <- parallel_args$plan
n_workers <- parallel_args$workers
max_cores <- parallel::detectCores()
if (is.null(plan_type)) stop("parallel_args$plan must be specified.")
if (!plan_type %in% allowed_plans) {
stop("parallel_args$plan must be one of: ", paste(allowed_plans, collapse = ", "))
}
if (is.null(n_workers) || !is.numeric(n_workers) || n_workers < 1) {
  parallel_args$workers <- 1
} else {
  parallel_args$workers <- min(n_workers, max_cores)
}
}
if(!(sg_focus %in% c("hr","hrMaxSG", "hrMinSG", "maxSG", "minSG"))) stop("sg_focus must be either hr, hrMaxSG (maxSG), or hrMinSG (minSG)")
if(plot.sg && is.null(by.risk)) stop("by.risk must be non-null if plot.sg = TRUE")
# reset stop.threshold (>1) to override stopping
if(showten_subgroups)  stop.threshold <- 1.1
if(!(cut_type %in% c("default","median"))) stop("only default and median cuts")
if(all(confounders.name %in% names(df.analysis)) != TRUE) stop("Not all confounders found in dataset")
if(!is.null(defaultcut_names)){
if(all(defaultcut_names %in% names(df.analysis)) != TRUE) stop("Not all confounders for default cuts found in dataset")
}
if(is.null(confounders.name)) stop("Confounder names (confounders.name) required")
if(is.null(outcome.name) || is.null(event.name) || is.null(treat.name)) stop("outcome.name, event.name, and treat.name required (missing at least 1)")
if(is.null(hr.threshold) || is.null(hr.consistency) || is.null(pconsistency.threshold)) stop("hr.threshold, hr.consistency, pconsistency.threshold required (missing at least 1)")
if(sg_focus %in% c("maxSG","minSG")){
if(stop.threshold < pconsistency.threshold) stop.threshold <- pconsistency.threshold
# Stop searching once pconsistency.threshold is met
# Select max/min subgroup size
 }
# Re-set stop.threshold
# Continue searching
# Select max/min subgroup size (pconsistency threshold is minimum)
if(sg_focus %in% c("hrMaxSG","hrMinSG") && stop.threshold < 1.0) stop.threshold <- 1.0
# Sort data by id
df.analysis <- df.analysis[order(df.analysis[[id.name]]), , drop = FALSE]
# Select relevant columns
dfa <- df.analysis[, var_names, drop = FALSE]
# Identify complete cases
complete_idx <- complete.cases(dfa)
n_excluded <- sum(!complete_idx)
# Report exclusions
if(n_excluded > 0) {
  message("Total excluded by omitting missing data = ", n_excluded)
}
# Keep only complete cases
df.analysis <- dfa[complete_idx, , drop = FALSE]
t.start_all<-proc.time()[3]
# Initialize outputs
grf_plot <- NULL
grf_cuts <- NULL
# If using grf and not populated then run grf
if(use_grf && (is.null(grf_res) || is.null(grf_res$tree.cuts))) {
if(details){
cat("GRF stage for cut selection with dmin,tau=",c(dmin.grf, frac.tau),"\n")
}
grf_res <- NULL
grf_res <- try(
grf.subg.harm.survival(data = df.analysis, confounders.name = confounders.name,
outcome.name = outcome.name, RCT = is.RCT,seedit = seedit,maxdepth = grf_depth,
event.name = event.name, id.name = id.name, treat.name = treat.name, n.min = n.min, dmin.grf = dmin.grf,
frac.tau = frac.tau, details = details)
,TRUE)
# Check if grf_res is valid (not a try-error and not NULL)
if (!inherits(grf_res, "try-error") && !is.null(grf_res)) {
  # If no subgroup found
  if (is.null(grf_res$sg.harm)) {
    use_grf <- FALSE
    if (isTRUE(details)) {
      cat("NO GRF cuts meeting delta(RMST): dmin.grf=", dmin.grf, "\n")
    }
  } else {
    # If subgroup found
    # Check for DiagrammeR availability
    if (requireNamespace("DiagrammeR", quietly = TRUE) && plot.grf) {
      grf_plot <- plot(grf_res$tree, leaf.labels = c("Control", "Treat"))
    } else {
      #warning("Skipping tree plot --> DiagrammeR packaged required to view tree graph")
      if (isTRUE(details)) {
        cat("DiagrammeR or not creating: skipping tree plot.\n")
      }
      grf_plot <- NULL
    }
    grf_cuts <- grf_res$tree.cuts
  }
} else {
  # If grf_res is invalid, ensure outputs are NULL
  grf_plot <- NULL
  grf_cuts <- NULL
}
}
if(use_grf && !exists("grf_cuts")) warning("GRF cuts not found")
get_argsFS <- formals(get_FSdata)
args_FS <- names(get_argsFS)
# align with args_call_all
args_FS_filtered <- args_call_all[names(args_call_all) %in% args_FS]
# In get_FSdata the data source is "df"
args_FS_filtered$df <- df.analysis
args_FS_filtered$grf_cuts <- grf_cuts
# Remove
# cat("args_FS_filtered","\n")
# print(names(args_FS_filtered))
# FSdata1 <- do.call(get_FSdata, args_FS_filtered)
# print(names(FSdata1))
FSdata <- try(do.call(get_FSdata, args_FS_filtered), TRUE)
if(inherits(FSdata,"try-error")){
warning("FSdata failure")
}
if(inherits(FSdata,"try-error")) stop("FSdata error")
if(!inherits(FSdata,"try-error")){
lassoomit <- FSdata$lassoomit
lassokeep <- FSdata$lassokeep
df <- FSdata$df
Y <- df[,outcome.name]
Event <- df[,event.name]
Treat <- df[,treat.name]
FSconfounders.name <- FSdata$confs_names
confs_labels <- FSdata$confs
if(is.null(df.predict)) df.predict <- df
if(!is.null(vi.grf.min)){
  # Use GRF for screening and ordering
  # Covariates need to be converted to numeric scale
  # original data.frame version
  X <- as.matrix(df[,FSconfounders.name])
  # Convert to numeric
  X <- apply(X,2,as.numeric)
  tau.rmst <- min(c(max(Y[Treat == 1 & Event == 1]),max(Y[Treat == 0 & Event == 1])))
  # For screening we take 0.9*tau.rms
  if(!is.RCT) cs.forest <- try(suppressWarnings(grf::causal_survival_forest(X, Y, Treat, Event, horizon = 0.9 * tau.rmst, seed = 8316951)), TRUE)
  if(is.RCT) cs.forest <- try(suppressWarnings(grf::causal_survival_forest(X, Y, Treat, Event, W.hat = 0.5, horizon = 0.9 * tau.rmst, seed = 8316951)), TRUE)
  vi.cs <- round(grf::variable_importance(cs.forest),4)
  vi.cs2 <- data.frame(confs_labels,FSconfounders.name,vi.cs)
  vi.order <- order(vi.cs,decreasing=TRUE)
  vi.cs2 <- vi.cs2[vi.order,]
  conf.screen <- vi.cs2[,2]
  vi_ratio <- vi.cs2[,3] / max(vi.cs2[,3])
  selected.vars <- which(vi_ratio > vi.grf.min)
  conf.screen <- conf.screen[selected.vars]
  # Restrict to max of max_n_confounders
  # Keeping 1st lmax ordered per vi
  lmax <- min(c(length(conf.screen),max_n_confounders))
  conf.screen_limit <- conf.screen[c(1:lmax)]
  conf.screen <- conf.screen_limit
  if(details){
  cat("Number of factors evaluated=",c(lmax),"\n")
  cat("Confounders per grf screening",conf.screen,"\n")
  vi_res <- vi.cs2[selected.vars,]
  # Re-name for printing
  names(vi_res) <- c("Factors","Labels","VI(grf)")
  print(vi_res)
  }
} else {
conf.screen <- FSconfounders.name
}
df.confounders <- df[,conf.screen]
df.confounders <- dummy(df.confounders)
  # name identification as "id" for merging (df.predict) sg membership flags
  id <- df[,c(id.name)]
  df.fs <- data.frame(Y,Event,Treat,id,df.confounders)
  Z <- as.matrix(df.confounders)
  colnames(Z) <- names(df.confounders)
  find.grps <- subgroup.search(Y = Y, Event = Event, Treat = Treat, Z = Z, d0.min = d0.min, d1.min = d1.min, n.min = n.min,
                               hr.threshold = hr.threshold, max.minutes = max.minutes, details = details, maxk = maxk)
  sg.harm <- NULL
  df.est_out <- NULL
  df.predict_out <- NULL
  df.test_out <- NULL
  grp.consistency <- NULL
  max_sg_est <- find.grps$max_sg_est
  prop_maxk <- find.grps$prop_max_count
  # If no subgroups found then this is end
  t.end_all<-proc.time()[3]
  t.min_all<-(t.end_all-t.start_all)/60
  if(!is.null(find.grps$out.found) && (any(find.grps$out.found$hr.subgroups$HR > hr.consistency)) || any(find.grps$out.found$hr.subgroups$HR > hr.consistency)){# Found something?
  if(plot.sg && is.null(by.risk)) by.risk<-round(max(Y)/12,0)
  if(details) cat("# of candidate subgroups (meeting all criteria) = ",c(nrow(find.grps$out.found$hr.subgroups)),"\n")
  args_sgc <- names(formals(subgroup.consistency))
  # align with args_call_all
  args_sgc_filtered <- args_call_all[names(args_call_all) %in% args_sgc]
  args_sgc_filtered$df <- df.fs
  args_sgc_filtered$hr.subgroups <- find.grps$out.found$hr.subgroups
  args_sgc_filtered$Lsg <- find.grps$L
  args_sgc_filtered$confs_labels <- confs_labels
  args_sgc_filtered$n.splits <- fs.splits
  args_sgc_filtered$stop_Kgroups <- max_subgroups_search
  grp.consistency <- do.call(subgroup.consistency, args_sgc_filtered)
  t.end_all<-proc.time()[3]
  t.min_all<-(t.end_all-t.start_all)/60
if(details){
cat("Minutes forestsearch overall=",c(t.min_all),"\n")
}
# Found something and a subgroup
if(!is.null(grp.consistency$sg.harm)){
sg.harm <- grp.consistency$sg.harm
# data containing id and treatment flag
temp <- grp.consistency$df_flag
# Merge to analysis data and add treatment flag (all.x=TRUE)
df.est_out <- merge(df, temp, by="id", all.x=TRUE)
 # Return df.predict
if(!is.null(df.predict)){
# This does not work if df.predict is test sample in which case
# cannot match to df_flag by id
df.predict_out <- merge(df.predict, temp, by="id", all.x=TRUE)
}
if(!is.null(df.test)){
  df.test_out <- get_dfpred(df.predict = df.test,sg.harm = grp.consistency$sg.harm,version = 2)
   }
}
 } # Found something
out <- list(grp.consistency = grp.consistency,find.grps = find.grps,
confounders.candidate = FSconfounders.name,
confounders.evaluated = confs_labels,
df.est = df.est_out,
df.predict = df.predict_out,
df.test = df.test_out,
minutes_all = t.min_all,
grf_res = grf_res,
sg_focus = sg_focus,
sg.harm = sg.harm,
grf_cuts = grf_cuts,
prop_maxk = prop_maxk,
max_sg_est = max_sg_est,
grf_plot = grf_plot,
args_call_all = args_call_all)
}
# Fsdata NOT successful
if(inherits(FSdata,"try-error")){
  out <- list(sg.harm=NULL)
}
return(out)
}
Please check grf_plot object creation</div><div class="bot-msg"><strong>ADW:</strong> <p>Let's review the creation and assignment of the <code>grf_plot</code> object in your <code>forestsearch</code> function:</p>
<h3>Where is <code>grf_plot</code> created?</h3>
<pre><code class="language-r"># Initialize outputs
grf_plot &lt;- NULL
grf_cuts &lt;- NULL

# If using grf and not populated then run grf
if(use_grf &amp;&amp; (is.null(grf_res) || is.null(grf_res$tree.cuts))) {
  ...
  if (!inherits(grf_res, &quot;try-error&quot;) &amp;&amp; !is.null(grf_res)) {
    # If no subgroup found
    if (is.null(grf_res$sg.harm)) {
      use_grf &lt;- FALSE
      if (isTRUE(details)) {
        cat(&quot;NO GRF cuts meeting delta(RMST): dmin.grf=&quot;, dmin.grf, &quot;\n&quot;)
      }
    } else {
      # If subgroup found
      # Check for DiagrammeR availability
      if (requireNamespace(&quot;DiagrammeR&quot;, quietly = TRUE) &amp;&amp; plot.grf) {
        grf_plot &lt;- plot(grf_res$tree, leaf.labels = c(&quot;Control&quot;, &quot;Treat&quot;))
      } else {
        #warning(&quot;Skipping tree plot --&gt; DiagrammeR packaged required to view tree graph&quot;)
        if (isTRUE(details)) {
          cat(&quot;DiagrammeR or not creating: skipping tree plot.\n&quot;)
        }
        grf_plot &lt;- NULL
      }
      grf_cuts &lt;- grf_res$tree.cuts
    }
  } else {
    # If grf_res is invalid, ensure outputs are NULL
    grf_plot &lt;- NULL
    grf_cuts &lt;- NULL
  }
}
</code></pre>
<h3>What does this do?</h3>
<ul>
<li><code>grf_plot</code> is initialized as <code>NULL</code>.</li>
<li>If GRF is used and a valid GRF result is found with a subgroup:</li>
<li>If <code>DiagrammeR</code> is available and <code>plot.grf</code> is <code>TRUE</code>, it attempts to plot the tree and assign the result to <code>grf_plot</code>.</li>
<li>Otherwise, it sets <code>grf_plot</code> to <code>NULL</code> and optionally prints a message.</li>
<li>If no valid GRF result, <code>grf_plot</code> is set to <code>NULL</code>.</li>
</ul>
<h3>Is this correct?</h3>
<p><strong>Yes, this logic is correct.</strong><br />
- <code>grf_plot</code> will only be non-NULL if:
  - A valid GRF result is found,
  - A subgroup is found,
  - <code>DiagrammeR</code> is installed,
  - and <code>plot.grf</code> is <code>TRUE</code>.
- Otherwise, it will be <code>NULL</code>.</p>
<h3>Additional Notes</h3>
<ul>
<li>The <code>plot()</code> function for the GRF tree (likely a <code>policytree</code> object) must be compatible with <code>DiagrammeR</code>. If not, you may need to use the appropriate plotting function for your tree object.</li>
<li>The <code>grf_plot</code> object is included in the output list at the end of the function.</li>
</ul>
<h3>Suggestion</h3>
<p>If you want to ensure that <code>grf_plot</code> is always a valid object (e.g., a plot or <code>NULL</code>), your current logic is robust. If you want to avoid errors in environments without <code>DiagrammeR</code>, your current check is also correct.</p>
<p><strong>If you want to make it even more robust, you could wrap the plot call in <code>try()</code> or <code>tryCatch()</code> to avoid unexpected errors:</strong></p>
<pre><code class="language-r">if (requireNamespace(&quot;DiagrammeR&quot;, quietly = TRUE) &amp;&amp; plot.grf) {
  grf_plot &lt;- try(plot(grf_res$tree, leaf.labels = c(&quot;Control&quot;, &quot;Treat&quot;)), silent = TRUE)
  if (inherits(grf_plot, &quot;try-error&quot;)) grf_plot &lt;- NULL
} else {
  ...
}
</code></pre>
<hr />
<p><strong>Summary:</strong><br />
- The creation and assignment of <code>grf_plot</code> in your function is correct and robust.
- Optionally, you can wrap the plot call in <code>try()</code>/<code>tryCatch()</code> for extra safety.</p></div><div class="user-msg"><strong>User:</strong> Is it necessary to apply usethis::use_git() after revising functions in R folder</div><div class="bot-msg"><strong>ADW:</strong> <p>No, it is <strong>not necessary</strong> to run <code>usethis::use_git()</code> every time you revise functions in your R folder.</p>
<h3>What does <code>usethis::use_git()</code> do?</h3>
<ul>
<li><code>usethis::use_git()</code> is a one-time setup function that initializes a Git repository in your project (if one does not already exist).</li>
<li>It sets up the <code>.git</code> folder, creates a <code>.gitignore</code>, and optionally makes an initial commit.</li>
</ul>
<h3>What should you do after revising functions?</h3>
<ul>
<li><strong>If your project is already under Git version control</strong> (i.e., you have a <code>.git</code> folder in your project root), you do <strong>not</strong> need to run <code>usethis::use_git()</code> again.</li>
<li>Instead, you should use standard Git commands to track your changes:</li>
<li>In RStudio: Use the Git pane to stage, commit, and push changes.</li>
<li>In the terminal or command line:
    <code>sh
    git add R/
    git commit -m "Describe your changes"
    git push</code></li>
</ul>
<h3>When should you use <code>usethis::use_git()</code>?</h3>
<ul>
<li>Only the <strong>first time</strong> you want to put your project under Git version control.</li>
</ul>
<hr />
<p><strong>Summary Table</strong></p>
<p>| Situation                                 | Should you use <code>usethis::use_git()</code>? |
|--------------------------------------------|:------------------------------------:|
| Project not under Git yet                  | Yes (one time only)                  |
| Project already under Git (has <code>.git/</code>)    | No                                   |
| After editing functions in R/ folder       | No                                   |
| To commit changes                         | Use Git commit (not <code>use_git()</code>)     |</p>
<hr />
<p><strong>In short:</strong><br />
- Use <code>usethis::use_git()</code> only once per project.
- After that, use regular Git commands or RStudio's Git interface to manage changes.</p></div><div class="user-msg"><strong>User:</strong> My function has an argument when viewed in Rstudio console, but when loaded via github package it is missing the argument</div><div class="bot-msg"><strong>ADW:</strong> <p>This is a common issue in R package development and usually relates to one of the following causes:</p>
<hr />
<h2>1. <strong>The Package Was Not Rebuilt and Reinstalled</strong></h2>
<p>When you change a function's arguments in your local source code, you must rebuild and reinstall the package for those changes to be reflected when you load it (whether locally or from GitHub).</p>
<ul>
<li>If you only edit the function in the R folder but do not reinstall the package, the old version (without the new argument) will be used.</li>
<li>If you push to GitHub but do not rebuild the package (e.g., with <code>devtools::install_github()</code>), the changes will not be available to users.</li>
</ul>
<p><strong>Solution:</strong><br />
- After editing your function, run:
  <code>r
  devtools::document()   # If you use roxygen2
  devtools::install()    # For local install
  # or
  devtools::install_github("yourusername/yourpackagename")  # For GitHub install</code></p>
<hr />
<h2>2. <strong>Namespace or R Environment Caching</strong></h2>
<p>If you have loaded the package before, R may cache the old version. Restart your R session before reinstalling and reloading the package.</p>
<p><strong>Solution:</strong><br />
- In RStudio: Session &gt; Restart R
- Then reinstall and reload the package.</p>
<hr />
<h2>3. <strong>You Are Editing a Different Copy Than You Think</strong></h2>
<ul>
<li>Make sure you are editing the correct file in the correct project directory.</li>
<li>If you have multiple copies of the package, you might be loading an old version.</li>
</ul>
<hr />
<h2>4. <strong>GitHub Not Updated</strong></h2>
<ul>
<li>If you install from GitHub, make sure you have pushed your latest changes to GitHub.</li>
<li>Check your GitHub repo to confirm the function code is up to date.</li>
</ul>
<hr />
<h2>5. <strong>Function Masking</strong></h2>
<ul>
<li>If you have a function with the same name in your global environment, it may mask the package version.</li>
<li>Use <code>rm(function_name)</code> to remove it from the global environment, then reload the package.</li>
</ul>
<hr />
<h2>6. <strong>Check the Function Signature</strong></h2>
<p>After reinstalling, check the function signature:</p>
<pre><code class="language-r">library(yourpackagename)
args(your_function)
# or
your_function
</code></pre>
<hr />
<h2><strong>Summary Table</strong></h2>
<p>| Problem                                   | Solution                                      |
|--------------------------------------------|-----------------------------------------------|
| Did not reinstall after editing            | Run <code>devtools::install()</code> or <code>install_github</code> |
| R session not restarted                    | Restart R session                             |
| Editing wrong file                         | Double-check file/project                     |
| GitHub not updated                         | Push changes to GitHub                        |
| Function masking in global env             | Remove from global env, reload package        |</p>
<hr />
<p><strong>In short:</strong><br />
- Always rebuild and reinstall your package after changing function arguments.
- Restart your R session before reinstalling.
- Make sure you are installing from the correct, up-to-date source.</p>
<p>If you follow these steps and still have issues, please provide the exact steps you are taking and the code you are using for further troubleshooting!</p></div><div class="user-msg"><strong>User:</strong> Is plot.grf a function in the grf package or policytree</div><div class="bot-msg"><strong>ADW:</strong> <p>No, <code>plot.grf</code> is <strong>not</strong> a function in either the <code>grf</code> package or the <code>policytree</code> package.</p>
<h3>Details:</h3>
<ul>
<li><strong>grf package</strong>:  </li>
<li>The <code>grf</code> package provides functions for generalized random forests (e.g., <code>causal_forest</code>, <code>causal_survival_forest</code>, etc.).</li>
<li>It does <strong>not</strong> provide a function called <code>plot.grf</code> or a generic <code>plot()</code> method for its forest objects.</li>
<li>
<p>You can use <code>plot()</code> on some objects (like variable importance plots), but not on the forest itself in the way you might expect for a tree.</p>
</li>
<li>
<p><strong>policytree package</strong>:  </p>
</li>
<li>The <code>policytree</code> package provides the <code>policy_tree()</code> function for fitting policy trees.</li>
<li>It does <strong>not</strong> provide a function called <code>plot.grf</code>.</li>
<li>It does provide a <code>plot()</code> method for <code>policy_tree</code> objects (e.g., <code>plot(tree)</code>), but not a function named <code>plot.grf</code>.</li>
</ul>
<h3>What about <code>plot.grf</code> in your code?</h3>
<ul>
<li>If you see <code>plot.grf</code> in your code, it is <strong>not</strong> from either of these packages.</li>
<li>You may have intended to use <code>plot()</code> on a <code>policy_tree</code> object, or you may need to write your own plotting function for GRF objects.</li>
<li>If you want to plot a <code>policy_tree</code> object, use:
  <code>r
  plot(tree)</code></li>
<li>If you want to visualize a GRF object, you may need to extract variable importance or use custom plotting code.</li>
</ul>
<hr />
<p><strong>Summary Table</strong></p>
<p>| Function   | grf package | policytree package | Notes                                 |
|------------|:-----------:|:-----------------:|---------------------------------------|
| plot.grf   |      ‚ùå      |        ‚ùå         | Not in either package                 |
| plot()     |   Limited   |     ‚úî (for tree)  | Use <code>plot(tree)</code> for policy trees     |</p>
<hr />
<p><strong>If you need to plot a GRF or policy tree object, use the appropriate <code>plot()</code> method for that object, not <code>plot.grf</code>.</strong></p></div><div class="user-msg"><strong>User:</strong> what is the convention for naming a dataset as the first argument of a function</div><div class="bot-msg"><strong>ADW:</strong> <p>The <strong>convention for naming a dataset as the first argument of a function in R</strong> is to use one of the following names, in order of commonality and clarity:</p>
<h3>1. <code>data</code></h3>
<ul>
<li><strong>Most common and recommended</strong> for general-purpose functions.</li>
<li>Used in base R (<code>lm(data = ...)</code>, <code>plot(data, ...)</code>, etc.), tidyverse, and many packages.</li>
<li>Example:
  <code>r
  my_function &lt;- function(data, ...) { ... }</code></li>
</ul>
<h3>2. <code>df</code></h3>
<ul>
<li>Short for "data frame", also widely used, especially for functions that expect a data frame specifically.</li>
<li>Example:
  <code>r
  my_function &lt;- function(df, ...) { ... }</code></li>
</ul>
<h3>3. More Specific Names</h3>
<ul>
<li>If your function expects a particular type of data (e.g., training, test, analysis), you may use:</li>
<li><code>train</code>, <code>test</code>, <code>df_train</code>, <code>df_test</code>, <code>df_analysis</code>, etc.</li>
<li>Example:
  <code>r
  my_function &lt;- function(df_analysis, ...) { ... }</code></li>
</ul>
<h3>4. <code>x</code></h3>
<ul>
<li>Sometimes used for generic functions, but less clear for data frames/tables.</li>
</ul>
<hr />
<h2><strong>Best Practice</strong></h2>
<ul>
<li><strong>Use <code>data</code> as the first argument name</strong> for general-purpose functions that take a dataset.</li>
<li>If your function is part of a package or workflow where multiple datasets are used, use a more specific name for clarity (e.g., <code>df_analysis</code>, <code>df_train</code>).</li>
</ul>
<hr />
<h2><strong>References</strong></h2>
<ul>
<li><a href="https://google.github.io/styleguide/Rguide.html#function-arguments">R Style Guide (Google)</a></li>
<li><a href="https://style.tidyverse.org/functions.html#argument-order">tidyverse style guide</a></li>
</ul>
<hr />
<h2><strong>Summary Table</strong></h2>
<p>| Argument Name | When to Use                | Example                                  |
|---------------|---------------------------|------------------------------------------|
| <code>data</code>        | General dataset           | <code>my_function &lt;- function(data, ...)</code>     |
| <code>df</code>          | Data frame specifically   | <code>my_function &lt;- function(df, ...)</code>       |
| <code>df_analysis</code> | Specific dataset purpose  | <code>my_function &lt;- function(df_analysis, ...)</code> |
| <code>x</code>           | Generic, less preferred   | <code>my_function &lt;- function(x, ...)</code>        |</p>
<hr />
<p><strong>In short:</strong>  </p>
<blockquote>
<p>The most common and recommended convention is to use <code>data</code> as the first argument name for a dataset in R functions. Use more specific names if needed for clarity.</p>
</blockquote></div><div class="user-msg"><strong>User:</strong> qcheck <- as.factor(ifelse(eval(parse(text=thiscut), envir=df), 1, 0))
What does envi=df mean</div><div class="bot-msg"><strong>ADW:</strong> <p>The argument <code>envir = df</code> in the <code>eval()</code> function is intended to specify the environment in which the expression (created by <code>parse(text = thiscut)</code>) should be evaluated. However, in R, <code>envir</code> must be an environment object, <strong>not</strong> a data frame.</p>
<h3>What does the code do?</h3>
<pre><code class="language-r">qcheck &lt;- as.factor(ifelse(eval(parse(text = thiscut), envir = df), 1, 0))
</code></pre>
<ul>
<li><code>thiscut</code> is a string representing a logical expression involving columns of <code>df</code> (e.g., <code>"age &lt;= 50"</code>).</li>
<li><code>parse(text = thiscut)</code> turns the string into an R expression.</li>
<li><code>eval(..., envir = df)</code> tries to evaluate that expression using the variables in <code>df</code>.</li>
</ul>
<h3>What does <code>envir = df</code> mean here?</h3>
<ul>
<li>The intention is: "Evaluate the expression as if the columns of <code>df</code> are variables in the environment."</li>
<li><strong>But:</strong> <code>envir</code> must be an environment, not a data frame.  </li>
<li>If you pass a data frame, R will internally convert it to an environment using <code>list2env(df)</code>, but this is not always robust or recommended.</li>
</ul>
<h3>Correct and robust usage</h3>
<p><strong>Best practice:</strong><br />
Explicitly convert the data frame to an environment:</p>
<pre><code class="language-r">qcheck &lt;- as.factor(ifelse(eval(parse(text = thiscut), envir = as.list(df)), 1, 0))
</code></pre>
<p>or, more robustly:</p>
<pre><code class="language-r">qcheck &lt;- as.factor(ifelse(eval(parse(text = thiscut), envir = list2env(df)), 1, 0))
</code></pre>
<ul>
<li><code>as.list(df)</code> works for simple column access.</li>
<li><code>list2env(df)</code> creates an environment where each column is a variable.</li>
</ul>
<h3>Summary Table</h3>
<p>| Usage                        | Meaning/Effect                                              |
|------------------------------|------------------------------------------------------------|
| <code>envir = df</code>                 | Tries to use df columns as variables (not robust)          |
| <code>envir = as.list(df)</code>        | Uses df columns as variables (for simple cases)            |
| <code>envir = list2env(df)</code>       | Robust: creates environment with df columns as variables    |</p>
<hr />
<p><strong>In short:</strong><br />
<code>envir = df</code> is a shortcut to let you use column names of <code>df</code> as variables in the evaluated expression, but the robust and recommended way is to use <code>envir = list2env(df)</code>.</p></div><div class="user-msg"><strong>User:</strong> add = c("calc_cov",  
                                   "calculate_counts", 
                                   "analyze_subgroups", 
                                   "calculate_potential_hr",
                                   "ci.est",
                                   "count.id",
                                   "CV_sgs",
                           "cox_summary","df_counting","extract_subgroup","format_results", "get_targetEst","getci_Cox",
                           "getCIs","grf.estimates.out","hrCI_format","km_summary","n_pcnt","plot_subgroup","plot_weighted_km",
                           "prepare_subgroup_data","quiet","rmst_calculation","sg_tables","sort_subgroups","SummaryStat","var_summary",
                           "get_FSdata", "dummy","run_bootstrap",
                             "forestsearch", "forestsearch_bootstrap_dofuture","get_combinations_info",
                             "get_dfpred",
                             "grf.subg.harm.survival",
                             "subgroup.search",
                             "subgroup.consistency",
                             "lasso_selection",
                             "get_Cox_sg",
                             "get_conf_force",
                             "filter_by_lassokeep",
                             "is.continuous",
                             "process_conf_force_expr",
                             "is_flag_continuous",
                             "is_flag_drop", "acm.disjctif",  "acm.util.df2", "acm.util.df", "dummy2","ztrail","one.zero",
                             "get_dfRes", "get_subgroup_membership",
                             "SG_tab_estimates",
                             "prepare_data",
                             "run_grf",
                             "evaluate_subgroups",
                             "summarize_results",
                              "clean_data", "qlow", "qhigh","FS_labels","thiscut","get_cut_name",
                             "bootstrap_results", "remove_redundant_subgroups", "sg_consistency_out","get_split_hr","cut_var",
                             "bootstrap_ystar", "ensure_packages", "fit_cox_models", "build_cox_formula", "cox.formula.boot",
                             "format_CI","setup_parallel_SGcons", "get_covs_in", "extract_idx_flagredundancy"
                           )
Please revise this to a more readable format</div><div class="bot-msg"><strong>ADW:</strong> <p>Certainly! Here is your <code>add = c(...)</code> vector, formatted for readability and maintainability. Each function/object is on its own line, grouped by related functionality where possible:</p>
<pre><code class="language-r">add = c(
  # Bootstrap/statistics helpers
  &quot;calc_cov&quot;,  
  &quot;calculate_counts&quot;, 
  &quot;analyze_subgroups&quot;, 
  &quot;calculate_potential_hr&quot;,
  &quot;ci.est&quot;,
  &quot;count.id&quot;,
  &quot;CV_sgs&quot;,
  &quot;get_targetEst&quot;,
  &quot;get_dfRes&quot;,
  &quot;getCIs&quot;,
  &quot;getci_Cox&quot;,
  &quot;SummaryStat&quot;,
  &quot;var_summary&quot;,
  &quot;format_results&quot;,
  &quot;format_CI&quot;,
  &quot;qlow&quot;, &quot;qhigh&quot;,

  # Subgroup/consistency helpers
  &quot;cox_summary&quot;,
  &quot;km_summary&quot;,
  &quot;n_pcnt&quot;,
  &quot;plot_subgroup&quot;,
  &quot;plot_weighted_km&quot;,
  &quot;prepare_subgroup_data&quot;,
  &quot;quiet&quot;,
  &quot;rmst_calculation&quot;,
  &quot;sg_tables&quot;,
  &quot;sort_subgroups&quot;,
  &quot;remove_redundant_subgroups&quot;,
  &quot;sg_consistency_out&quot;,
  &quot;get_split_hr&quot;,

  # Data preparation
  &quot;get_FSdata&quot;,
  &quot;dummy&quot;, &quot;dummy2&quot;, &quot;acm.disjctif&quot;, &quot;acm.util.df2&quot;, &quot;acm.util.df&quot;,
  &quot;ztrail&quot;, &quot;one.zero&quot;,
  &quot;prepare_data&quot;,
  &quot;clean_data&quot;,

  # ForestSearch core
  &quot;forestsearch&quot;,
  &quot;forestsearch_bootstrap_dofuture&quot;,
  &quot;run_bootstrap&quot;,
  &quot;run_grf&quot;,
  &quot;evaluate_subgroups&quot;,
  &quot;summarize_results&quot;,
  &quot;SG_tab_estimates&quot;,
  &quot;get_dfpred&quot;,
  &quot;get_combinations_info&quot;,
  &quot;get_subgroup_membership&quot;,
  &quot;get_covs_in&quot;,
  &quot;extract_idx_flagredundancy&quot;,
  &quot;get_cut_name&quot;,
  &quot;cut_var&quot;,
  &quot;thiscut&quot;,
  &quot;FS_labels&quot;,

  # GRF and policytree
  &quot;grf.subg.harm.survival&quot;,
  &quot;grf.estimates.out&quot;,
  &quot;policy_tree&quot;, # if used
  &quot;causal_survival_forest&quot;, # if used

  # Subgroup search/consistency
  &quot;subgroup.search&quot;,
  &quot;subgroup.consistency&quot;,
  &quot;extract_subgroup&quot;,
  &quot;filter_by_lassokeep&quot;,
  &quot;is.continuous&quot;,
  &quot;process_conf_force_expr&quot;,
  &quot;is_flag_continuous&quot;,
  &quot;is_flag_drop&quot;,
  &quot;lasso_selection&quot;,
  &quot;get_Cox_sg&quot;,
  &quot;get_conf_force&quot;,

  # Bootstrap/parallel
  &quot;bootstrap_results&quot;,
  &quot;bootstrap_ystar&quot;,
  &quot;ensure_packages&quot;,
  &quot;fit_cox_models&quot;,
  &quot;build_cox_formula&quot;,
  &quot;cox.formula.boot&quot;,
  &quot;setup_parallel_SGcons&quot;
)
</code></pre>
<p><strong>Tip:</strong><br />
- You can further group or comment as needed for your workflow.
- If you use this in your code, you can copy-paste as is for clarity and easy maintenance.</p></div><div class="user-msg"><strong>User:</strong> library(DiagrammeR)
flowchart <- grViz("
digraph flowchart {
  graph [rankdir = LR]
  node [shape=box, style=filled, fillcolor=\"#e6f2ff\", fontname=\"Arial\"]
  edge [fontname=\"Arial\"]
  forestsearch [label=\"forestsearch (main entry)\", fillcolor=\"#b3d1ff\"]
  get_FSdata [label=\"get_FSdata\"]
  grf_subg [label=\"grf.subg.harm.survival\"]
  subgroup_search [label=\"subgroup.search\"]
  subgroup_consistency [label=\"subgroup.consistency\"]
  get_dfpred [label=\"get_dfpred\"]
  SG_tab_estimates [label=\"SG_tab_estimates\"]
  forestsearch_bootstrap [label=\"forestsearch_bootstrap_dofuture\"]
  # Main flow
  forestsearch -> get_FSdata
  forestsearch -> grf_subg
  forestsearch -> subgroup_search
  forestsearch -> subgroup_consistency
  forestsearch -> get_dfpred
  forestsearch -> SG_tab_estimates
  forestsearch -> forestsearch_bootstrap
  # get_FSdata helpers
  get_FSdata -> lasso_selection
  get_FSdata -> get_conf_force
  get_FSdata -> filter_by_lassokeep
  get_FSdata -> is_continuous
  get_FSdata -> cut_var
  get_FSdata -> process_conf_force_expr
  get_FSdata -> dummy
  get_FSdata -> dummy2
  # grf_subg helpers
  grf_subg -> policy_tree
  grf_subg -> causal_survival_forest
  grf_subg -> double_robust_scores
  grf_subg -> aggregate
  # subgroup_search helpers
  subgroup_search -> get_combinations_info
  subgroup_search -> get_subgroup_membership
  subgroup_search -> get_covs_in
  subgroup_search -> extract_idx_flagredundancy
  # subgroup_consistency helpers
  subgroup_consistency -> sort_subgroups
  subgroup_consistency -> extract_subgroup
  subgroup_consistency -> sg_consistency_out
  subgroup_consistency -> remove_redundant_subgroups
  subgroup_consistency -> get_split_hr
  subgroup_consistency -> setup_parallel_SGcons
  # forestsearch_bootstrap helpers
  forestsearch_bootstrap -> bootstrap_results
  forestsearch_bootstrap -> bootstrap_ystar
  forestsearch_bootstrap -> get_dfRes
  forestsearch_bootstrap -> get_Cox_sg
  forestsearch_bootstrap -> ci_est
  forestsearch_bootstrap -> get_targetEst
  forestsearch_bootstrap -> fit_cox_models
  forestsearch_bootstrap -> build_cox_formula
  forestsearch_bootstrap -> ensure_packages
  forestsearch_bootstrap -> setup_parallel_SGcons
  # SG_tab_estimates helpers
  SG_tab_estimates -> analyze_subgroup
  analyze_subgroup [label=\"analyze_subgroup\"]
  analyze_subgroup -> cox_summary
  analyze_subgroup -> km_summary
  analyze_subgroup -> rmst_calculation
  analyze_subgroup -> calculate_counts
  analyze_subgroup -> calculate_potential_hr
  SG_tab_estimates -> prepare_subgroup_data
  SG_tab_estimates -> format_results
  SG_tab_estimates -> format_CI
}
", width = 800, height = 800)
flowchart
Can this be split into two parts, side by side, or two separate schematics?</div><div class="bot-msg"><strong>ADW:</strong> <p>Yes, you can split this large flowchart into two more manageable diagrams for clarity. Here are two common approaches:</p>
<hr />
<h2><strong>Option 1: Two Side-by-Side Diagrams (Main Flow &amp; Helper Functions)</strong></h2>
<h3><strong>A. Main Flow Diagram</strong></h3>
<p>Shows the high-level workflow between the main functions.</p>
<pre><code class="language-r">library(DiagrammeR)
main_flow &lt;- grViz(&quot;
digraph main_flow {
  graph [rankdir = LR]
  node [shape=box, style=filled, fillcolor=\&quot;#e6f2ff\&quot;, fontname=\&quot;Arial\&quot;]
  edge [fontname=\&quot;Arial\&quot;]
  forestsearch [label=\&quot;forestsearch (main entry)\&quot;, fillcolor=\&quot;#b3d1ff\&quot;]
  get_FSdata [label=\&quot;get_FSdata\&quot;]
  grf_subg [label=\&quot;grf.subg.harm.survival\&quot;]
  subgroup_search [label=\&quot;subgroup.search\&quot;]
  subgroup_consistency [label=\&quot;subgroup.consistency\&quot;]
  get_dfpred [label=\&quot;get_dfpred\&quot;]
  SG_tab_estimates [label=\&quot;SG_tab_estimates\&quot;]
  forestsearch_bootstrap [label=\&quot;forestsearch_bootstrap_dofuture\&quot;]
  forestsearch -&gt; get_FSdata
  forestsearch -&gt; grf_subg
  forestsearch -&gt; subgroup_search
  forestsearch -&gt; subgroup_consistency
  forestsearch -&gt; get_dfpred
  forestsearch -&gt; SG_tab_estimates
  forestsearch -&gt; forestsearch_bootstrap
}
&quot;, width = 600, height = 200)
main_flow
</code></pre>
<hr />
<h3><strong>B. Helper Functions Diagram</strong></h3>
<p>Shows the relationships between each main function and its helpers.</p>
<pre><code class="language-r">library(DiagrammeR)
helpers_flow &lt;- grViz(&quot;
digraph helpers_flow {
  graph [rankdir = LR]
  node [shape=box, style=filled, fillcolor=\&quot;#e6f2ff\&quot;, fontname=\&quot;Arial\&quot;]
  edge [fontname=\&quot;Arial\&quot;]
  # get_FSdata helpers
  get_FSdata [label=\&quot;get_FSdata\&quot;]
  get_FSdata -&gt; lasso_selection
  get_FSdata -&gt; get_conf_force
  get_FSdata -&gt; filter_by_lassokeep
  get_FSdata -&gt; is_continuous
  get_FSdata -&gt; cut_var
  get_FSdata -&gt; process_conf_force_expr
  get_FSdata -&gt; dummy
  get_FSdata -&gt; dummy2
  # grf_subg helpers
  grf_subg [label=\&quot;grf.subg.harm.survival\&quot;]
  grf_subg -&gt; policy_tree
  grf_subg -&gt; causal_survival_forest
  grf_subg -&gt; double_robust_scores
  grf_subg -&gt; aggregate
  # subgroup_search helpers
  subgroup_search [label=\&quot;subgroup.search\&quot;]
  subgroup_search -&gt; get_combinations_info
  subgroup_search -&gt; get_subgroup_membership
  subgroup_search -&gt; get_covs_in
  subgroup_search -&gt; extract_idx_flagredundancy
  # subgroup_consistency helpers
  subgroup_consistency [label=\&quot;subgroup.consistency\&quot;]
  subgroup_consistency -&gt; sort_subgroups
  subgroup_consistency -&gt; extract_subgroup
  subgroup_consistency -&gt; sg_consistency_out
  subgroup_consistency -&gt; remove_redundant_subgroups
  subgroup_consistency -&gt; get_split_hr
  subgroup_consistency -&gt; setup_parallel_SGcons
  # forestsearch_bootstrap helpers
  forestsearch_bootstrap [label=\&quot;forestsearch_bootstrap_dofuture\&quot;]
  forestsearch_bootstrap -&gt; bootstrap_results
  forestsearch_bootstrap -&gt; bootstrap_ystar
  forestsearch_bootstrap -&gt; get_dfRes
  forestsearch_bootstrap -&gt; get_Cox_sg
  forestsearch_bootstrap -&gt; ci_est
  forestsearch_bootstrap -&gt; get_targetEst
  forestsearch_bootstrap -&gt; fit_cox_models
  forestsearch_bootstrap -&gt; build_cox_formula
  forestsearch_bootstrap -&gt; ensure_packages
  forestsearch_bootstrap -&gt; setup_parallel_SGcons
  # SG_tab_estimates helpers
  SG_tab_estimates [label=\&quot;SG_tab_estimates\&quot;]
  SG_tab_estimates -&gt; analyze_subgroup
  analyze_subgroup [label=\&quot;analyze_subgroup\&quot;]
  analyze_subgroup -&gt; cox_summary
  analyze_subgroup -&gt; km_summary
  analyze_subgroup -&gt; rmst_calculation
  analyze_subgroup -&gt; calculate_counts
  analyze_subgroup -&gt; calculate_potential_hr
  SG_tab_estimates -&gt; prepare_subgroup_data
  SG_tab_estimates -&gt; format_results
  SG_tab_estimates -&gt; format_CI
}
&quot;, width = 800, height = 800)
helpers_flow
</code></pre>
<hr />
<h2><strong>Option 2: Two Separate Schematics</strong></h2>
<p>You can also simply run each of the above diagrams in separate R chunks or scripts, and display them one after the other.</p>
<hr />
<h2><strong>Summary</strong></h2>
<ul>
<li><strong>Main Flow</strong>: Shows the high-level function calls.</li>
<li><strong>Helpers Flow</strong>: Shows the helper functions for each main function.</li>
</ul>
<p>This approach makes each diagram easier to read and maintain.<br />
You can adjust the <code>width</code> and <code>height</code> as needed for your display.</p>
<hr />
<p><strong>If you want to show them side by side in an RMarkdown or Shiny app, you can use layout tools (e.g., <code>splitLayout()</code> in Shiny, or columns in RMarkdown).</strong></p></div></body></html>